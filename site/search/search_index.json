{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programa\u00e7\u00e3o Competitiva Ementa Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional. Objetivos Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas. Programas e Sites Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona Bibliografia Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++ Notebooks Stanford University Royal Institute of Technology","title":"Disciplina"},{"location":"#programacao-competitiva","text":"","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"#ementa","text":"Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional.","title":"Ementa"},{"location":"#objetivos","text":"Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas.","title":"Objetivos"},{"location":"#programas-e-sites","text":"Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona","title":"Programas e Sites"},{"location":"#bibliografia","text":"Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++","title":"Bibliografia"},{"location":"#notebooks","text":"Stanford University Royal Institute of Technology","title":"Notebooks"},{"location":"busca/","text":"Busca 1 Busca sequencial A forma mais intuitiva para procurar um elemento em um array \u00e9 usar um loop que percorre todos os elementos do array e parando assim que o elemento buscado \u00e9 encontrado. No pior caso, \u00e9 necess\u00e1rio percorrer todos os elementos, logo a complexidade ser\u00e1 \\(O(n)\\) . O c\u00f3digo abaixo verifica se x est\u00e1 no array : 1 2 3 4 5 for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] == x ) { // x encontrado na posi\u00e7\u00e3o i } } Em C++, pode-se usar a fun\u00e7\u00e3o search . Busca bin\u00e1ria Se os elementos do array estiverem ordenados, pode-se usar uma estrat\u00e9gia diferente e mais eficiente para realizar a busca: verifique se o elemento do meio do array \u00e9 o elementos buscado, se for, a busca termina. Caso n\u00e3o seja, verique se o elemento do meio \u00e9 menor que elemento buscaso, se for, repita o processo considerando apenas a segunda metade do array . Sen\u00e3o, considere a primeira metade do array . Assim, a cada passo da busca, o tamanho do array \u00e9 reduzido a metade, logo, a complexidade do algoritmo \u00e9 \\(O(\\log n)\\) . 1 2 3 4 5 6 7 8 9 10 int buscaBinaria ( vector < int > v , int x ) { int ini = 0 , fim = v . size () -1 ; while ( ini <= fim ) { int meio = ini + ( fim - ini ) / 2 ; // (1) if ( v [ meio ] == x ) return meio ; else if ( v [ meio ] < x ) ini = meio + 1 ; else fim = meio - 1 ; } return -1 ; // (2) } Evite usar meio = (ini + fim) / 2; , j\u00e1 que ini + fim pode gerar integer overflow . x n\u00e3o est\u00e1 no vetor v . Em C++, pode-se usar a fun\u00e7\u00e3o std::binary_search . As fun\u00e7\u00f5es abaixo tamb\u00e9m s\u00e3o \u00fateis e baseadas na busca bin\u00e1ria: std::lower_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 pelo menos x ; std::upper_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 maior que x ; As fun\u00e7\u00f5es assumem que o array est\u00e1 ordenado. Se o valor procurado n\u00e3o for encontrado, \u00e9 retornado um ponteiro para o elemento ap\u00f3s o \u00faltimo elemento do array . Por exemplo, o c\u00f3digo a seguir verifica se o array cont\u00e9m um elemento com valor x : 1 2 3 4 5 6 7 vector < int > v = { 1 , 2 , 3 , 5 , 8 , 10 , 20 }; int x = 10 ; auto k = lower_bound ( v . begin (), v . end (), x ); if ( k != v . end () && * k == x ) { // x encontrado no indice k cout << \"Valor encontrado na posi\u00e7\u00e3o: \" << k - v . begin () << endl ; // (1) } Pode-se usar a fun\u00e7\u00e3o std::distance ao inv\u00e9s de k - v.begin() , ou seja, distance(v.begin(), k) . Complemente sua leitura e seu conhecimento: Binary Search tutorial (C++ and Python) Busca Bin\u00e1ria Binary Search Binary Search (ITMO Academy) \ud83e\udd2f Binary Search (CS Academy) Busca bin\u00e1ria em fun\u00e7\u00f5es monot\u00f4nicas 2 Considere uma fun\u00e7\u00e3o booleana \\(f(x)\\) e se deseja encontrar o valor m\u00e1ximo (ou m\u00ednimo) de \\(x\\) tal que \\(f(x)\\) seja true . Da mesma forma que a busca bin\u00e1ria s\u00f3 funciona se o array estiver ordenado, s\u00f3 \u00e9 possivel aplicar a busca bin\u00e1ria em uma fun\u00e7\u00e3o mon\u00f3tona , ou seja, \u00e9 sempre n\u00e3o-decrescente ou sempre n\u00e3o-crescente. Seja check(x) uma fun\u00e7\u00e3o que verifica uma propriedade de x . Se para todo x , check ( x ) = true implica check ( x + 1 ) = true , ou para todo x , check ( x ) = false implica check ( x + 1 ) = false , ent\u00e3o a fun\u00e7\u00e3o check \u00e9 mon\u00f3tona. Suponha a fun\u00e7\u00e3o check abaixo que verifica se um elemento \u00e9 maior ou igual a x . Se x = 11 e o vetor v = [1, 2, 3, 5, 8, 11, 12, 14, 16] , ent\u00e3o teremos o seguinte vetor de sa\u00edda ao aplicarmos check em v : [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] . 1 2 3 bool check ( int val ) { return val >= x ; } Dessa forma, a fun\u00e7\u00e3o check para essa situa\u00e7\u00e3o \u00e9 mon\u00f3tona e isso \u00e9 relevante porque se um valor do vetor satisfizer a condi\u00e7\u00e3o, todos os valores a direita tamb\u00e9m v\u00e3o satisfaz\u00ea-la, e de forma an\u00e1loga, todos os valores a esquerda de um \u00edndice que n\u00e3o satisfaz a condi\u00e7\u00e3o, tamb\u00e9m n\u00e3o v\u00e3o satisfazer, e \u00e9 isso que nos permite aplicar busca bin\u00e1ria. Al\u00e9m disso, a fun\u00e7\u00e3o check s\u00f3 se torna mon\u00f3tona nesse exemplo quando o vetor est\u00e1 ordenado, por isso a busca bin\u00e1ria s\u00f3 \u00e9 feita em vetores ordenados. Como encontrar o menor valor que torna check verdadeiro? R. inicia-se o processo \"chutanto\" um intervalo onde a resposta com certeza estar\u00e1. Para cada intevalo, checa-se o meio e, dependendo da resposta, descarta-se os elementos a direita ou a esquerda, mas sempre divide-se o tamanho do intervalo por 2, at\u00e9 que o intervalo tenha tamanho 1. Veja uma solu\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int l = a ; // sei que a resposta n\u00e3o \u00e9 menos que a int r = b ; // sei que a resposta n\u00e3o \u00e9 mais que b while ( r > l + 1 ){ // repita enquanto o intervalo tiver tamanho > 2 int mid = l + ( r - l ) / 2 ; if ( check ( mid )){ // mid \u00e9 v\u00e1lido r = mid ; // como queremos minimizar a resposta, e mid \u00e9 uma resposta v\u00e1lida //descartamos tudo a direita de mid (mas n\u00e3o mid) } else { l = mid + 1 ; // Se mid n\u00e3o \u00e9 v\u00e1lido, descartamos ele e tudo abaixo. } } // Ao final desse la\u00e7o, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent\u00e3o se l for v\u00e1lido, // ficaremos com l, e caso contr\u00e1rio, com r int ans = r ; if ( check ( l )) ans = l ; Exemplo: Encontrar o maior valor de \\(x \\in [0, 10]\\) tal que \\(x^2 \\leq 30\\) . 1 2 3 4 5 6 7 8 9 10 11 12 bool check ( int val ) { return val * val <= 30 ; } int lastTrue ( int ini , int fim ) { ini -- ; // Se nenhum valor no intervalor for true, retorna ini - 1 while ( ini < fim ) { int m = ini + ( fim - ini ) / 2 ; if ( check ( m )) ini = m ; // (1) else fim = m - 1 ; // (2) } return ini ; } Se check ( m ) \u00e9 true , ent\u00e3o todos os n\u00fameros menores que m tamb\u00e9m ser\u00e3o true . Se check ( m ) \u00e9 false , ent\u00e3o todos os n\u00fameros maiores que m tamb\u00e9m ser\u00e3o false . Two-Pointers Na t\u00e9cnica chamada Two-Pointers dois \"apontadores\" caminham pelo vetor. Normalmente, esses apontadores s\u00e3o \"colocados\" nas extremidades opostas do vetor e caminham um em dire\u00e7\u00e3o ao outro, como mostra a figura abaixo. Fonte: AfterAcademy Voc\u00ea consegue pensar em como usar esse t\u00e9cnica para resolver o problema de inverter os elementos de um vetor sem usar um vetor auxiliar? A ideia \u00e9 simples: coloque cada apontador (digamos i e j ) em uma extremidade do vetor, ou seja, i = 0 e j = n - 1 , e, a cada itera\u00e7\u00e3o, troque os elementos que est\u00e3o nas posi\u00e7\u00f5es i e j (ou seja, v[i] <-> v[j] ). Ap\u00f3s a troca, incremente o apontador i e decremente o apontador j . Repita esse processo enquanto i < j . A figura abaixo ilustra parte desse processo. Fonte: AfterAcademy O c\u00f3digo abaixo ilustra essa estrat\u00e9gia (note a simplicidade): 1 2 3 4 5 6 7 8 9 void inverte ( vector < int > & v ) { // (1) int i = 0 ; int j = v . size () - 1 ; while ( i < j ) { swap ( v [ i ], v [ j ]); // (2) i ++ ; j -- ; } } A std::reverse tamb\u00e9m pode ser usada com o mesmo objetivo. O intuito \u00e9 mostrar com a t\u00e9cnica Two-Pointers funciona. std::swap Complemente sua leitura e seu conhecimento: Two Pointers Method (ITMO Academy) \ud83e\udd2f Two Pointers Technique What is the Two pointer technique? O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9 Conte\u00fado extra\u00eddo de Busca Bin\u00e1ria \u21a9","title":"Busca"},{"location":"busca/#busca1","text":"","title":"Busca1"},{"location":"busca/#busca-sequencial","text":"A forma mais intuitiva para procurar um elemento em um array \u00e9 usar um loop que percorre todos os elementos do array e parando assim que o elemento buscado \u00e9 encontrado. No pior caso, \u00e9 necess\u00e1rio percorrer todos os elementos, logo a complexidade ser\u00e1 \\(O(n)\\) . O c\u00f3digo abaixo verifica se x est\u00e1 no array : 1 2 3 4 5 for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] == x ) { // x encontrado na posi\u00e7\u00e3o i } } Em C++, pode-se usar a fun\u00e7\u00e3o search .","title":"Busca sequencial"},{"location":"busca/#busca-binaria","text":"Se os elementos do array estiverem ordenados, pode-se usar uma estrat\u00e9gia diferente e mais eficiente para realizar a busca: verifique se o elemento do meio do array \u00e9 o elementos buscado, se for, a busca termina. Caso n\u00e3o seja, verique se o elemento do meio \u00e9 menor que elemento buscaso, se for, repita o processo considerando apenas a segunda metade do array . Sen\u00e3o, considere a primeira metade do array . Assim, a cada passo da busca, o tamanho do array \u00e9 reduzido a metade, logo, a complexidade do algoritmo \u00e9 \\(O(\\log n)\\) . 1 2 3 4 5 6 7 8 9 10 int buscaBinaria ( vector < int > v , int x ) { int ini = 0 , fim = v . size () -1 ; while ( ini <= fim ) { int meio = ini + ( fim - ini ) / 2 ; // (1) if ( v [ meio ] == x ) return meio ; else if ( v [ meio ] < x ) ini = meio + 1 ; else fim = meio - 1 ; } return -1 ; // (2) } Evite usar meio = (ini + fim) / 2; , j\u00e1 que ini + fim pode gerar integer overflow . x n\u00e3o est\u00e1 no vetor v . Em C++, pode-se usar a fun\u00e7\u00e3o std::binary_search . As fun\u00e7\u00f5es abaixo tamb\u00e9m s\u00e3o \u00fateis e baseadas na busca bin\u00e1ria: std::lower_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 pelo menos x ; std::upper_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 maior que x ; As fun\u00e7\u00f5es assumem que o array est\u00e1 ordenado. Se o valor procurado n\u00e3o for encontrado, \u00e9 retornado um ponteiro para o elemento ap\u00f3s o \u00faltimo elemento do array . Por exemplo, o c\u00f3digo a seguir verifica se o array cont\u00e9m um elemento com valor x : 1 2 3 4 5 6 7 vector < int > v = { 1 , 2 , 3 , 5 , 8 , 10 , 20 }; int x = 10 ; auto k = lower_bound ( v . begin (), v . end (), x ); if ( k != v . end () && * k == x ) { // x encontrado no indice k cout << \"Valor encontrado na posi\u00e7\u00e3o: \" << k - v . begin () << endl ; // (1) } Pode-se usar a fun\u00e7\u00e3o std::distance ao inv\u00e9s de k - v.begin() , ou seja, distance(v.begin(), k) . Complemente sua leitura e seu conhecimento: Binary Search tutorial (C++ and Python) Busca Bin\u00e1ria Binary Search Binary Search (ITMO Academy) \ud83e\udd2f Binary Search (CS Academy)","title":"Busca bin\u00e1ria"},{"location":"busca/#busca-binaria-em-funcoes-monotonicas2","text":"Considere uma fun\u00e7\u00e3o booleana \\(f(x)\\) e se deseja encontrar o valor m\u00e1ximo (ou m\u00ednimo) de \\(x\\) tal que \\(f(x)\\) seja true . Da mesma forma que a busca bin\u00e1ria s\u00f3 funciona se o array estiver ordenado, s\u00f3 \u00e9 possivel aplicar a busca bin\u00e1ria em uma fun\u00e7\u00e3o mon\u00f3tona , ou seja, \u00e9 sempre n\u00e3o-decrescente ou sempre n\u00e3o-crescente. Seja check(x) uma fun\u00e7\u00e3o que verifica uma propriedade de x . Se para todo x , check ( x ) = true implica check ( x + 1 ) = true , ou para todo x , check ( x ) = false implica check ( x + 1 ) = false , ent\u00e3o a fun\u00e7\u00e3o check \u00e9 mon\u00f3tona. Suponha a fun\u00e7\u00e3o check abaixo que verifica se um elemento \u00e9 maior ou igual a x . Se x = 11 e o vetor v = [1, 2, 3, 5, 8, 11, 12, 14, 16] , ent\u00e3o teremos o seguinte vetor de sa\u00edda ao aplicarmos check em v : [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] . 1 2 3 bool check ( int val ) { return val >= x ; } Dessa forma, a fun\u00e7\u00e3o check para essa situa\u00e7\u00e3o \u00e9 mon\u00f3tona e isso \u00e9 relevante porque se um valor do vetor satisfizer a condi\u00e7\u00e3o, todos os valores a direita tamb\u00e9m v\u00e3o satisfaz\u00ea-la, e de forma an\u00e1loga, todos os valores a esquerda de um \u00edndice que n\u00e3o satisfaz a condi\u00e7\u00e3o, tamb\u00e9m n\u00e3o v\u00e3o satisfazer, e \u00e9 isso que nos permite aplicar busca bin\u00e1ria. Al\u00e9m disso, a fun\u00e7\u00e3o check s\u00f3 se torna mon\u00f3tona nesse exemplo quando o vetor est\u00e1 ordenado, por isso a busca bin\u00e1ria s\u00f3 \u00e9 feita em vetores ordenados. Como encontrar o menor valor que torna check verdadeiro? R. inicia-se o processo \"chutanto\" um intervalo onde a resposta com certeza estar\u00e1. Para cada intevalo, checa-se o meio e, dependendo da resposta, descarta-se os elementos a direita ou a esquerda, mas sempre divide-se o tamanho do intervalo por 2, at\u00e9 que o intervalo tenha tamanho 1. Veja uma solu\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int l = a ; // sei que a resposta n\u00e3o \u00e9 menos que a int r = b ; // sei que a resposta n\u00e3o \u00e9 mais que b while ( r > l + 1 ){ // repita enquanto o intervalo tiver tamanho > 2 int mid = l + ( r - l ) / 2 ; if ( check ( mid )){ // mid \u00e9 v\u00e1lido r = mid ; // como queremos minimizar a resposta, e mid \u00e9 uma resposta v\u00e1lida //descartamos tudo a direita de mid (mas n\u00e3o mid) } else { l = mid + 1 ; // Se mid n\u00e3o \u00e9 v\u00e1lido, descartamos ele e tudo abaixo. } } // Ao final desse la\u00e7o, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent\u00e3o se l for v\u00e1lido, // ficaremos com l, e caso contr\u00e1rio, com r int ans = r ; if ( check ( l )) ans = l ; Exemplo: Encontrar o maior valor de \\(x \\in [0, 10]\\) tal que \\(x^2 \\leq 30\\) . 1 2 3 4 5 6 7 8 9 10 11 12 bool check ( int val ) { return val * val <= 30 ; } int lastTrue ( int ini , int fim ) { ini -- ; // Se nenhum valor no intervalor for true, retorna ini - 1 while ( ini < fim ) { int m = ini + ( fim - ini ) / 2 ; if ( check ( m )) ini = m ; // (1) else fim = m - 1 ; // (2) } return ini ; } Se check ( m ) \u00e9 true , ent\u00e3o todos os n\u00fameros menores que m tamb\u00e9m ser\u00e3o true . Se check ( m ) \u00e9 false , ent\u00e3o todos os n\u00fameros maiores que m tamb\u00e9m ser\u00e3o false .","title":"Busca bin\u00e1ria em fun\u00e7\u00f5es monot\u00f4nicas2"},{"location":"busca/#two-pointers","text":"Na t\u00e9cnica chamada Two-Pointers dois \"apontadores\" caminham pelo vetor. Normalmente, esses apontadores s\u00e3o \"colocados\" nas extremidades opostas do vetor e caminham um em dire\u00e7\u00e3o ao outro, como mostra a figura abaixo. Fonte: AfterAcademy Voc\u00ea consegue pensar em como usar esse t\u00e9cnica para resolver o problema de inverter os elementos de um vetor sem usar um vetor auxiliar? A ideia \u00e9 simples: coloque cada apontador (digamos i e j ) em uma extremidade do vetor, ou seja, i = 0 e j = n - 1 , e, a cada itera\u00e7\u00e3o, troque os elementos que est\u00e3o nas posi\u00e7\u00f5es i e j (ou seja, v[i] <-> v[j] ). Ap\u00f3s a troca, incremente o apontador i e decremente o apontador j . Repita esse processo enquanto i < j . A figura abaixo ilustra parte desse processo. Fonte: AfterAcademy O c\u00f3digo abaixo ilustra essa estrat\u00e9gia (note a simplicidade): 1 2 3 4 5 6 7 8 9 void inverte ( vector < int > & v ) { // (1) int i = 0 ; int j = v . size () - 1 ; while ( i < j ) { swap ( v [ i ], v [ j ]); // (2) i ++ ; j -- ; } } A std::reverse tamb\u00e9m pode ser usada com o mesmo objetivo. O intuito \u00e9 mostrar com a t\u00e9cnica Two-Pointers funciona. std::swap Complemente sua leitura e seu conhecimento: Two Pointers Method (ITMO Academy) \ud83e\udd2f Two Pointers Technique What is the Two pointer technique? O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9 Conte\u00fado extra\u00eddo de Busca Bin\u00e1ria \u21a9","title":"Two-Pointers"},{"location":"buscaexaustiva/","text":"Busca Exaustiva (Recurs\u00e3o + Backtracking) 1 Uma busca exaustiva ou busca completa tem por objetivo gerar todas as solu\u00e7\u00f5es poss\u00edveis para um determinado problema usando for\u00e7a bruta e ent\u00e3o selecionar a melhor solu\u00e7\u00e3o ou contar o n\u00famero de solu\u00e7\u00f5es, dependendo do problema. A busca exaustiva \u00e9 uma boa t\u00e9cnica se houver tempo suficiente para gerar todas as solu\u00e7\u00f5es, pois geralmente \u00e9 f\u00e1cil de implementar e sempre fornece a resposta correta. Entretanto, se o n\u00famero de solu\u00e7\u00f5es for muito grande ou a gera\u00e7\u00e3o das solu\u00e7\u00f5es for demorada, outras t\u00e9cnicas, como algoritmos gulosos ou programa\u00e7\u00e3o din\u00e2mica , podem ser necess\u00e1rias. Gerando subconjuntos Nesse problema, deseja-se gerar todos os subconjuntos de \\(n\\) elementos ou de um conjunto espec\u00edfico. Por exemplo, os subconjuntos de \\(\\{0, 1, 2\\}\\) s\u00e3o: \\(\\emptyset\\) , \\(\\{0\\}\\) , \\(\\{1\\}\\) , \\(\\{2\\}\\) , \\(\\{0,1\\}\\) , \\(\\{0,2\\}\\) , \\(\\{1,2\\}\\) e \\(\\{0,1,2\\}\\) . Existem dois m\u00e9todos comuns para gerar subconjuntos: realizar uma busca recursiva ou explorar a representa\u00e7\u00e3o de bits de inteiros. M\u00e9todo 1 Uma maneira elegante de gerar todos os subconjuntos de um conjunto \u00e9 usar recurs\u00e3o. A fun\u00e7\u00e3o abaixo gera os subconjuntos do conjunto \\(\\{0,1,\\dots ,n - 1\\}\\) . A fun\u00e7\u00e3o utiliza um vetor booleano para definir se o elemento \\(i\\) pertence ou n\u00e3o ao subconjunto. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 typedef long long ll ; vector < bool > subconj ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << i << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; subconj . resize ( n + 1 , false ); geraSubconjuntos ( n ); return 0 ; } M\u00e9todo 2 Outra maneira de gerar subconjuntos \u00e9 baseada na representa\u00e7\u00e3o de bits de inteiros. Cada subconjunto de um conjunto de \\(n\\) elementos pode ser representado como uma sequ\u00eancia de \\(n\\) bits, que corresponde a um inteiro entre \\(0 \\dots 2^n \u22121\\) . Os bits 1 da sequ\u00eancia de bits indicam quais elementos est\u00e3o inclu\u00eddos no subconjunto. A conven\u00e7\u00e3o usual \u00e9 que o \u00faltimo bit corresponde ao elemento \\(0\\) , o pen\u00faltimo bit corresponde ao elemento \\(1\\) e assim por diante. Por exemplo, a representa\u00e7\u00e3o de bit de \\(25\\) \u00e9 \\(11001\\) , que corresponde ao subconjunto \\(\\{0,3,4\\}\\) . O c\u00f3digo abaixo gera os subconjuntos de um conjunto de \\(n\\) elementos baseado nesse m\u00e9todo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void imprime ( vector < ll > subconj ) { cout << \"{ \" ; for ( auto i : subconj ) cout << i << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n ) { for ( ll b = 0 ; b < ( 1 << n ); b ++ ) { vector < ll > subconj ; for ( ll i = 0 ; i < n ; i ++ ) { if ( b & ( 1 << i )) subconj . push_back ( i ); } imprime ( subconj ); } } int main () { ll n ; cin >> n ; geraSubconjuntos ( n ); return 0 ; } Exemplos Gerar todos os subconjuntos de um conjunto de valores lidos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Gerar todos os subconjuntos de um conjunto de valores lidos cuja soma seja menor ou igual a um limitante 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; ll limite ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } ll soma ( ll n ) { ll s = 0 ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) s += valores [ i ]; return s ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( i == n ) { if ( soma ( n ) <= limite ) imprime ( n ); return ; } subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; cin >> limite ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Mesmo que o anterior, mas \"corta\" o backtracking assim que chega em um subconjunto cuja soma seja maior que o limite . Assim, n\u00e3o espera terminar de gerar o subconjunto para testar a soma, por isso \u00e9 bem mais r\u00e1pido. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; ll limite ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } ll soma ( ll n ) { ll s = 0 ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) s += valores [ i ]; return s ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( soma ( n ) > limite ) return ; if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; cin >> limite ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Mesmo que o anterior, mas n\u00e3o recalcula a soma dos elementos (chamada da fun\u00e7\u00e3o soma que \u00e9 \\(O(n)\\) ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; ll limite ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n , ll i = 0 , ll soma = 0 ) { if ( soma > limite ) return ; if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 , soma + valores [ i ]); subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 , soma ); } int main () { ll n ; cin >> n ; cin >> limite ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Gerando permuta\u00e7\u00f5es Considere agora o problema de gerar todas as permuta\u00e7\u00f5es de um conjunto de \\(n\\) elementos. Por exemplo, as permuta\u00e7\u00f5es de \\(\\{0,1,2\\}\\) s\u00e3o \\((0,1,2)\\) , \\((0,2,1)\\) , \\((1,0,2)\\) , \\((1,2,0)\\) , \\((2,0 ,1\\) ) e \\((2,1,0)\\) . Novamente, existem duas abordagens: usar a recurs\u00e3o ou percorrer as permuta\u00e7\u00f5es iterativamente. M\u00e9todo 1 Assim como no problema de gerar os subconjuntos, as permuta\u00e7\u00f5es tamb\u00e9m podem ser geradas usando recurs\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 typedef long long ll ; vector < ll > permutacao ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << permutacao [ i ] << \" \" ; cout << \") \\n \" ; } void geraPermutacao ( ll n ) { if ( permutacao . size () == n ) { imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); geraPermutacao ( n ); return 0 ; } M\u00e9todo 2 Outra alternativa \u00e9 usar a fun\u00e7\u00e3o da biblioteca padr\u00e3o do C++ next_permutation , que a cada chamada constr\u00f3i a pr\u00f3xima permuta\u00e7\u00e3o em ordem crescente. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef long long ll ; vector < ll > permutacao ; void imprime () { cout << \"( \" ; for ( auto x : permutacao ) cout << x << \" \" ; cout << \") \\n \" ; } int main () { ll n ; cin >> n ; permutacao . resize ( n , false ); iota ( permutacao . begin (), permutacao . end (), 0 ); // (1) do { //Processa a permuta\u00e7\u00e3o imprime (); } while ( next_permutation ( permutacao . begin (), permutacao . end ())); return 0 ; } std:iota Exemplos Gera todas as permuta\u00e7\u00f5es de a partir de valores lidos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 typedef long long ll ; vector < ll > permutacao , valores ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << valores [ permutacao [ i ]] << \" \" ; cout << \") \\n \" ; } void geraPermutacao ( ll n ) { if ( permutacao . size () == n ) { imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraPermutacao ( n ); return 0 ; } Gera todas as permuta\u00e7\u00f5es de \\({0, 1, 2, 3, \\dots, n-1}\\) em que 2 e 3 n\u00e3o aparecem seguidos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 typedef long long ll ; vector < ll > permutacao ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << permutacao [ i ] << \" \" ; cout << \") \\n \" ; } bool seguidos () { for ( ll i = 0 ; i < permutacao . size () - 1 ; i ++ ) if ( permutacao [ i ] == 2 && permutacao [ i + 1 ] == 3 ) return true ; return false ; } void geraPermutacao ( ll n ) { if ( permutacao . size () == n ) { if ( ! seguidos ()) imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); geraPermutacao ( n ); return 0 ; } Mesmo que o anterior, mas corta o backtracking t\u00e3o logo 2 e 3 apare\u00e7am seguidos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 typedef long long ll ; vector < ll > permutacao ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << permutacao [ i ] << \" \" ; cout << \") \\n \" ; } bool seguidos () { for ( ll i = 0 ; i < permutacao . size () - 1 ; i ++ ) if ( permutacao [ i ] == 2 && permutacao [ i + 1 ] == 3 ) return true ; return false ; } void geraPermutacao ( ll n ) { if ( seguidos ()) return ; if ( permutacao . size () == n ) { imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); geraPermutacao ( n ); return 0 ; } Backtracking Backtracking (tamb\u00e9m chamado de tentativa e erro ou for\u00e7a bruta ) \u00e9 uma t\u00e9cnica que usa recursividade para gerar/enumerar/percorrer sistematicamente todas as alternativas no espa\u00e7o de solu\u00e7\u00f5es. O m\u00e9todo constr\u00f3i solu\u00e7\u00f5es candidatas incrementalmente e abandona ( backtrack ) uma solu\u00e7\u00e3o parcial quando identifica que tal solu\u00e7\u00e3o parcial n\u00e3o levar\u00e1 a uma solu\u00e7\u00e3o do problema. Como dito, \u00e9 um m\u00e9todo de tentativa e erro: tenta um caminho, se n\u00e3o der certo, volta e tenta outro. Assim, a ideia por tr\u00e1s de um algoritmo backtracking \u00e9 que ele busca uma solu\u00e7\u00e3o para um problema entre todas as op\u00e7\u00f5es dispon\u00edveis. Existem tr\u00eas tipos de problemas que s\u00e3o comumente resolvidos com Backtracking: Problema de Decis\u00e3o \u2013 Neste, busca-se uma solu\u00e7\u00e3o vi\u00e1vel. Problema de Otimiza\u00e7\u00e3o \u2013 Neste, deseja-se a melhor solu\u00e7\u00e3o. Problema de Enumera\u00e7\u00e3o \u2013 Neste, busca-se encontrar todas as solu\u00e7\u00f5es vi\u00e1veis. Algoritmo Geral O c\u00f3digo abaixo ilustra a ideia geral de um algoritmo backtracking. Note que essa ideia foi usada nos algoritmos para gerar subconjuntos e permuta\u00e7\u00f5es 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // int a[] - solu\u00e7\u00e3o parcial, de a[0] at\u00e9 a[k-1] // int k - posi\u00e7\u00e3o para inserir o pr\u00f3ximo passo // int n - tamanho m\u00e1ximo da solu\u00e7\u00e3o void backtrack ( int a [], int k , int n ) { // \u00c9 importante cortar a busca t\u00e3o logo se descubra que n\u00e3o levar\u00e1 a uma solu\u00e7\u00e3o if ( /* n\u00e3o h\u00e1 como continuar */ ) // Corte return ; if ( /* terminou */ ) { // se chegou numa poss\u00edvel solu\u00e7\u00e3o /* processa solucao */ return ; } for ( /* toda alternativa */ ) // para toda alternativa if ( /* alternativa vi\u00e1vel */ ) { // se pode inclu\u00ed-la a [ k ] = /* alternativa */ ; // inclui na solu\u00e7\u00e3o parcial backtrack ( a , k + 1 , n ); // gera o restante } } Exemplos Procura a sa\u00edda de um labirinto, sendo . espa\u00e7o livre e # as paredes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* Exemplo de entrada: 7 8 ######## #..#...# ##...#.. #.#.##.# #....#.# ##.#..## ######## 5 3 Sa\u00edda: Sa\u00edda encontrada: ######## #..#ooo# ##.oo#os #.#o##.# #.oo.#.# ##.#..## ######## */ #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll nl , nc , li , ci ; vector < vector < char >> mapa ; bool achouSaida = false ; void imprime () { for ( ll l = 0 ; l < nl ; l ++ , cout << \" \\n \" ) for ( ll c = 0 ; c < nc ; c ++ ) cout << mapa [ l ][ c ]; } void caminha ( ll l , ll c ) { // Se achou solu\u00e7\u00e3o, n\u00e3o precisa continuar if ( achouSaida ) return ; // Verifica se 'l' e 'c' s\u00e3o valores v\u00e1lidos if ( l < 0 || c < 0 || l >= nl || c >= nc ) return ; // Verifica se a posi\u00e7\u00e3o n\u00e3o \u00e9 parede if ( mapa [ l ][ c ] != '.' ) return ; // Verifica se chegou em uma das extremidades do mapa. // Se chegou, achou a sa\u00edda. if ( l == 0 || c == 0 || l == nl - 1 || c == nc - 1 ) { mapa [ l ][ c ] = 's' ; achouSaida = true ; return ; } // Se n\u00e3o retornou ainda, \u00e9 porque o processo deve continuar mapa [ l ][ c ] = 'o' ; // Marca o mapa, indicando que foi passado nessa posi\u00e7\u00e3o caminha ( l , c - 1 ); // Tenta caminhar para tr\u00e1s caminha ( l + 1 , c ); // Tenta caminhar para baixo caminha ( l , c + 1 ); // Tenta caminhar para frente caminha ( l - 1 , c ); // Tenta caminhar para cima // Se n\u00e3o achou sa\u00edda, desmarca no mapa if ( ! achouSaida ) mapa [ l ][ c ] = '.' ; } int main () { cin >> nl >> nc ; mapa . resize ( nl , vector < char > ( nc )); for ( ll l = 0 ; l < nl ; l ++ ) for ( ll c = 0 ; c < nc ; c ++ ) cin >> mapa [ l ][ c ]; cin >> li >> ci ; caminha ( li - 1 , ci - 1 ); if ( achouSaida ) { cout << \"Sa\u00edda encontrada:\" << endl ; imprime (); } else cout << \"Solu\u00e7\u00e3o n\u00e3o encontrada\" << endl ; return 0 ; } Conta o n\u00famero de regi\u00f5es. Semelhante ao do labrinto, mas caminha nos # marcando toda uma regi\u00e3o cercada por \"\u00e1gua\", simbolizada por . . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* Exemplo de entrada: 7 8 ..#...#. ..#####. #...#... ##...... ###...#. .....### ..#...#. Sa\u00edda: N\u00famero de regi\u00f5es: 4 ..1...1. ..11111. 2...1... 22...... 222...3. .....333 ..4...3. */ #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll nl , nc ; vector < vector < string >> mapa ; void imprime () { for ( ll l = 0 ; l < nl ; l ++ , cout << \" \\n \" ) for ( ll c = 0 ; c < nc ; c ++ ) cout << mapa [ l ][ c ]; } void caminha ( ll l , ll c , ll nr ) { // Verifica se 'l' e 'c' s\u00e3o valores v\u00e1lidos if ( l < 0 || c < 0 || l >= nl || c >= nc ) return ; // Se a posi\u00e7\u00e3o n\u00e3o for uma regi\u00e3o, retorne if ( mapa [ l ][ c ] != \"#\" ) return ; // Se n\u00e3o retornou ainda, \u00e9 porque o processo deve continuar mapa [ l ][ c ] = to_string ( nr ); // Marca no mapa o n\u00famero da regi\u00e3o caminha ( l , c - 1 , nr ); // Tenta caminhar para tr\u00e1s caminha ( l + 1 , c , nr ); // Tenta caminhar para baixo caminha ( l , c + 1 , nr ); // Tenta caminhar para frente caminha ( l - 1 , c , nr ); // Tenta caminhar para cima } int main () { cin >> nl >> nc ; mapa . resize ( nl , vector < string > ( nc )); char v ; for ( ll l = 0 ; l < nl ; l ++ ) for ( ll c = 0 ; c < nc ; c ++ ) { cin >> v ; // (1) mapa [ l ][ c ] = v ; } ll numRegioes = 0 ; // Procura pelas regi\u00f5es ainda n\u00e3o marcadas for ( ll l = 0 ; l < nl ; l ++ ) for ( ll c = 0 ; c < nc ; c ++ ) { if ( mapa [ l ][ c ] == \"#\" ) { // Encontrou uma regi\u00e3o numRegioes ++ ; caminha ( l , c , numRegioes ); // Marca a regi\u00e3o } } cout << \"N\u00famero de regi\u00f5es: \" << numRegioes << endl ; imprime (); return 0 ; } Se for feito cin >> mapa[l][c]; , a linha toda ser\u00e1 atribuida a posi\u00e7\u00e3o mapa[l][c] . Material complementar Backtracking Algorithms (GeeksforGeeks) Os textos dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados nesse link: 1 \u21a9","title":"Busca Exaustiva"},{"location":"buscaexaustiva/#busca-exaustiva-recursao-backtracking1","text":"Uma busca exaustiva ou busca completa tem por objetivo gerar todas as solu\u00e7\u00f5es poss\u00edveis para um determinado problema usando for\u00e7a bruta e ent\u00e3o selecionar a melhor solu\u00e7\u00e3o ou contar o n\u00famero de solu\u00e7\u00f5es, dependendo do problema. A busca exaustiva \u00e9 uma boa t\u00e9cnica se houver tempo suficiente para gerar todas as solu\u00e7\u00f5es, pois geralmente \u00e9 f\u00e1cil de implementar e sempre fornece a resposta correta. Entretanto, se o n\u00famero de solu\u00e7\u00f5es for muito grande ou a gera\u00e7\u00e3o das solu\u00e7\u00f5es for demorada, outras t\u00e9cnicas, como algoritmos gulosos ou programa\u00e7\u00e3o din\u00e2mica , podem ser necess\u00e1rias.","title":"Busca Exaustiva (Recurs\u00e3o + Backtracking)1"},{"location":"buscaexaustiva/#gerando-subconjuntos","text":"Nesse problema, deseja-se gerar todos os subconjuntos de \\(n\\) elementos ou de um conjunto espec\u00edfico. Por exemplo, os subconjuntos de \\(\\{0, 1, 2\\}\\) s\u00e3o: \\(\\emptyset\\) , \\(\\{0\\}\\) , \\(\\{1\\}\\) , \\(\\{2\\}\\) , \\(\\{0,1\\}\\) , \\(\\{0,2\\}\\) , \\(\\{1,2\\}\\) e \\(\\{0,1,2\\}\\) . Existem dois m\u00e9todos comuns para gerar subconjuntos: realizar uma busca recursiva ou explorar a representa\u00e7\u00e3o de bits de inteiros. M\u00e9todo 1 Uma maneira elegante de gerar todos os subconjuntos de um conjunto \u00e9 usar recurs\u00e3o. A fun\u00e7\u00e3o abaixo gera os subconjuntos do conjunto \\(\\{0,1,\\dots ,n - 1\\}\\) . A fun\u00e7\u00e3o utiliza um vetor booleano para definir se o elemento \\(i\\) pertence ou n\u00e3o ao subconjunto. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 typedef long long ll ; vector < bool > subconj ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << i << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; subconj . resize ( n + 1 , false ); geraSubconjuntos ( n ); return 0 ; } M\u00e9todo 2 Outra maneira de gerar subconjuntos \u00e9 baseada na representa\u00e7\u00e3o de bits de inteiros. Cada subconjunto de um conjunto de \\(n\\) elementos pode ser representado como uma sequ\u00eancia de \\(n\\) bits, que corresponde a um inteiro entre \\(0 \\dots 2^n \u22121\\) . Os bits 1 da sequ\u00eancia de bits indicam quais elementos est\u00e3o inclu\u00eddos no subconjunto. A conven\u00e7\u00e3o usual \u00e9 que o \u00faltimo bit corresponde ao elemento \\(0\\) , o pen\u00faltimo bit corresponde ao elemento \\(1\\) e assim por diante. Por exemplo, a representa\u00e7\u00e3o de bit de \\(25\\) \u00e9 \\(11001\\) , que corresponde ao subconjunto \\(\\{0,3,4\\}\\) . O c\u00f3digo abaixo gera os subconjuntos de um conjunto de \\(n\\) elementos baseado nesse m\u00e9todo. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void imprime ( vector < ll > subconj ) { cout << \"{ \" ; for ( auto i : subconj ) cout << i << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n ) { for ( ll b = 0 ; b < ( 1 << n ); b ++ ) { vector < ll > subconj ; for ( ll i = 0 ; i < n ; i ++ ) { if ( b & ( 1 << i )) subconj . push_back ( i ); } imprime ( subconj ); } } int main () { ll n ; cin >> n ; geraSubconjuntos ( n ); return 0 ; }","title":"Gerando subconjuntos"},{"location":"buscaexaustiva/#exemplos","text":"Gerar todos os subconjuntos de um conjunto de valores lidos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Gerar todos os subconjuntos de um conjunto de valores lidos cuja soma seja menor ou igual a um limitante 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; ll limite ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } ll soma ( ll n ) { ll s = 0 ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) s += valores [ i ]; return s ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( i == n ) { if ( soma ( n ) <= limite ) imprime ( n ); return ; } subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; cin >> limite ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Mesmo que o anterior, mas \"corta\" o backtracking assim que chega em um subconjunto cuja soma seja maior que o limite . Assim, n\u00e3o espera terminar de gerar o subconjunto para testar a soma, por isso \u00e9 bem mais r\u00e1pido. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; ll limite ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } ll soma ( ll n ) { ll s = 0 ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) s += valores [ i ]; return s ; } void geraSubconjuntos ( ll n , ll i = 0 ) { if ( soma ( n ) > limite ) return ; if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 ); } int main () { ll n ; cin >> n ; cin >> limite ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; } Mesmo que o anterior, mas n\u00e3o recalcula a soma dos elementos (chamada da fun\u00e7\u00e3o soma que \u00e9 \\(O(n)\\) ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 typedef long long ll ; vector < bool > subconj ; vector < ll > valores ; ll limite ; void imprime ( ll n ) { cout << \"{ \" ; for ( ll i = 0 ; i < n ; i ++ ) if ( subconj [ i ]) cout << valores [ i ] << \" \" ; cout << \"} \\n \" ; } void geraSubconjuntos ( ll n , ll i = 0 , ll soma = 0 ) { if ( soma > limite ) return ; if ( i == n ) { imprime ( n ); return ; } subconj [ i ] = true ; // Elemento i est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 , soma + valores [ i ]); subconj [ i ] = false ; // Elemento i n\u00e3o est\u00e1 no subconjunto geraSubconjuntos ( n , i + 1 , soma ); } int main () { ll n ; cin >> n ; cin >> limite ; subconj . resize ( n + 1 , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraSubconjuntos ( n ); return 0 ; }","title":"Exemplos"},{"location":"buscaexaustiva/#gerando-permutacoes","text":"Considere agora o problema de gerar todas as permuta\u00e7\u00f5es de um conjunto de \\(n\\) elementos. Por exemplo, as permuta\u00e7\u00f5es de \\(\\{0,1,2\\}\\) s\u00e3o \\((0,1,2)\\) , \\((0,2,1)\\) , \\((1,0,2)\\) , \\((1,2,0)\\) , \\((2,0 ,1\\) ) e \\((2,1,0)\\) . Novamente, existem duas abordagens: usar a recurs\u00e3o ou percorrer as permuta\u00e7\u00f5es iterativamente. M\u00e9todo 1 Assim como no problema de gerar os subconjuntos, as permuta\u00e7\u00f5es tamb\u00e9m podem ser geradas usando recurs\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 typedef long long ll ; vector < ll > permutacao ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << permutacao [ i ] << \" \" ; cout << \") \\n \" ; } void geraPermutacao ( ll n ) { if ( permutacao . size () == n ) { imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); geraPermutacao ( n ); return 0 ; } M\u00e9todo 2 Outra alternativa \u00e9 usar a fun\u00e7\u00e3o da biblioteca padr\u00e3o do C++ next_permutation , que a cada chamada constr\u00f3i a pr\u00f3xima permuta\u00e7\u00e3o em ordem crescente. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef long long ll ; vector < ll > permutacao ; void imprime () { cout << \"( \" ; for ( auto x : permutacao ) cout << x << \" \" ; cout << \") \\n \" ; } int main () { ll n ; cin >> n ; permutacao . resize ( n , false ); iota ( permutacao . begin (), permutacao . end (), 0 ); // (1) do { //Processa a permuta\u00e7\u00e3o imprime (); } while ( next_permutation ( permutacao . begin (), permutacao . end ())); return 0 ; } std:iota","title":"Gerando permuta\u00e7\u00f5es"},{"location":"buscaexaustiva/#exemplos_1","text":"Gera todas as permuta\u00e7\u00f5es de a partir de valores lidos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 typedef long long ll ; vector < ll > permutacao , valores ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << valores [ permutacao [ i ]] << \" \" ; cout << \") \\n \" ; } void geraPermutacao ( ll n ) { if ( permutacao . size () == n ) { imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); valores . resize ( n ); for ( ll i = 0 ; i < n ; i ++ ) cin >> valores [ i ]; geraPermutacao ( n ); return 0 ; } Gera todas as permuta\u00e7\u00f5es de \\({0, 1, 2, 3, \\dots, n-1}\\) em que 2 e 3 n\u00e3o aparecem seguidos. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 typedef long long ll ; vector < ll > permutacao ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << permutacao [ i ] << \" \" ; cout << \") \\n \" ; } bool seguidos () { for ( ll i = 0 ; i < permutacao . size () - 1 ; i ++ ) if ( permutacao [ i ] == 2 && permutacao [ i + 1 ] == 3 ) return true ; return false ; } void geraPermutacao ( ll n ) { if ( permutacao . size () == n ) { if ( ! seguidos ()) imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); geraPermutacao ( n ); return 0 ; } Mesmo que o anterior, mas corta o backtracking t\u00e3o logo 2 e 3 apare\u00e7am seguidos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 typedef long long ll ; vector < ll > permutacao ; vector < bool > pertence ; void imprime ( ll n ) { cout << \"( \" ; for ( ll i = 0 ; i < n ; i ++ ) cout << permutacao [ i ] << \" \" ; cout << \") \\n \" ; } bool seguidos () { for ( ll i = 0 ; i < permutacao . size () - 1 ; i ++ ) if ( permutacao [ i ] == 2 && permutacao [ i + 1 ] == 3 ) return true ; return false ; } void geraPermutacao ( ll n ) { if ( seguidos ()) return ; if ( permutacao . size () == n ) { imprime ( n ); return ; } for ( ll i = 0 ; i < n ; i ++ ) { if ( pertence [ i ]) continue ; pertence [ i ] = true ; // Inclui o elemento i na permuta\u00e7\u00e3o permutacao . push_back ( i ); geraPermutacao ( n ); // Gera o restante da permuta\u00e7\u00e3o pertence [ i ] = false ; // Remove o elemento i da permuta\u00e7\u00e3o permutacao . pop_back (); } } int main () { ll n ; cin >> n ; pertence . resize ( n , false ); geraPermutacao ( n ); return 0 ; }","title":"Exemplos"},{"location":"buscaexaustiva/#backtracking","text":"Backtracking (tamb\u00e9m chamado de tentativa e erro ou for\u00e7a bruta ) \u00e9 uma t\u00e9cnica que usa recursividade para gerar/enumerar/percorrer sistematicamente todas as alternativas no espa\u00e7o de solu\u00e7\u00f5es. O m\u00e9todo constr\u00f3i solu\u00e7\u00f5es candidatas incrementalmente e abandona ( backtrack ) uma solu\u00e7\u00e3o parcial quando identifica que tal solu\u00e7\u00e3o parcial n\u00e3o levar\u00e1 a uma solu\u00e7\u00e3o do problema. Como dito, \u00e9 um m\u00e9todo de tentativa e erro: tenta um caminho, se n\u00e3o der certo, volta e tenta outro. Assim, a ideia por tr\u00e1s de um algoritmo backtracking \u00e9 que ele busca uma solu\u00e7\u00e3o para um problema entre todas as op\u00e7\u00f5es dispon\u00edveis. Existem tr\u00eas tipos de problemas que s\u00e3o comumente resolvidos com Backtracking: Problema de Decis\u00e3o \u2013 Neste, busca-se uma solu\u00e7\u00e3o vi\u00e1vel. Problema de Otimiza\u00e7\u00e3o \u2013 Neste, deseja-se a melhor solu\u00e7\u00e3o. Problema de Enumera\u00e7\u00e3o \u2013 Neste, busca-se encontrar todas as solu\u00e7\u00f5es vi\u00e1veis. Algoritmo Geral O c\u00f3digo abaixo ilustra a ideia geral de um algoritmo backtracking. Note que essa ideia foi usada nos algoritmos para gerar subconjuntos e permuta\u00e7\u00f5es 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // int a[] - solu\u00e7\u00e3o parcial, de a[0] at\u00e9 a[k-1] // int k - posi\u00e7\u00e3o para inserir o pr\u00f3ximo passo // int n - tamanho m\u00e1ximo da solu\u00e7\u00e3o void backtrack ( int a [], int k , int n ) { // \u00c9 importante cortar a busca t\u00e3o logo se descubra que n\u00e3o levar\u00e1 a uma solu\u00e7\u00e3o if ( /* n\u00e3o h\u00e1 como continuar */ ) // Corte return ; if ( /* terminou */ ) { // se chegou numa poss\u00edvel solu\u00e7\u00e3o /* processa solucao */ return ; } for ( /* toda alternativa */ ) // para toda alternativa if ( /* alternativa vi\u00e1vel */ ) { // se pode inclu\u00ed-la a [ k ] = /* alternativa */ ; // inclui na solu\u00e7\u00e3o parcial backtrack ( a , k + 1 , n ); // gera o restante } }","title":"Backtracking"},{"location":"buscaexaustiva/#exemplos_2","text":"Procura a sa\u00edda de um labirinto, sendo . espa\u00e7o livre e # as paredes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /* Exemplo de entrada: 7 8 ######## #..#...# ##...#.. #.#.##.# #....#.# ##.#..## ######## 5 3 Sa\u00edda: Sa\u00edda encontrada: ######## #..#ooo# ##.oo#os #.#o##.# #.oo.#.# ##.#..## ######## */ #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll nl , nc , li , ci ; vector < vector < char >> mapa ; bool achouSaida = false ; void imprime () { for ( ll l = 0 ; l < nl ; l ++ , cout << \" \\n \" ) for ( ll c = 0 ; c < nc ; c ++ ) cout << mapa [ l ][ c ]; } void caminha ( ll l , ll c ) { // Se achou solu\u00e7\u00e3o, n\u00e3o precisa continuar if ( achouSaida ) return ; // Verifica se 'l' e 'c' s\u00e3o valores v\u00e1lidos if ( l < 0 || c < 0 || l >= nl || c >= nc ) return ; // Verifica se a posi\u00e7\u00e3o n\u00e3o \u00e9 parede if ( mapa [ l ][ c ] != '.' ) return ; // Verifica se chegou em uma das extremidades do mapa. // Se chegou, achou a sa\u00edda. if ( l == 0 || c == 0 || l == nl - 1 || c == nc - 1 ) { mapa [ l ][ c ] = 's' ; achouSaida = true ; return ; } // Se n\u00e3o retornou ainda, \u00e9 porque o processo deve continuar mapa [ l ][ c ] = 'o' ; // Marca o mapa, indicando que foi passado nessa posi\u00e7\u00e3o caminha ( l , c - 1 ); // Tenta caminhar para tr\u00e1s caminha ( l + 1 , c ); // Tenta caminhar para baixo caminha ( l , c + 1 ); // Tenta caminhar para frente caminha ( l - 1 , c ); // Tenta caminhar para cima // Se n\u00e3o achou sa\u00edda, desmarca no mapa if ( ! achouSaida ) mapa [ l ][ c ] = '.' ; } int main () { cin >> nl >> nc ; mapa . resize ( nl , vector < char > ( nc )); for ( ll l = 0 ; l < nl ; l ++ ) for ( ll c = 0 ; c < nc ; c ++ ) cin >> mapa [ l ][ c ]; cin >> li >> ci ; caminha ( li - 1 , ci - 1 ); if ( achouSaida ) { cout << \"Sa\u00edda encontrada:\" << endl ; imprime (); } else cout << \"Solu\u00e7\u00e3o n\u00e3o encontrada\" << endl ; return 0 ; } Conta o n\u00famero de regi\u00f5es. Semelhante ao do labrinto, mas caminha nos # marcando toda uma regi\u00e3o cercada por \"\u00e1gua\", simbolizada por . . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /* Exemplo de entrada: 7 8 ..#...#. ..#####. #...#... ##...... ###...#. .....### ..#...#. Sa\u00edda: N\u00famero de regi\u00f5es: 4 ..1...1. ..11111. 2...1... 22...... 222...3. .....333 ..4...3. */ #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll nl , nc ; vector < vector < string >> mapa ; void imprime () { for ( ll l = 0 ; l < nl ; l ++ , cout << \" \\n \" ) for ( ll c = 0 ; c < nc ; c ++ ) cout << mapa [ l ][ c ]; } void caminha ( ll l , ll c , ll nr ) { // Verifica se 'l' e 'c' s\u00e3o valores v\u00e1lidos if ( l < 0 || c < 0 || l >= nl || c >= nc ) return ; // Se a posi\u00e7\u00e3o n\u00e3o for uma regi\u00e3o, retorne if ( mapa [ l ][ c ] != \"#\" ) return ; // Se n\u00e3o retornou ainda, \u00e9 porque o processo deve continuar mapa [ l ][ c ] = to_string ( nr ); // Marca no mapa o n\u00famero da regi\u00e3o caminha ( l , c - 1 , nr ); // Tenta caminhar para tr\u00e1s caminha ( l + 1 , c , nr ); // Tenta caminhar para baixo caminha ( l , c + 1 , nr ); // Tenta caminhar para frente caminha ( l - 1 , c , nr ); // Tenta caminhar para cima } int main () { cin >> nl >> nc ; mapa . resize ( nl , vector < string > ( nc )); char v ; for ( ll l = 0 ; l < nl ; l ++ ) for ( ll c = 0 ; c < nc ; c ++ ) { cin >> v ; // (1) mapa [ l ][ c ] = v ; } ll numRegioes = 0 ; // Procura pelas regi\u00f5es ainda n\u00e3o marcadas for ( ll l = 0 ; l < nl ; l ++ ) for ( ll c = 0 ; c < nc ; c ++ ) { if ( mapa [ l ][ c ] == \"#\" ) { // Encontrou uma regi\u00e3o numRegioes ++ ; caminha ( l , c , numRegioes ); // Marca a regi\u00e3o } } cout << \"N\u00famero de regi\u00f5es: \" << numRegioes << endl ; imprime (); return 0 ; } Se for feito cin >> mapa[l][c]; , a linha toda ser\u00e1 atribuida a posi\u00e7\u00e3o mapa[l][c] .","title":"Exemplos"},{"location":"buscaexaustiva/#material-complementar","text":"Backtracking Algorithms (GeeksforGeeks) Os textos dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados nesse link: 1 \u21a9","title":"Material complementar"},{"location":"combinatoria/","text":"Combinat\u00f3ria Sugere-se a leitura dos seguintes conte\u00fados: Basics of Combinatorics (HackerEarth) Basics of Combinatorics (TopCoder) Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving","title":"Combinat\u00f3ria"},{"location":"combinatoria/#combinatoria","text":"Sugere-se a leitura dos seguintes conte\u00fados: Basics of Combinatorics (HackerEarth) Basics of Combinatorics (TopCoder) Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving","title":"Combinat\u00f3ria"},{"location":"complexidade/","text":"Complexidade de Algoritmos Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, pode-se descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"complexidade/#complexidade-de-algoritmos","text":"Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, pode-se descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"ed1/","text":"Estrutura de Dados e STL 1 Estrutura de dados (ED) \u00e9 a forma como os dados s\u00e3o armazenados na mem\u00f3ria do computador com o objetivo de tornar o processamento mais f\u00e1cil e eficiente. Cada uma possui suas pr\u00f3prias vantagens e desvantagens, por isso, \u00e9 crucial conhecer diferentes estruturas de dados (b\u00e1sicas e avan\u00e7adas) para conseguir definir qual as mais apropriada para um determinado problema. Em programa\u00e7\u00e3o competitiva, com o objetivo de economizar uma grande quantidade de tempo ao implementar um algoritmo, tamb\u00e9m \u00e9 muito importante saber quais EDs est\u00e3o dispon\u00edveis na biblioteca padr\u00e3o, como us\u00e1-las e qual a complexidade de cada opera\u00e7\u00e3o da ED. A seguir s\u00e3o apresentados as estruturas de dados presentes na biblioteca padr\u00e3o do C++ comumente usadas em competi\u00e7\u00f5es. Leitura recomendada: C++ Standard Library Containers More Operations on Sorted Sets C++ Sets with Custom Comparators C++ Containers library vector Um vector \u00e9 um array din\u00e2mico que permite adicionar e remover elementos de forma eficiente no final da estrutura. Por exemplo, o c\u00f3digo a seguir cria um vetor vazio e adiciona tr\u00eas elementos a ele: 1 2 3 4 vector < int > v ; v . push_back ( 3 ); // [3] v . push_back ( 2 ); // [3,2] v . push_back ( 5 ); // [3,2,5] Observe que os elementos s\u00e3o inseridos no fim. Ent\u00e3o, os elementos podem ser acessados como em um array comum: 1 2 3 cout << v [ 0 ] << \" \\n \" ; // 3 cout << v [ 1 ] << \" \\n \" ; // 2 cout << v [ 2 ] << \" \\n \" ; // 5 Outra maneira de criar um vetor \u00e9 fornecer uma lista de seus elementos: 1 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; Tamb\u00e9m pode-se fornecer o n\u00famero de elementos e seus valores iniciais: 1 2 vector < int > a ( 8 ); // tamanho 8, valor inicial: 0 vector < int > b ( 8 , 2 ); // tamanho 8, valor inicial: 2 A fun\u00e7\u00e3o size() retorna o n\u00famero de elementos no vector . Por exemplo: 1 2 3 for ( int i = 0 ; i < v . size (); i ++ ) { cout << v [ i ] << \" \\n \" ; } Uma alternativa mais simples \u00e9 a seguinte: 1 2 3 for ( auto x : v ) { cout << x << \" \\n \" ; } A fun\u00e7\u00e3o back retorna o \u00faltimo elemento de um vetor e a fun\u00e7\u00e3o pop_back remove o \u00faltimo elemento: 1 2 3 4 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; cout << v . back () << \" \\n \" ; // 1 v . pop_back (); cout << v . back () << \" \\n \" ; // 5 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do vector . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::vector std::vector deque Um deque \u00e9 um array din\u00e2mico que pode ser manipulado eficientemente em ambas as extremidades da estrutura. Como um vector , um deque fornece as fun\u00e7\u00f5es push_back e pop_back , mas tamb\u00e9m fornece as fun\u00e7\u00f5es push_front e pop_front que n\u00e3o est\u00e3o dispon\u00edveis em um vector . veja uma exemplo: As principais fun\u00e7\u00f5es da deque s\u00e3o: push_front(x) : adiciona o elemento x no in\u00edcio da estrutura; push_back(x) : adiciona o elemento x no fim da estrutura; pop_front() : remove o primeiro elemento da estrutura; pop_back() : remove o \u00faltimo elemento da estrutura; front() : retorna o primeiro elemento da estrutura; back() : retorna o \u00faltimo elemento da estrutura; size() : retorna o n\u00famero de elementos da estrutura. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 deque < int > d ; d . push_back ( 5 ); // [5] d . push_back ( 2 ); // [5,2] d . push_front ( 3 ); // [3,5,2] d . pop_back (); // [3,5] d . pop_front (); // [5] As opera\u00e7\u00f5es de um deque funcionam em tempo m\u00e9dio \\(O(1)\\) . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do deque . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::deque std::deque queue A estrutura da queue (fila) corresponde a uma fila simples da vida real e segue a regra First In First Out (FIFO). Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no fim da fila, acessar e remover o primeiro elemento da fila. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da queue s\u00e3o: push(x) : adiciona o elemento x no fim da fila; pop() : remove o primeiro elemento da fila; front() : retorna o primeiro elemento da fila; size() : retorna o n\u00famero de elementos da fila. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 queue < int > q ; q . push ( 2 ); // [2] q . push ( 5 ); // [2,5] cout << q . size () << \" \\n \" ; // 2 cout << q . front () << \" \\n \" ; // 2 q . pop (); // [5] cout << q . back () << \" \\n \" ; // 5 Complemente sua leitura e seu conhecimento: std::queue Queue Data Structure (GeeksforGeeks) stack Uma stack (pilha) \u00e9 uma estrutura muito semelhante a uma fila, mas que segue a regra Last In First Out (LIFO). Ou seja, ao inserir um elemento na pilha, ele \u00e9 adicionado no topo e esse \u00e9 o elemento que se tem acesso. Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no topo da pilha, acessar e remover o elemento do topo da pilha. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da stack s\u00e3o: push(x) : adiciona o elemento x no topo da pilha; pop() : remove o elemento do topo da pilha; top() : retorna o elemento do topo da pilha; size() : retorna o n\u00famero de elementos da pilha. Veja um exemplo de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 stack < int > s ; s . push ( 2 ); // [2] s . push ( 5 ); // [2,5] cout << s . size () << \" \\n \" ; // 2 cout << s . top () << \" \\n \" ; // 5 s . pop (); // [2] cout << s . top () << \" \\n \" ; // 2 Complemente sua leitura e seu conhecimento: std::stack Stack Data Structure (GeeksforGeeks) Stacks priority_queue Uma fila de prioridade ( priority_queue ) \u00e9 uma estrutura semelhante a uma fila ou pilha, mas ao inv\u00e9s de inser\u00e7\u00f5es e remo\u00e7\u00f5es acontecerem em uma das extremidades da estrutura, o maior (ou menor ) elemento \u00e9 sempre retornado durante o acesso/remo\u00e7\u00e3o. Inser\u00e7\u00f5es e remo\u00e7\u00f5es possuem complexidade \\(O(\\log n)\\) e o acesso ao elemento de maior prioridade \u00e9 \\(O(1)\\) . Uma fila de prioridade geralmente \u00e9 implementada usando uma estrutura chamada heap que \u00e9 muito mais simples do que uma \u00e1rvore bin\u00e1ria balanceada usado em um set . As principais fun\u00e7\u00f5es da priority_queue s\u00e3o: push(x) : adiciona o elemento x na fila de prioridade; pop() : remove o elemento de maior prioridade; top() : retorna o elemento de maior prioridade; size() : retorna o n\u00famero de elementos da fila de prioridade. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 priority_queue < int > q ; q . push ( 3 ); q . push ( 5 ); q . push ( 7 ); q . push ( 2 ); cout << q . top () << \" \\n \" ; // 7 q . pop (); cout << q . top () << \" \\n \" ; // 5 q . pop (); q . push ( 6 ); cout << q . top () << \" \\n \" ; // 6 q . pop (); Se for necess\u00e1rio criar uma fila de prioridade que suporte encontrar e remover o menor elemento, pode-se fazer da seguinte forma: 1 2 3 4 bool cmp ( const int & a , const int & b ) { return a > b ; } priority_queue < int , vector < int > , cmp > pq ; // (1) Note o uso da fun\u00e7\u00e3o de compara\u00e7\u00e3o cmp . Essa fun\u00e7\u00e3o deve receber dois argumentos do tipo armazenado na fila de prioridade e retorna true se o primeiro for considerado menor que o segundo. Para o exemplo anterior, outra alternativa \u00e9 usar a fun\u00e7\u00e3o greater : 1 priority_queue < int , vector < int > , greater < int >> pq ; Complemente sua leitura e seu conhecimento: Priority Queue in C++ Standard Template Library (STL) std::priority_queue set e multiset Semelhante a um conjunto matem\u00e1tico, um set \u00e9 uma cole\u00e7\u00e3o de elementos \u00fanicos , ou seja, todos os seus elementos s\u00e3o distintos. A estrutura \u00e9 baseada em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . Consequentemente, n\u00e3o \u00e9 poss\u00edvel acessar os elementos do set usando o operador [] , como acontece em um vector . Al\u00e9m disso, os elementos s\u00e3o mantidos ordenados . As principais fun\u00e7\u00f5es do set (e multiset ) s\u00e3o: insert(x) : adiciona o elemento x no conjunto. Se ele j\u00e1 estiver no conjunto, nada \u00e9 feito; erase(x) : remove o elemento x ; count(x) : retorna o n\u00famero de elemento cuja chave seja x ; find(x) : retorna um iterador para o elemento com chave x ; size() : retorna o n\u00famero de elementos do conjunto. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura set : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 set < int > s ; s . insert ( 3 ); s . insert ( 2 ); s . insert ( 5 ); cout << s . count ( 3 ) << \" \\n \" ; // 1 cout << s . count ( 4 ) << \" \\n \" ; // 0 s . erase ( 3 ); s . insert ( 4 ); cout << s . count ( 3 ) << \" \\n \" ; // 0 cout << s . count ( 4 ) << \" \\n \" ; // 1 if ( s . find ( 7 ) == s . end ()){ cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; } auto menor = s . begin (); auto maior = s . end (); maior -- ; // (1) cout << \"O menor elemento do conjunto \u00e9: \" << * menor << \" \\n \" ; cout << \"O maior elemento do conjunto \u00e9: \" << * maior << \" \\n \" ; set < int > c1 = { 2 , 5 , 6 , 8 }; cout << c1 . size () << \" \\n \" ; // 4 for ( auto x : c1 ) cout << x << \" \\n \" ; set < int > c2 ; c2 . insert ( 5 ); c2 . insert ( 5 ); c2 . insert ( 5 ); cout << c2 . count ( 5 ) << \" \\n \" ; // 1 (2) Como end() aponta para um elemento ap\u00f3s o \u00faltimo elemento, deve-se diminuir o iterador em uma unidade. Lembre-se que em um set todos seus elementos s\u00e3o distintos. Assim, a fun\u00e7\u00e3o count sempre retornar ou 0 (elemento n\u00e3o est\u00e1 no set ) ou 1 (o elemento est\u00e1 no set ). A estrutura set tamb\u00e9m fornece as fun\u00e7\u00f5es lower_bound(x) e upper_bound(x) que retornam um iterador para o menor elemento em um set cujo valor \u00e9 pelo menos ou maior que x , respectivamente. Em ambas as fun\u00e7\u00f5es, se o elemento solicitado n\u00e3o existir, o valor de retorno \u00e9 end() . Um multiset \u00e9 um conjunto que pode conter v\u00e1rias c\u00f3pias do mesmo elemento. Por exemplo, o c\u00f3digo abaixo adiciona tr\u00eas c\u00f3pias do valor 5 ao multiset : 1 2 3 4 5 multiset < int > s ; s . insert ( 5 ); s . insert ( 5 ); s . insert ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 3 A fun\u00e7\u00e3o erase remove todas as c\u00f3pias de um valor do multiset : 1 2 s . erase ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 0 Caso seja necess\u00e1rio remover apenas uma c\u00f3pia, pode-se fazer da seguinte forma: 1 2 s . erase ( s . find ( 5 )); cout << s . count ( 5 ) << \" \\n \" ; // 2 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do set e multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Set in C++ Standard Template Library (STL) Multiset in C++ Standard Template Library (STL) std::set std::multiset map e multimap Um map \u00e9 um conjunto que consiste em pares de valores-chave. Um map tamb\u00e9m pode ser visto como um array comum. Enquanto as chaves em um array s\u00e3o sempre inteiros consecutivos \\(0, 1, \\dots , n \u2212 1\\) , onde \\(n\\) \u00e9 o tamanho do array , as chaves em um map podem ser de qualquer tipo de dados e n\u00e3o precisam ser valores consecutivos. Como no set , o map \u00e9 baseado em em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . O c\u00f3digo a seguir cria um map cujas chaves s\u00e3o strings e os valores s\u00e3o int : 1 2 3 4 5 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; cout << m [ \"Daniel\" ] << \" \\n \" ; // 38 Se o valor de uma chave for solicitado, mas que n\u00e3o existe no map , a chave ser\u00e1 adicionada automaticamente ao map com um valor padr\u00e3o do tipo (se for uma classe o construtor padr\u00e3o \u00e9 chamado). Por exemplo, no c\u00f3digo a seguir, a chave \"Ana\" com valor 0 \u00e9 adicionada ao map . 1 2 map < string , int > m ; cout << m [ \"Ana\" ] << \" \\n \" ; Veja mais alguns exemplos de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; if ( m . find ( \"Ana\" ) == m . end ()) cout << \"N\u00e3o temos a idade da Ana registrada\" << \" \\n \" ; cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; cout << \"Bia tem \" << m [ \"Bia\" ] << \" anos \\n \" ; for ( auto x : m ) cout << x . first << \" \" << x . second << \" \\n \" ; m . erase ( \"Paulo\" ); cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; auto ultimo = -- m . end (); cout << ultimo -> first << \" tem \" << ultimo -> second << \" anos \\n \" ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do map e multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Map in C++ Standard Template Library (STL) Multimap in C++ Standard Template Library (STL) std::map std::multimap unordered_set e unordered_multiset Um unordered_set \u00e9 um cont\u00eainer associativo que cont\u00e9m um conjunto de objetos exclusivos. J\u00e1 um unordered_multiset permite c\u00f3pia dos elementos. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 unordered_set < int > s = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; s . erase ( 10 ); s . insert ( 4 ); cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; if ( s . find ( 7 ) == s . end ()) cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; for ( auto x : s ) cout << x << \" \" ; cout << endl ; unordered_multiset < int > ms = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; for ( auto x : ms ) cout << x << \" \" ; cout << endl ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_set e unordered_multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_set std::unordered_multiset unordered_map e unordered_multimap \u00e9 um conjunto que consiste em pares de valores-chave Um unordered_map \u00e9 um cont\u00eainer associativo que cont\u00e9m pares de valores-chave com chaves exclusivas. J\u00e1 um unordered_multimap permite m\u00faltiplas c\u00f3pias das chaves. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 unordered_map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; m [ \"Bia\" ] = 28 ; // Atualiza o valor da chave \"Bia\" for ( auto [ chave , valor ] : m ) cout << chave << \" -> \" << valor << \" \\n \" ; cout << endl ; unordered_multimap < string , int > mm ; mm . insert ( make_pair ( \"Paulo\" , 22 )); // (1) mm . insert ( make_pair ( \"Paulo\" , 43 )); mm . insert ( make_pair ( \"Bia\" , 19 )); mm . insert ( make_pair ( \"Bia\" , 22 )); for ( auto [ chave , valor ] : mm ) cout << chave << \" -> \" << valor << \" \\n \" ; N\u00e3o \u00e9 poss\u00edvel usar o operator[] como no map e unordered_map . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_map e unordered_multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_map std::unordered_multimap O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 \u21a9","title":"Estrutura de Dados (Parte 1)"},{"location":"ed1/#estrutura-de-dados-e-stl1","text":"Estrutura de dados (ED) \u00e9 a forma como os dados s\u00e3o armazenados na mem\u00f3ria do computador com o objetivo de tornar o processamento mais f\u00e1cil e eficiente. Cada uma possui suas pr\u00f3prias vantagens e desvantagens, por isso, \u00e9 crucial conhecer diferentes estruturas de dados (b\u00e1sicas e avan\u00e7adas) para conseguir definir qual as mais apropriada para um determinado problema. Em programa\u00e7\u00e3o competitiva, com o objetivo de economizar uma grande quantidade de tempo ao implementar um algoritmo, tamb\u00e9m \u00e9 muito importante saber quais EDs est\u00e3o dispon\u00edveis na biblioteca padr\u00e3o, como us\u00e1-las e qual a complexidade de cada opera\u00e7\u00e3o da ED. A seguir s\u00e3o apresentados as estruturas de dados presentes na biblioteca padr\u00e3o do C++ comumente usadas em competi\u00e7\u00f5es. Leitura recomendada: C++ Standard Library Containers More Operations on Sorted Sets C++ Sets with Custom Comparators C++ Containers library","title":"Estrutura de Dados e STL1"},{"location":"ed1/#vector","text":"Um vector \u00e9 um array din\u00e2mico que permite adicionar e remover elementos de forma eficiente no final da estrutura. Por exemplo, o c\u00f3digo a seguir cria um vetor vazio e adiciona tr\u00eas elementos a ele: 1 2 3 4 vector < int > v ; v . push_back ( 3 ); // [3] v . push_back ( 2 ); // [3,2] v . push_back ( 5 ); // [3,2,5] Observe que os elementos s\u00e3o inseridos no fim. Ent\u00e3o, os elementos podem ser acessados como em um array comum: 1 2 3 cout << v [ 0 ] << \" \\n \" ; // 3 cout << v [ 1 ] << \" \\n \" ; // 2 cout << v [ 2 ] << \" \\n \" ; // 5 Outra maneira de criar um vetor \u00e9 fornecer uma lista de seus elementos: 1 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; Tamb\u00e9m pode-se fornecer o n\u00famero de elementos e seus valores iniciais: 1 2 vector < int > a ( 8 ); // tamanho 8, valor inicial: 0 vector < int > b ( 8 , 2 ); // tamanho 8, valor inicial: 2 A fun\u00e7\u00e3o size() retorna o n\u00famero de elementos no vector . Por exemplo: 1 2 3 for ( int i = 0 ; i < v . size (); i ++ ) { cout << v [ i ] << \" \\n \" ; } Uma alternativa mais simples \u00e9 a seguinte: 1 2 3 for ( auto x : v ) { cout << x << \" \\n \" ; } A fun\u00e7\u00e3o back retorna o \u00faltimo elemento de um vetor e a fun\u00e7\u00e3o pop_back remove o \u00faltimo elemento: 1 2 3 4 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; cout << v . back () << \" \\n \" ; // 1 v . pop_back (); cout << v . back () << \" \\n \" ; // 5 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do vector . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::vector std::vector","title":"vector"},{"location":"ed1/#deque","text":"Um deque \u00e9 um array din\u00e2mico que pode ser manipulado eficientemente em ambas as extremidades da estrutura. Como um vector , um deque fornece as fun\u00e7\u00f5es push_back e pop_back , mas tamb\u00e9m fornece as fun\u00e7\u00f5es push_front e pop_front que n\u00e3o est\u00e3o dispon\u00edveis em um vector . veja uma exemplo: As principais fun\u00e7\u00f5es da deque s\u00e3o: push_front(x) : adiciona o elemento x no in\u00edcio da estrutura; push_back(x) : adiciona o elemento x no fim da estrutura; pop_front() : remove o primeiro elemento da estrutura; pop_back() : remove o \u00faltimo elemento da estrutura; front() : retorna o primeiro elemento da estrutura; back() : retorna o \u00faltimo elemento da estrutura; size() : retorna o n\u00famero de elementos da estrutura. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 deque < int > d ; d . push_back ( 5 ); // [5] d . push_back ( 2 ); // [5,2] d . push_front ( 3 ); // [3,5,2] d . pop_back (); // [3,5] d . pop_front (); // [5] As opera\u00e7\u00f5es de um deque funcionam em tempo m\u00e9dio \\(O(1)\\) . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do deque . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::deque std::deque","title":"deque"},{"location":"ed1/#queue","text":"A estrutura da queue (fila) corresponde a uma fila simples da vida real e segue a regra First In First Out (FIFO). Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no fim da fila, acessar e remover o primeiro elemento da fila. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da queue s\u00e3o: push(x) : adiciona o elemento x no fim da fila; pop() : remove o primeiro elemento da fila; front() : retorna o primeiro elemento da fila; size() : retorna o n\u00famero de elementos da fila. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 queue < int > q ; q . push ( 2 ); // [2] q . push ( 5 ); // [2,5] cout << q . size () << \" \\n \" ; // 2 cout << q . front () << \" \\n \" ; // 2 q . pop (); // [5] cout << q . back () << \" \\n \" ; // 5 Complemente sua leitura e seu conhecimento: std::queue Queue Data Structure (GeeksforGeeks)","title":"queue"},{"location":"ed1/#stack","text":"Uma stack (pilha) \u00e9 uma estrutura muito semelhante a uma fila, mas que segue a regra Last In First Out (LIFO). Ou seja, ao inserir um elemento na pilha, ele \u00e9 adicionado no topo e esse \u00e9 o elemento que se tem acesso. Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no topo da pilha, acessar e remover o elemento do topo da pilha. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da stack s\u00e3o: push(x) : adiciona o elemento x no topo da pilha; pop() : remove o elemento do topo da pilha; top() : retorna o elemento do topo da pilha; size() : retorna o n\u00famero de elementos da pilha. Veja um exemplo de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 stack < int > s ; s . push ( 2 ); // [2] s . push ( 5 ); // [2,5] cout << s . size () << \" \\n \" ; // 2 cout << s . top () << \" \\n \" ; // 5 s . pop (); // [2] cout << s . top () << \" \\n \" ; // 2 Complemente sua leitura e seu conhecimento: std::stack Stack Data Structure (GeeksforGeeks) Stacks","title":"stack"},{"location":"ed1/#priority_queue","text":"Uma fila de prioridade ( priority_queue ) \u00e9 uma estrutura semelhante a uma fila ou pilha, mas ao inv\u00e9s de inser\u00e7\u00f5es e remo\u00e7\u00f5es acontecerem em uma das extremidades da estrutura, o maior (ou menor ) elemento \u00e9 sempre retornado durante o acesso/remo\u00e7\u00e3o. Inser\u00e7\u00f5es e remo\u00e7\u00f5es possuem complexidade \\(O(\\log n)\\) e o acesso ao elemento de maior prioridade \u00e9 \\(O(1)\\) . Uma fila de prioridade geralmente \u00e9 implementada usando uma estrutura chamada heap que \u00e9 muito mais simples do que uma \u00e1rvore bin\u00e1ria balanceada usado em um set . As principais fun\u00e7\u00f5es da priority_queue s\u00e3o: push(x) : adiciona o elemento x na fila de prioridade; pop() : remove o elemento de maior prioridade; top() : retorna o elemento de maior prioridade; size() : retorna o n\u00famero de elementos da fila de prioridade. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 priority_queue < int > q ; q . push ( 3 ); q . push ( 5 ); q . push ( 7 ); q . push ( 2 ); cout << q . top () << \" \\n \" ; // 7 q . pop (); cout << q . top () << \" \\n \" ; // 5 q . pop (); q . push ( 6 ); cout << q . top () << \" \\n \" ; // 6 q . pop (); Se for necess\u00e1rio criar uma fila de prioridade que suporte encontrar e remover o menor elemento, pode-se fazer da seguinte forma: 1 2 3 4 bool cmp ( const int & a , const int & b ) { return a > b ; } priority_queue < int , vector < int > , cmp > pq ; // (1) Note o uso da fun\u00e7\u00e3o de compara\u00e7\u00e3o cmp . Essa fun\u00e7\u00e3o deve receber dois argumentos do tipo armazenado na fila de prioridade e retorna true se o primeiro for considerado menor que o segundo. Para o exemplo anterior, outra alternativa \u00e9 usar a fun\u00e7\u00e3o greater : 1 priority_queue < int , vector < int > , greater < int >> pq ; Complemente sua leitura e seu conhecimento: Priority Queue in C++ Standard Template Library (STL) std::priority_queue","title":"priority_queue"},{"location":"ed1/#set-e-multiset","text":"Semelhante a um conjunto matem\u00e1tico, um set \u00e9 uma cole\u00e7\u00e3o de elementos \u00fanicos , ou seja, todos os seus elementos s\u00e3o distintos. A estrutura \u00e9 baseada em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . Consequentemente, n\u00e3o \u00e9 poss\u00edvel acessar os elementos do set usando o operador [] , como acontece em um vector . Al\u00e9m disso, os elementos s\u00e3o mantidos ordenados . As principais fun\u00e7\u00f5es do set (e multiset ) s\u00e3o: insert(x) : adiciona o elemento x no conjunto. Se ele j\u00e1 estiver no conjunto, nada \u00e9 feito; erase(x) : remove o elemento x ; count(x) : retorna o n\u00famero de elemento cuja chave seja x ; find(x) : retorna um iterador para o elemento com chave x ; size() : retorna o n\u00famero de elementos do conjunto. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura set : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 set < int > s ; s . insert ( 3 ); s . insert ( 2 ); s . insert ( 5 ); cout << s . count ( 3 ) << \" \\n \" ; // 1 cout << s . count ( 4 ) << \" \\n \" ; // 0 s . erase ( 3 ); s . insert ( 4 ); cout << s . count ( 3 ) << \" \\n \" ; // 0 cout << s . count ( 4 ) << \" \\n \" ; // 1 if ( s . find ( 7 ) == s . end ()){ cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; } auto menor = s . begin (); auto maior = s . end (); maior -- ; // (1) cout << \"O menor elemento do conjunto \u00e9: \" << * menor << \" \\n \" ; cout << \"O maior elemento do conjunto \u00e9: \" << * maior << \" \\n \" ; set < int > c1 = { 2 , 5 , 6 , 8 }; cout << c1 . size () << \" \\n \" ; // 4 for ( auto x : c1 ) cout << x << \" \\n \" ; set < int > c2 ; c2 . insert ( 5 ); c2 . insert ( 5 ); c2 . insert ( 5 ); cout << c2 . count ( 5 ) << \" \\n \" ; // 1 (2) Como end() aponta para um elemento ap\u00f3s o \u00faltimo elemento, deve-se diminuir o iterador em uma unidade. Lembre-se que em um set todos seus elementos s\u00e3o distintos. Assim, a fun\u00e7\u00e3o count sempre retornar ou 0 (elemento n\u00e3o est\u00e1 no set ) ou 1 (o elemento est\u00e1 no set ). A estrutura set tamb\u00e9m fornece as fun\u00e7\u00f5es lower_bound(x) e upper_bound(x) que retornam um iterador para o menor elemento em um set cujo valor \u00e9 pelo menos ou maior que x , respectivamente. Em ambas as fun\u00e7\u00f5es, se o elemento solicitado n\u00e3o existir, o valor de retorno \u00e9 end() . Um multiset \u00e9 um conjunto que pode conter v\u00e1rias c\u00f3pias do mesmo elemento. Por exemplo, o c\u00f3digo abaixo adiciona tr\u00eas c\u00f3pias do valor 5 ao multiset : 1 2 3 4 5 multiset < int > s ; s . insert ( 5 ); s . insert ( 5 ); s . insert ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 3 A fun\u00e7\u00e3o erase remove todas as c\u00f3pias de um valor do multiset : 1 2 s . erase ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 0 Caso seja necess\u00e1rio remover apenas uma c\u00f3pia, pode-se fazer da seguinte forma: 1 2 s . erase ( s . find ( 5 )); cout << s . count ( 5 ) << \" \\n \" ; // 2 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do set e multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Set in C++ Standard Template Library (STL) Multiset in C++ Standard Template Library (STL) std::set std::multiset","title":"set e multiset"},{"location":"ed1/#map-e-multimap","text":"Um map \u00e9 um conjunto que consiste em pares de valores-chave. Um map tamb\u00e9m pode ser visto como um array comum. Enquanto as chaves em um array s\u00e3o sempre inteiros consecutivos \\(0, 1, \\dots , n \u2212 1\\) , onde \\(n\\) \u00e9 o tamanho do array , as chaves em um map podem ser de qualquer tipo de dados e n\u00e3o precisam ser valores consecutivos. Como no set , o map \u00e9 baseado em em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . O c\u00f3digo a seguir cria um map cujas chaves s\u00e3o strings e os valores s\u00e3o int : 1 2 3 4 5 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; cout << m [ \"Daniel\" ] << \" \\n \" ; // 38 Se o valor de uma chave for solicitado, mas que n\u00e3o existe no map , a chave ser\u00e1 adicionada automaticamente ao map com um valor padr\u00e3o do tipo (se for uma classe o construtor padr\u00e3o \u00e9 chamado). Por exemplo, no c\u00f3digo a seguir, a chave \"Ana\" com valor 0 \u00e9 adicionada ao map . 1 2 map < string , int > m ; cout << m [ \"Ana\" ] << \" \\n \" ; Veja mais alguns exemplos de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; if ( m . find ( \"Ana\" ) == m . end ()) cout << \"N\u00e3o temos a idade da Ana registrada\" << \" \\n \" ; cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; cout << \"Bia tem \" << m [ \"Bia\" ] << \" anos \\n \" ; for ( auto x : m ) cout << x . first << \" \" << x . second << \" \\n \" ; m . erase ( \"Paulo\" ); cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; auto ultimo = -- m . end (); cout << ultimo -> first << \" tem \" << ultimo -> second << \" anos \\n \" ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do map e multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Map in C++ Standard Template Library (STL) Multimap in C++ Standard Template Library (STL) std::map std::multimap","title":"map e multimap"},{"location":"ed1/#unordered_set-e-unordered_multiset","text":"Um unordered_set \u00e9 um cont\u00eainer associativo que cont\u00e9m um conjunto de objetos exclusivos. J\u00e1 um unordered_multiset permite c\u00f3pia dos elementos. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 unordered_set < int > s = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; s . erase ( 10 ); s . insert ( 4 ); cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; if ( s . find ( 7 ) == s . end ()) cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; for ( auto x : s ) cout << x << \" \" ; cout << endl ; unordered_multiset < int > ms = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; for ( auto x : ms ) cout << x << \" \" ; cout << endl ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_set e unordered_multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_set std::unordered_multiset","title":"unordered_set e unordered_multiset"},{"location":"ed1/#unordered_map-e-unordered_multimap","text":"\u00e9 um conjunto que consiste em pares de valores-chave Um unordered_map \u00e9 um cont\u00eainer associativo que cont\u00e9m pares de valores-chave com chaves exclusivas. J\u00e1 um unordered_multimap permite m\u00faltiplas c\u00f3pias das chaves. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 unordered_map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; m [ \"Bia\" ] = 28 ; // Atualiza o valor da chave \"Bia\" for ( auto [ chave , valor ] : m ) cout << chave << \" -> \" << valor << \" \\n \" ; cout << endl ; unordered_multimap < string , int > mm ; mm . insert ( make_pair ( \"Paulo\" , 22 )); // (1) mm . insert ( make_pair ( \"Paulo\" , 43 )); mm . insert ( make_pair ( \"Bia\" , 19 )); mm . insert ( make_pair ( \"Bia\" , 22 )); for ( auto [ chave , valor ] : mm ) cout << chave << \" -> \" << valor << \" \\n \" ; N\u00e3o \u00e9 poss\u00edvel usar o operator[] como no map e unordered_map . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_map e unordered_multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_map std::unordered_multimap O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 \u21a9","title":"unordered_map e unordered_multimap"},{"location":"ed2/","text":"Estrutura de Dados Nesta parte, ser\u00e3o apresentados duas estruturas baseadas em \u00e1rvores e uma implementa\u00e7\u00e3o de set do GNU C++. GNU C++ Policy-Based Sets O compilador GNU g++ tamb\u00e9m suporta algumas estruturas de dados que n\u00e3o fazem parte da biblioteca padr\u00e3o do C++. Essas estruturas s\u00e3o chamadas de estruturas de dados baseadas em pol\u00edticas ( Policy-Based Data Structures - PBDS ). Para usar essas estruturas \u00e9 necess\u00e1rio incluir o seguinte c\u00f3digo: 1 2 3 #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds ; Alternativamente, pode-se simplificar o c\u00f3digo anterior da seguinte forma: 1 2 #include <bits/extc++.h> using namespace __gnu_pbds ; Ap\u00f3s isso, \u00e9 poss\u00edvel definir um conjunto ordenado indexado (entre as dispon\u00edveis, essa \u00e9 a principal estrutura usada em competi\u00e7\u00f5es de programa\u00e7\u00e3o). Esta estrutura \u00e9 como o set , mas com a possibilidade de acessar os elementos de acordo com a sua posi\u00e7\u00e3o (\u00edndice), como em um array . O c\u00f3digo abaixo, define um conjunto ordenado indexado usando template . 1 2 template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; Veja alguns exemplos de uso da defini\u00e7\u00e3o anterior: 1 2 3 4 indexed_set < int > setInt ; // Conjunto ordenado indexado de inteiros indexed_set < double > setDouble ; // Conjunto ordenado indexado de doubles indexed_set < pair < int , int >> setPairInt ; // Conjunto ordenado indexado de pares de inteiros indexed_set < Pessoa > setPessoa ; // Conjunto ordenado indexado de Pessoas (precisa do operator<) Al\u00e9m das opera\u00e7\u00f5es comuns do set ( insert , erase , size , clear , find , begin , end ), ainda existem duas fun\u00e7\u00f5es muito \u00fateis e que justificam o uso do PBDS: find_by_order(k) : retorna um iterador para o \\(k\\) -\u00e9simo menor elemento (contando a partir de zero) do conjunto em tempo \\(O(\\log n)\\) ; order_of_key(x) : retorna ao n\u00famero de itens estritamente menores que o x em tempo \\(O(\\log n)\\) . Veja um exemplo completo de utiliza\u00e7\u00e3o do PBDS (Fonte: pbds.cpp ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <bits/stdc++.h> #include <bits/extc++.h> // pbds using namespace std ; using namespace __gnu_pbds ; template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; int main () { int n = 9 ; vector < int > A = { 71 , 10 , 2 , 4 , 23 , 7 , 10 , 15 , 23 , 50 , 65 , 71 }; indexed_set < int > iset ; for ( int i = 0 ; i < A . size (); ++ i ) // O(n log n) iset . insert ( A [ i ]); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 9 for ( auto x : iset ) cout << x << \" \" ; cout << \" \\n \" ; // O(log n) select cout << * iset . find_by_order ( 0 ) << \" \\n \" ; // 1-smallest = 2 cout << * iset . find_by_order ( n -1 ) << \" \\n \" ; // 9-smallest/largest = 71 cout << * iset . find_by_order ( 4 ) << \" \\n \" ; // 5-smallest = 15 // O(log n) rank cout << iset . order_of_key ( 2 ) << \" \\n \" ; // index 0 (rank 1) cout << iset . order_of_key ( 71 ) << \" \\n \" ; // index 8 (rank 9) cout << iset . order_of_key ( 15 ) << \" \\n \" ; // index 4 (rank 5) iset . erase ( 2 ); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 8 return 0 ; } Complemente sua leitura e seu conhecimento: Ordered Set and GNU C++ PBDS (GeeksforGeeks) C++ STL: Policy based data structures PBDS Examples Fenwick (Binary Indexed) Tree Considere o seguinte problema: Voc\u00ea possui \\(n\\) caixas com bolinhas de gude e deseja: Adicionar bolinhas de gude a caixa \\(i\\) ; Saber a quantidade de bolinhas de gude que existem da caixa \\(a\\) at\u00e9 a caixa \\(b\\) , ou seja, a soma das bolinhas nas caixas \\([a, a+1, a+2, \\dots, b]\\) . O objetivo \u00e9 implementar essas duas opera\u00e7\u00f5es de forma eficiente. Esse problema \u00e9 conhecido como Range Sum Queries (RSQ) . Uma abordagem ing\u00eanua, mostrada abaixo, possui \\(O(1)\\) para a opera\u00e7\u00e3o 1 e \\(O(n)\\) para a 2. Se forem feitas \\(m\\) opera\u00e7\u00f5es 2, no pior caso, a complexidade de tempo ser\u00e1 \\(O(n*m)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 vector < ll > caixas ( n , 0 ); void add ( vector < ll >& caixas , ll i , ll n ) { // O(1) caixas [ i ] += n ; } void sum ( vector < ll >& caixas , ll a , ll b ){ // O(n) ll s = 0 ; for ( ll i = a ; i <= b ; i ++ ) s += caixas [ i ]; return s ; } Para responder range sum queries em sequ\u00eancias din\u00e2micas com melhor complexidade \u00e9 preciso usar estruturas mais sofisticadas, que permitam a atualiza\u00e7\u00e3o das somas pr\u00e9-computadas de forma eficiente. Uma destas estruturas \u00e9 a Binary Indexed Tree ( BIT ou Fenwick Tree ), proposta por Peter M. Fenwick em 1994 . Usando BIT, ambas as opera\u00e7\u00f5es s\u00e3o feitas em \\(O(\\log n)\\) . A ideia da BIT \u00e9 que, assim como um n\u00famero pode ser representado como uma soma de algumas pot\u00eancias de dois, uma soma cumulativa pode ser representada como uma soma de algumas somas cumulativas parciais. Para isso, cada \u00edndice \\(i\\) no array de soma cumulativa \u00e9 respons\u00e1vel pela soma cumulativa do \u00edndice \\(i\\) at\u00e9 \\((i - (1<<r) + 1)\\) , onde \\(r\\) representa a posi\u00e7\u00e3o do \u00faltimo bit 1 da representa\u00e7\u00e3o bin\u00e1ria de \\(i\\) (o \\(p(i) = (1<<r)\\) tamb\u00e9m pode ser visto como a maior pot\u00eancia de \\(2\\) que divide \\(i\\) ). Por exemplo, o \u00edndice \\(15_{10} = 1111_2\\) ficar\u00e1 respons\u00e1vel pela soma do intervalo \\(15 - (1<<0) + 1 = 15 - 1 + 1\\) a \\(15\\) . J\u00e1 o \u00edndice \\(12_{10} = 1100_2\\) ficar\u00e1 respons\u00e1vel pela soma do intervalo \\(12 - (1<<3) + 1 = 12 - 8 + 1 = 9\\) a \\(12\\) , e assim por diante. A tabela abaixo mostra a responsabilidade dos \u00edndices 1 a 16. \u00cdndice Respons\u00e1vel pela soma parcial do intervalo 16 [01, 16] 15 [15, 15] 14 [13, 14] 13 [13, 13] 12 [09, 12] 11 [11, 11] 10 [09, 10] 09 [09, 09] 08 [01, 08] 07 [07, 07] 06 [05, 06] 05 [05, 05] 04 [01, 04] 03 [03, 03] 02 [01, 02] 01 [01, 01] Perceba que todo \u00edndice \u00edmpar fica respons\u00e1vel por um intervalo de tamanho 1 (porqu\u00ea?). J\u00e1 os \u00edndices \\(i\\) que s\u00e3o pot\u00eancia de 2, ficam respons\u00e1veis pelo intervalo \\([1, i]\\) . Tipicamente, a Fenwick Tree \u00e9 implementada usando um array ( vector ), digamos ft , de modo que: 1 ft [ i ] = sum ( i - p ( i ) + 1 , i ); Assim, cada posi\u00e7\u00e3o i cont\u00e9m a soma dos valores de um intervalo do array original cujo comprimento \u00e9 p(i) e que termina na posi\u00e7\u00e3o i . Por exemplo, como p(6) = 2 , ft[6] cont\u00e9m o valor de sum(5,6) . Considere o seguinte array original: A Fenwick Tree correspondente \u00e9 a seguinte: A figura abaixo mostra mais claramente como cada valor na BIT corresponde a um intervalo no array original: Usando uma BIT, qualquer valor de sum(1,i) pode ser calculado em tempo \\(O(\\log n)\\) , pois um intervalo \\([1,i]\\) sempre pode ser dividido em intervalos \\(O(\\log n)\\) cujas somas s\u00e3o armazenadas na \u00e1rvore. Por exemplo, o intervalo \\([1,7]\\) consiste nos seguintes intervalos: Assim, pode-se calcular a soma correspondente da seguinte forma: \\[ sum(1,7) = sum(1,4)+sum(5,6)+sum(7,7) = 16+7+4 = 27 \\] Para calcular o valor de \\(sum(a,b)\\) onde \\(a > 1\\) , pode-se usar o mesmo truque que usado na soma de prefixo: \\[ sum(a,b) = sum(1,b)\u2212sum(1,a\u22121). \\] Como pode-se calcular tanto \\(sum(1, b)\\) quanto \\(sum(1, a\u22121)\\) em tempo \\(O(\\log n)\\) , a complexidade de tempo total \u00e9 \\(O(\\log n)\\) . Al\u00e9m de calcular a soma parcial, tamb\u00e9m \u00e9 poss\u00edvel/necess\u00e1rio atualizar o valor de uma determinada posi\u00e7\u00e3o no array original. Ap\u00f3s a atualiza\u00e7\u00e3o, alguns valores na BIT devem ser atualizados. Por exemplo, se o valor na posi\u00e7\u00e3o 3 mudar, as somas dos seguintes intervalos mudam: Como cada elemento do array pertence a \\(O(\\log n)\\) intervalos na BIT, basta atualizar os \\(O(\\log n)\\) valores na \u00e1rvore. Implementa\u00e7\u00e3o O primeiro passo \u00e9 definir como calcular o valor de p(i) , ou seja, a maior pot\u00eancia de \\(2\\) que divide \\(i\\) . Este valor \u00e9 conhecido como o bit menos significativo , abreviado lsb , da representa\u00e7\u00e3o bin\u00e1ria de \\(i\\) . O fun\u00e7\u00e3o abaixo calcula esse valor: 1 2 3 4 5 6 7 int p ( int i ) { int bit = 0 ; while (( i >> bit ) & 1 == 0 ) { ++ bit ; } return ( 1 << bit ); } Essa fun\u00e7\u00e3o possui complexidade \\(O(\\log n)\\) . Entretanto, usando manipula\u00e7\u00e3o de bits , pode-se encontrar esse valor de forma mais eficiente. Lembre-se que um n\u00famero negativo \u00e9 representado usando complemento de 2, ou seja, pega-se a representa\u00e7\u00e3o bin\u00e1ria de x , inverte-se os bits e adiciona 1 (ignorando o resto final). Por exemplo, considere x = 108 e que os valores s\u00e3o representados em 8 bits: 1 2 3 x = 01101100 ~x = 10010011 -x = 10010100 Observe que os bits mais significativos que o lsb s\u00e3o diferentes para x e -x , enquanto o lsb e os 0s seguintes s\u00e3o os mesmos. Portanto, x & \u2212x d\u00e1 a resposta desejada, ou seja: x & -x = 00000100 . Com essa estrat\u00e9gia, pode-se calcular o valor de lsb , consequentemente, o valor de p(i) em \\(O(1)\\) : 1 2 3 long long lsb ( long long i ) { // (1) return i & - i ; } Normalmente, essa fun\u00e7\u00e3o \u00e9 feita como uma macro: #define lsb(i) ((i) & -(i)) A fun\u00e7\u00f5es a seguir calculam o valor de \\(sum(1,i)\\) e \\(sum(a, b)\\) , respectivamente: 1 2 3 4 5 6 7 8 9 10 11 long long sum ( long long i ) { long long s = 0 ; while ( i >= 1 ) { s += ft [ i ]; i -= lsb ( i ); } return s ; } long long sum ( long long a , long long b ) { return sum ( b ) - sum ( a -1 ); } A seguinte fun\u00e7\u00e3o aumenta o valor do array na posi\u00e7\u00e3o \\(i\\) em \\(x\\) ( \\(x\\) pode ser positivo ou negativo): 1 2 3 4 5 6 void add ( int i , int x ) { // Normalmente, essa fun\u00e7\u00e3o tamb\u00e9m \u00e9 chamada de update while ( i < ft . size ()) { ft [ i ] += x ; i += lsb ( i ); } } Para construir a BIT a partir de um array original, uma primeira estrat\u00e9gia \u00e9 iniciar o array ft com valor 0 em todas as posi\u00e7\u00f5es. Em seguida, para cada posi\u00e7\u00e3o \\(i\\) , chama-se a fun\u00e7\u00e3o add passando o valor do array original como valor a ser incrementado, o que daria resultaria em \\(O(n \\log n)\\) opera\u00e7\u00f5es. Veja a fun\u00e7\u00e3o abaixo: 1 2 3 4 5 void build ( const vector < ll >& a ) { ft . assign ( a . size () + 1 , 0 ); for ( ll i = 1 ; i < a . size (); i ++ ) add ( i , a [ i ]); } Entretanto, note que ap\u00f3s atualizar o valor de ft[i] , pode-se verificar se o \"pai\" de \\(i\\) \u00e9 menor que \\(N\\) (tamanho do array). Se for, atualiza-se o \"pai\" tamb\u00e9m. Dessa forma, temos uma fun\u00e7\u00e3o com complexidade \\(O(n)\\) . 1 2 3 4 5 6 7 8 9 void build ( const vector < ll >& a ) { ll m = ( ll ) a . size () - 1 ; ft . assign ( m + 1 , 0 ); for ( ll i = 1 ; i <= m ; i ++ ) { ft [ i ] += a [ i ]; if ( i + lsb ( i ) <= m ) ft [ i + lsb ( i )] += a [ i ]; } } Tamb\u00e9m \u00e9 poss\u00edvel encontrar o menor \u00edndice \\(i\\) tal que soma acumulativa do intervalo \\([1..i] \\geq k\\) . Como as somas acumulativas dos valores est\u00e3o ordenadas, pode-se usar a busca bin\u00e1ria para encontrar tal \u00edndice. Basicamente, testa-se o \u00edndice do meio \\(m = n / 2\\) do intervalo inicial \\([1..n]\\) e verifica se sum(1, i) \u00e9 menor que \\(k\\) ou n\u00e3o. Para cada valor de \\(m\\) , tem-se \\(O(\\log n)\\) opera\u00e7\u00f5es, logo, essa fun\u00e7\u00e3o ter\u00e1 complexidade \\(O(\\log n \\times \\log n) = O(\\log^2 n)\\) . O c\u00f3digo abaixo ilustra tal fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 ll select ( ll k ) { ll ini = 1 , fim = ft . size () - 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { // (1) ll m = ( ini + fim ) / 2 ; if ( sum ( 1 , m ) < k ) ini = m ; else fim = m ; } return fim ; } \\(2^{30} > 10^9\\) , normalmente \u00e9 suficiente. O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o completa de uma BIT. Note que foi usado uma vers\u00e3o baseada em orienta\u00e7\u00e3o \u00e0 objetos, mas isso n\u00e3o \u00e9 necess\u00e1rio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vll ; #define lsb(i) ((i) & -(i)) class FenwickTree { private : vll ft ; public : FenwickTree ( ll m ) { ft . resize ( m + 1 , 0 ); } FenwickTree ( const vll & a ) { build ( a ); } ll sum ( ll i ) { ll s = 0 ; while ( i >= 1 ) { s += ft [ i ]; i -= lsb ( i ); } return s ; } ll sum ( ll a , ll b ) { return sum ( b ) - sum ( a -1 ); } void add ( ll i , ll x ) { while ( i < ( ll ) ft . size ()) { ft [ i ] += x ; i += lsb ( i ); } } void build ( const vll & a ) { ll m = ( ll ) a . size () - 1 ; ft . resize ( m + 1 , 0 ); for ( ll i = 1 ; i <= m ; i ++ ) { ft [ i ] += a [ i ]; if ( i + lsb ( i ) <= m ) ft [ i + lsb ( i )] += ft [ i ]; } } ll select ( ll k ) { ll ini = 1 , fim = ( ll ) ft . size () - 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { ll m = ini + ( fim - ini ) / 2 ; if ( sum ( 1 , m ) < k ) ini = m ; else fim = m ; } return fim ; } }; int main () { // 1 2 3 4 5 6 7 8 vll f = { 0 , 1 , 3 , 4 , 8 , 6 , 1 , 4 , 2 }; // Indice 0 n\u00e3o \u00e9 utilizado FenwickTree ft ( f ); cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 29 cout << ft . sum ( 1 , 3 ) << \" \\n \" ; // ft[3] + ft[2] = 4 + 4 = 8 cout << ft . sum ( 1 , 7 ) << \" \\n \" ; // ft[7] + ft[6] + ft[4] = 16 + 7 + 4 = 27 cout << ft . sum ( 2 , 4 ) << \" \\n \" ; // sum(1, 4) - sum(1, 1) = ft[4] - ft[1] = 16 - 1 = 15 cout << ft . sum ( 6 , 8 ) << \" \\n \" ; // sum(1, 8) - sum(1, 5) = ft[8] - (ft[5] + ft[4]) = 29 - (6 + 16) = 7 ft . add ( 8 , 2 ); // Aumenta em duas unidades o valor da posi\u00e7\u00e3o 8 cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 31 ft . add ( 8 , -2 ); // Reduz em duas unidades o valor da posi\u00e7\u00e3o 8 cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 29 ft . add ( 8 , - f [ 8 ]); // Zera o valor da posi\u00e7\u00e3o 8 cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 27 cout << ft . select ( 4 ) << \" \\n \" ; // Indice 2, sum(1, 2) == 4, que \u00e9 >= 4 cout << ft . select ( 5 ) << \" \\n \" ; // Indice 3, sum(1, 3) == 8, que \u00e9 >= 8 cout << ft . select ( 25 ) << \" \\n \" ; // Indice 7, sum(1, 7) == 27, que \u00e9 >= 25 return 0 ; } Quando usar? Para utilizar uma \u00e1rvore de Fenwick para realizar a opera\u00e7\u00e3o \\(\\odot\\) em um intervalo de \u00edndices \\([i,j]\\) da sequ\u00eancia \\(a_k\\) , \u00e9 necess\u00e1rio que esta opera\u00e7\u00e3o tenha duas propriedades: Associatividade: para quaisquer \\(x, y, z \\in a_k\\) , deve valer que: \\((x \\odot y)\\odot z = x \\odot (y \\odot z)\\) ; Invertibilidade: para qualquer \\(x \\in a_k\\) , deve existir um valor \\(y\\) tal que \\(x\\odot y = I\\) , onde \\(I\\) \u00e9 o elemento neutro/identidade da opera\u00e7\u00e3o \\(\\odot\\) . Como exemplos de opera\u00e7\u00f5es que t\u00eam ambas propriedades tem-se a adi\u00e7\u00e3o e a multiplica\u00e7\u00e3o de racionais, a adi\u00e7\u00e3o de matrizes e o ou exclusivo (xor). Material complementar Binary Indexed Tree or Fenwick Tree (GeeksforGeeks) Fenwick Tree Binary Indexed Trees (Topcoder) Fenwick Tree (Binary Index Tree) - Quick Tutorial and Source Code Explanation Tutorial: Binary Indexed Tree (Fenwick Tree) Binary Indexed (Fenwick) Tree - VisuAlgo Segment Tree Segment tree (\u00c1rvore de Segmento ou SegTree ) \u00e9 outra estrutura de dados para lidar com problemas de consulta em intervalos. O que torna as SegTrees poderosas \u00e9 sua capacidade de fazer atualiza\u00e7\u00e3o e consulta em intervalos com complexidade \\(O(\\log n)\\) , al\u00e9m do tipo da consulta ser bem abrangente. Entretanto, comparada a BIT, uma SegTree requer mais mem\u00f3ria e \u00e9 um pouco mais dif\u00edcil de implementar. A ideia da SegTree \u00e9 a seguinte: cria-se uma \u00e1rvore de forma que cada n\u00f3 representa a informa\u00e7\u00e3o que deseja-se saber a respeito de um segmento do vetor (por exemplo, a soma). Cada n\u00f3 (exceto as folhas) possui dois filhos, um filho representa a metade esquerda do intervalo e o outro, a metade direita. Esse processo repete-se (recursivamente) at\u00e9 que os intervalos atinjam tamanho 1. Assim, considerando o Range Sum Queries (RSQ), o n\u00f3 ra\u00edz da \u00e1rvore armazena a soma de todo o array, ou seja, a soma do segmento \\(a[0 \\dots n-1]\\) . Em seguida, essa segmento \u00e9 dividido em dois: o filho da esquerda fica respons\u00e1vel pelo calcular/armazenar a soma da metade da esquerda do segmento (ou seja, \\(a[0 \\dots n/2]\\) ) e o filho da direita respons\u00e1vel pela metade da direita do segmento (ou seja, \\(a[n/2+1 \\dots n-1]\\) ). Cada um desses n\u00f3s \u00e9 novamente dividido e calcula-se a soma de cada novo intervalo. Repete-se o processo at\u00e9 todos os segmentos atingirem tamanho 1. Nesse link voc\u00ea encontra uma demonstra\u00e7\u00e3o visual de como a SegTree funciona. Veja uma representa\u00e7\u00e3o visual de uma SegTree para o array a = [1,3,\u22122,8,\u22127] : Fonte: Algorithms for Competitive Programming Note que o primeiro n\u00edvel da \u00e1rvore cont\u00e9m um \u00fanico n\u00f3 (a raiz), o segundo n\u00edvel cont\u00e9m 2 n\u00f3s, no terceiro cont\u00e9m 4, e assim por diante, at\u00e9 que o n\u00famero de n\u00f3s alcance \\(n\\) . Portanto, o n\u00famero de n\u00f3s, no pior caso, pode ser estimado pela soma \\(1+2+4+\\cdots+2^{\\lceil \\log_2 n \\rceil}=2^{ \\lceil \\log_2 n \\rceil+1} < 4n\\) . Consultas Suponha que deseja-se fazer uma consulta (por exemplo, calcular a soma, valor m\u00ednimo/m\u00e1ximo, etc.) no intervalo \\(l\\) e \\(r\\) , ou seja, deseja-se fazer um consulta no segmento \\(a[l \\dots r]\\) . Para isso, deve-se percorrer a \u00e1rvore de segmentos e usar os valores pr\u00e9-computados dos segmentos. Considere que a consulta esteja no v\u00e9rtice que cobre o segmento \\(a[tl \\dots tr]\\) . Existem tr\u00eas possibilidades: O n\u00f3 est\u00e1 fora do intervalo de interesse, ou seja, tr < l || r < tl . Retorne um valor neutro que n\u00e3o afete a cunsulta (por exemplo, se a opera\u00e7\u00e3o for a soma, retorne 0); O n\u00f3 est\u00e1 completamente inclu\u00eddo no intervalos de interesse, ou seja, tl >= l && tr <= r . Retorne a informa\u00e7\u00e3o armazenada no n\u00f3; O n\u00f3 est\u00e1 parcialmente contido no intervalo de interesse, ou seja, ( l <= tr && tr <= r ) || ( l <= tl && tl <= r ) . Ent\u00e3o, a consulta continua nos n\u00f3s filhos. A figura abaixo ilustra esse processo para encontrar a soma do segmento \\(a[2 \\dots 4]\\) para o array a = [1,3,\u22122,8,\u22127] . Os n\u00f3s coloridos ser\u00e3o visitados e usa-se os valores pr\u00e9-calculados dos n\u00f3s verdes. Assim, o resultado ser\u00e1 \\(\u22122 + 1=\u22121\\) . O n\u00famero de n\u00f3s visitados \u00e9 proporcional \u00e0 altura da \u00e1rvore, ou seja, \\(O(\\log n)\\) . Fonte: Algorithms for Competitive Programming Atualiza\u00e7\u00f5es Fazer uma atualiza\u00e7\u00e3o no array original (por exemplo, fazer a[i] = x ) implica que a SegTree tamb\u00e9m deve ter alguns n\u00f3s atualizados, de modo que ela corresponda ao novo array modificado. Perceba que cada n\u00edvel de uma SegTree forma uma parti\u00e7\u00e3o do array. Portanto, um elemento a[i] apenas contribui para um segmento de cada n\u00edvel. Assim, apenas \\(O(\\log n)\\) n\u00f3s necessitam ser atualizadas. A atualiza\u00e7\u00e3o dos elementos pode ser facilmente implementada usando uma fun\u00e7\u00e3o recursiva. A fun\u00e7\u00e3o passa pelo n\u00f3 atual da \u00e1rvore e recursivamente chama a si mesma com um dos dois n\u00f3s filhos (aquele que cont\u00e9m a[i] em seu segmento) e, em seguida, recalcula seu valor. Considerando a SegTree do array a = [1,3,\u22122,8,\u22127] , ao fazer a[2] = 3 , os n\u00f3s verdes s\u00e3o os n\u00f3s visitados e atualizados. Fonte: Algorithms for Competitive Programming Implementa\u00e7\u00e3o A primeira fun\u00e7\u00e3o a ser analisada/implementada \u00e9 a build , respons\u00e1vel por criar a SegTree. Assim como na BIT, aqui tamb\u00e9m pode-se usar um array para armazenar os n\u00f3s da SegTree (considere que o array se chama st ). O \u00edndice 0 \u00e9 a ra\u00edz e os filhos da esquerda e direita do \u00edndice \\(i\\) s\u00e3o os \u00edndices \\(2 \\times i + 1\\) e \\(2 \\times i + 2\\) , respectivamente. A raiz da SegTree representa o segmento completo [0, n-1] do array A . Para cada segmento [L, R] armazenado no \u00edndice \\(i\\) , onde L != R , o segmento \u00e9 dividido no sub-segmento [L, (L+R)/2] (armazenado no \u00edndice \\(2 \\times i + 1\\) ) e sub-segmento [(L+R)/2 + 1, R] (armazenado no \u00edndice \\(2 \\times i + 2\\) ). Essa divis\u00e3o continua at\u00e9 que o segmento tenha tamanho 1 (isto \u00e9, L == R ), o que indica que chegou-se em um n\u00f3 folha e, pela defini\u00e7\u00e3o de SegTree, esse n\u00f3 deve receber o valor correspondente de A , ou seja, st[i] = A[L] ou st[i] = A[R] . A fun\u00e7\u00e3o build abaixo ilustra o processo de constru\u00e7\u00e3o de uma SegTree a partir do array A . Perceba que foi usada a fun\u00e7\u00e3o funcao para fazer a atualiza\u00e7\u00e3o dos n\u00f3s da \u00e1rvore. Nesse exemplo, a SegTree ser\u00e1 respons\u00e1vel por realizar a soma dos elementos (RSQ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define filhoEsq(i) (2*(i) + 1) #define filhoDir(i) (2*(i) + 2) long long funcao ( long long a , long long b ) { // Fun\u00e7\u00e3o usada na SegTree: soma return a + b ; } void build ( long long i , long long L , long long R ) { if ( L > R ) return ; //N\u00f3 (folha) que deve conter o valor de A[L] ou A[R] if ( L == R ) st [ i ] = A [ L ]; else { //Recursivamente constroi-se a SegTree long long m = L + ( R - L ) / 2 ; build ( filhoEsq ( i ), L , m ); build ( filhoDir ( i ), m + 1 , R ); //Ap\u00f3s atualizar o valor dos n\u00f3s filhos de 'i', atualiza-se o valor do n\u00f3 'i' st [ i ] = funcao ( st [ filhoEsq ( i )], st [ filhoDir ( i )]); } } A pr\u00f3xima fun\u00e7\u00e3o a ser analisada/implementada \u00e9 a query , respons\u00e1vel por fazer as consultas. Ao analisar o n\u00f3 \\(i\\) , respons\u00e1vel pelo intervalo [tl, tr] , como explicado na se\u00e7\u00e3o Atualiza\u00e7\u00f5es , existem tr\u00eas possibilidades. O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o da fun\u00e7\u00e3o query , ela recebe como par\u00e2metros informa\u00e7\u00f5es sobre o n\u00f3/segmento atual (ou seja, o \u00edndice \\(i\\) e os limites \\(tl\\) e \\(tr\\) ) e tamb\u00e9m os limites da consulta, \\(l\\) e \\(r\\) . Para fazer uma consulta no intervalo [l, r] , a fun\u00e7\u00e3o deve ser chamada da seguinte forma: query(0, 0, n - 1, l, r) , onde n representa o n\u00famero de elementos de A . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 long long query ( long long i , long long tl , long long tr , long long l , long long r ){ //O n\u00f3 i est\u00e1 fora do intervalo de interesse. //Retorne o elemento neutro que n\u00e3o afeta a consulta. if ( tr < l || r < tl ) return 0 ; // Elemento neutro da RSQ // O n\u00f3 i est\u00e1 completamente inclu\u00eddo no intervalo de interesse. // Retorne a informa\u00e7\u00e3o contida no n\u00f3. if ( tl >= l and tr <= r ) return st [ i ]; // Se a execu\u00e7\u00e3o chegou nesse ponto, significa que o n\u00f3 i est\u00e1 parcialmente // contido no intervalo de interesse. Ent\u00e3o, continua-se a procura nos n\u00f3s filhos. long long m = tl + ( tr - tl ) / 2 ; return funcao ( query ( filhoEsq ( i ), tl , m , l , r ), query ( filhoDir ( i ), m + 1 , tr , l , r )); } A fun\u00e7\u00e3o update \u00e9 respons\u00e1vel por fazer atualiza\u00e7\u00f5es no array A e, consequentemente, na SegTree. O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o da fun\u00e7\u00e3o update , ela recebe como par\u00e2metros informa\u00e7\u00f5es sobre o n\u00f3/segmento atual (ou seja, o \u00edndice \\(no\\) e os limites \\(tl\\) e \\(tr\\) ), o \u00edndice \\(i\\) que se deseja atualizar e o novo valor a ser armazenado na posi\u00e7\u00e3o \\(i\\) . Para fazer A[i] = x , a fun\u00e7\u00e3o deve ser chamada da seguinte forma: update(0, 0, n - 1, i, x); , onde n representa o n\u00famero de elementos de A . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void update ( long long no , long long tl , long long tr , long long i , long long novoValor ){ // \u00cdndice cujo valor deve ser atualizado if ( tl == i and tr == i ){ st [ no ] = novoValor ; A [ i ] = novoValor ; return ; } // O intervalo n\u00e3o contem o \u00edndice a ser atualizado if ( tl > i or tr < i ) return ; // O intervalo cont\u00e9m o \u00edndice, mas deve-se chegar no n\u00f3 espec\u00edfico. // O processo \u00e9 repetido recursivamente nos filhos. long long m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , i , novoValor ); update ( filhoDir ( no ), m + 1 , tr , i , novoValor ); // Ap\u00f3s atualizar os filhos (esquerdo ou direito), deve-se atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o completa de uma SegTree. Note que foi usado uma vers\u00e3o baseada em orienta\u00e7\u00e3o \u00e0 objetos, mas isso n\u00e3o \u00e9 necess\u00e1rio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vll ; #define filhoEsq(i) (2*(i) + 1) #define filhoDir(i) (2*(i) + 2) class SegTree { private : vll st , A ; ll size ; ll el_neutro = 0 ; ll funcao ( ll a , ll b ) { // Fun\u00e7\u00e3o usada na SegTree: soma return a + b ; } ll query ( ll no , ll tl , ll tr , ll l , ll r ){ //O n\u00f3 est\u00e1 fora do intervalo de interesse. //Retorne o elemento neutro que n\u00e3o afeta a consulta. if ( tr < l || r < tl ) return el_neutro ; // O n\u00f3 est\u00e1 completamente inclu\u00eddo no intervalo de interesse. // Retorne a informa\u00e7\u00e3o contida no n\u00f3. if ( tl >= l and tr <= r ) return st [ no ]; // Se chegarmos aqui, \u00e9 porque esse n\u00f3 est\u00e1 parcialmente contido no intervalo de interesse. // Ent\u00e3o, continuamos procurando nos filhos. ll m = tl + ( tr - tl ) / 2 ; return funcao ( query ( filhoEsq ( no ), tl , m , l , r ), query ( filhoDir ( no ), m + 1 , tr , l , r )); } void update ( ll no , ll tl , ll tr , ll i , ll novoValor ){ // Chegamos no \u00edndice que queremos atualizar o valor if ( tl == i and tr == i ){ st [ no ] = novoValor ; A [ i ] = novoValor ; return ; } // O intervalo que estamos n\u00e3o contem o \u00edndice que queremos atualizar, retorne if ( tl > i or tr < i ) return ; // O intervalo cont\u00e9m o \u00edndice, mas temos que chegar no n\u00f3 espec\u00edfico. // Repetimos o processo recursivamente nos filhos. ll m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , i , novoValor ); update ( filhoDir ( no ), m + 1 , tr , i , novoValor ); // Ap\u00f3s atualizar o filho (esquerdo ou direito), precisamos atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } void build ( ll no , ll L , ll R ) { //Chegamos no n\u00f3 que deve conter o valor de A[L] ou A[R] if ( L == R ) st [ no ] = A [ L ]; else { //Recursivamente construimos a SegTree ll m = L + ( R - L ) / 2 ; build ( filhoEsq ( no ), L , m ); build ( filhoDir ( no ), m + 1 , R ); st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } } public : SegTree ( ll n ) : st ( 4 * n , 0 ), A ( n , 0 ), size ( n ){} SegTree ( const vll & a ) { A = a ; st . resize ( 4 * A . size (), 0 ); size = A . size (); build ( 0 , 0 , size - 1 ); } ll query ( ll l , ll r ) { return query ( 0 , 0 , size - 1 , l , r ); } void update ( ll i , ll x ){ update ( 0 , 0 , size - 1 , i , x ); } }; int main () { // 0 1 2 3 4 5 6 7 8 vll a = { 0 , 1 , 3 , 4 , 8 , 6 , 1 , 4 , 2 }; SegTree st ( a ); cout << st . query ( 0 , 8 ) << \" \\n \" ; // 29 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 0 cout << st . query ( 0 , 3 ) << \" \\n \" ; // 8 cout << st . query ( 0 , 7 ) << \" \\n \" ; // 27 cout << st . query ( 2 , 4 ) << \" \\n \" ; // 15 cout << st . query ( 6 , 8 ) << \" \\n \" ; // 7 st . update ( 0 , 10 ); // A[0] = 10 cout << st . query ( 0 , 8 ) << \" \\n \" ; // 39 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 10 cout << st . query ( 0 , 3 ) << \" \\n \" ; // 18 st . update ( 8 , 7 ); // A[8] = 7; cout << st . query ( 8 , 8 ) << \" \\n \" ; // 7 cout << st . query ( 0 , 8 ) << \" \\n \" ; // 44 return 0 ; } Atualiza\u00e7\u00f5es em Intervalos (Lazy Propagation) Como visto, a fun\u00e7\u00e3o update atualiza apenas uma posi\u00e7\u00e3o do array, mas em alguns casos \u00e9 necess\u00e1rio alterar o valor de um intervalo do array, por exemplo, alterar os elementos da posi\u00e7\u00e3o \\(l\\) a \\(r\\) para \\(x\\) . Uma estrat\u00e9gia ing\u00eanua \u00e9 chamar a fun\u00e7\u00e3o update para cada posi\u00e7\u00e3o do array (complexidade \\(O(n)\\) ). Note que se for necess\u00e1rio alterar todos os elementos do array, uma alternativa \u00e9 alterar apenas a raiz e postergar a atualiza\u00e7\u00e3o dos outros n\u00f3s. Dessa forma, os n\u00f3s filhos s\u00e3o atualizados somente quando for realmente necess\u00e1rio. Esse processo \u00e9 conhecido como Lazy Propagation . \u00c9 importante destacar que, para implementar lazy propagation , cada tipo de SegTree vai requerer uma implementa\u00e7\u00e3o um pouco diferente, por isso, ser\u00e1 importante entender como essa estrat\u00e9gia funciona. Na SegTree com Lazy Propagation , cada segmento (n\u00f3) ter\u00e1 tamb\u00e9m um valor lazy associado. Uma atualiza\u00e7\u00e3o dividir\u00e1 o segmento da mesma forma feita anteriormente e definir\u00e1 o valor lazy em cada segmento alcan\u00e7ado. Assim, sempre que um n\u00f3 for analisado, seja por meio de uma atualiza\u00e7\u00e3o ou uma consulta, uma fun\u00e7\u00e3o, propagate , ser\u00e1 chamada. Essa fun\u00e7\u00e3o fica respons\u00e1vel por atualizar a informa\u00e7\u00e3o no segmento atual e passar o valor lazy para seus filhos. Considere o problema de saber a soma dos elementos de um intervalo e que uma atualiza\u00e7\u00e3o de intervalo significa alterar o valor de todos os elementos do intervalo para um determinado valor. Para isso \u00e9 necess\u00e1rio, al\u00e9m do vetor que armazena a SegTree, outros dois vetores: lazy e marked . O vetor lazy fica respons\u00e1vel por armazenar o valor do segmento que ainda n\u00e3o foi propagado para os n\u00f3s filhos. J\u00e1 o vetor marked (vetor booleano) indica se h\u00e1 uma atualiza\u00e7\u00e3o para ser feita no n\u00f3. A fun\u00e7\u00e3o de propaga\u00e7\u00e3o ( propagate ) \u00e9 a fun\u00e7\u00e3o que atualiza o valor de um n\u00f3 e posterga a atualiza\u00e7\u00e3o para os filhos. Essa fun\u00e7\u00e3o deve ser chamada toda vez que um n\u00f3 for analisado (seja por uma atualiza\u00e7\u00e3o ou uma consulta). O c\u00f3digo abaixo ilustra essa fun\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void propagate ( ll p , ll L , ll R ) { // (1) // Verifica se o n\u00f3 precisa ser atualizado if ( marked [ p ]) { // O valor do n\u00f3 ser\u00e1: n\u00famero de elementos que esse intervalo representa vezes o novo valor de cada elemento do intervalo st [ p ] = ( R - L + 1 ) * lazy [ p ]; // Se o n\u00f3 n\u00e3o for uma folha, propague a atualiza\u00e7\u00e3o para os filhos. if ( L != R ) { lazy [ filhoDir ( p )] = lazy [ filhoEsq ( p )] = lazy [ p ]; marked [ filhoDir ( p )] = marked [ filhoEsq ( p )] = true ; } // N\u00e3o \u00e9 mais necess\u00e1rio atualizar esse n\u00f3 marked [ p ] = false ; } } Par\u00e2metros: p : n\u00f3 atual L : limite inferior do intervalo que p representa (inclusivo) R : limite superior do intervalo que p representa (inclusivo) A fun\u00e7\u00e3o abaixo altera o valor dos elementos do intervalo [l, r] para novoValor . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void update ( ll no , ll tl , ll tr , ll l , ll r , ll novoValor ) { // (1) //Precisamos propagar a poss\u00edvel atualiza\u00e7\u00e3o do n\u00f3 propagate ( no , tl , tr ); // Chegamos no \u00edndice que queremos atualizar o valor if ( tl >= l and tr <= r ) { lazy [ no ] = novoValor ; marked [ no ] = true ; propagate ( no , tl , tr ); return ; } // O intervalo que estamos n\u00e3o contem o \u00edndice que queremos atualizar, retorne if ( tl > r or tr < l ) return ; // O intervalo cont\u00e9m o \u00edndice, mas temos que chegar no n\u00f3 espec\u00edfico. // Repetimos o processo recursivamente nos filhos. ll m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , l , r , novoValor ); update ( filhoDir ( no ), m + 1 , tr , l , r , novoValor ); // Ap\u00f3s atualizar o filho (esquerdo ou direito), precisamos atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } Par\u00e2metros: no : n\u00f3 atual tl : limite inferior do intervalo que no representa (inclusivo) tr : limite superior do intervalo que no representa (inclusivo) l : limite inferior do intervalo que se deseja atualizar no vetor r : limite superior do intervalo que se deseja atualizar no vetor novoValor : novo valor dos elementos no intervalo Vers\u00e3o final da classe SegTree com alguns exemplos de utiliza\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vll ; #define filhoEsq(i) (2*(i) + 1) #define filhoDir(i) (2*(i) + 2) class SegTree { private : vll st , lazy ; vector < bool > marked ; ll size ; ll funcao ( ll a , ll b ) { // Fun\u00e7\u00e3o usada na SegTree: soma return a + b ; } void propagate ( ll p , ll L , ll R ) { if ( marked [ p ]) { // O valor do n\u00f3 ser\u00e1: n\u00famero de elementos que esse intervalo representa vezes o novo valor de cada elemento do intervalo st [ p ] = lazy [ p ] * ( R - L + 1 ); if ( L != R ) { lazy [ filhoDir ( p )] = lazy [ filhoEsq ( p )] = lazy [ p ]; marked [ filhoDir ( p )] = marked [ filhoEsq ( p )] = true ; } marked [ p ] = false ; } } ll query ( ll no , ll tl , ll tr , ll l , ll r ){ //Precisamos propagar a poss\u00edvel atualiza\u00e7\u00e3o do n\u00f3 propagate ( no , tl , tr ); //O n\u00f3 est\u00e1 fora do intervalo de interesse. Retorne o elemento neutro que n\u00e3o afeta a consulta. if ( tr < l || r < tl ) return 0 ; // O n\u00f3 est\u00e1 completamente inclu\u00eddo no intervalo de interesse. Retorne a informa\u00e7\u00e3o contida no n\u00f3. if ( tl >= l and tr <= r ) return st [ no ]; // Se chegarmos aqui, \u00e9 porque esse n\u00f3 est\u00e1 parcialmente contido no intervalo de interesse. Ent\u00e3o, continuamos procurando nos filhos. ll m = tl + ( tr - tl ) / 2 ; return funcao ( query ( filhoEsq ( no ), tl , m , l , r ), query ( filhoDir ( no ), m + 1 , tr , l , r )); } void update ( ll no , ll tl , ll tr , ll l , ll r , ll novoValor ){ //Precisamos propagar a poss\u00edvel atualiza\u00e7\u00e3o do n\u00f3 propagate ( no , tl , tr ); // Chegamos no \u00edndice que queremos atualizar o valor if ( tl >= l and tr <= r ) { lazy [ no ] = novoValor ; marked [ no ] = true ; propagate ( no , tl , tr ); return ; } // O intervalo que estamos n\u00e3o contem o \u00edndice que queremos atualizar, retorne if ( tl > r or tr < l ) return ; // O intervalo cont\u00e9m o \u00edndice, mas temos que chegar no n\u00f3 espec\u00edfico. Repetimos o processo recursivamente nos filhos. ll m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , l , r , novoValor ); update ( filhoDir ( no ), m + 1 , tr , l , r , novoValor ); // Ap\u00f3s atualizar o filho (esquerdo ou direito), precisamos atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } void build ( ll no , ll L , ll R , const vll & A ) { //Chegamos no n\u00f3 que deve conter o valor de A[L] ou A[R] if ( L == R ) st [ no ] = A [ L ]; else { //Recursivamente construimos a SegTree ll m = L + ( R - L ) / 2 ; build ( filhoEsq ( no ), L , m , A ); build ( filhoDir ( no ), m + 1 , R , A ); st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } } public : SegTree ( ll n ) : st ( 4 * n , 0 ), lazy ( 4 * n , 0 ), marked ( 4 * n , false ), size ( n ) {} SegTree ( const vll & a ) { size = a . size (); st . resize ( 4 * size , 0 ); lazy . resize ( 4 * size , 0 ); marked . resize ( 4 * size , false ); build ( 0 , 0 , size - 1 , a ); } ll query ( ll l , ll r ) { return query ( 0 , 0 , size - 1 , l , r ); } void update ( ll i , ll x ){ update ( 0 , 0 , size - 1 , i , i , x ); } void update ( ll l , ll r , ll x ){ update ( 0 , 0 , size - 1 , l , r , x ); } }; int main () { SegTree st ( 10 ); st . update ( 0 , 4 , 1 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 0 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 5 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 0 st . update ( 5 , 9 , 2 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 10 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 15 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 2 st . update ( 0 , 9 , 1 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 5 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 10 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 1 st . update ( 5 , 20 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 24 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 29 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 20 return 0 ; } Material complementar \u2b50\ufe0f Segment Tree, part 1 (ITMO Academy) \ud83e\udd2f \u2b50\ufe0f Segment Tree, part 2 (ITMO Academy) \ud83e\udd2f \u2b50\ufe0f Segment Tree \u2b50\ufe0f Segment Tree (\u00c1rvore de Segmentos) \u2b50\ufe0f Segment Tree com Lazy Propagation Segment Tree (CS Academy) Segment Trees Segment Tree - VisuAlgo Segment Tree Data Structure - Min Max Queries Disjoint Set Union (DSU) Para entender DSU, considere o seguinte problema (extra\u00eddo desse link ): suponha que exista um grupo de \\(N\\) amigos em um jogo. Inicialmente, cada um deles joga contra todos os outros. Conforme o jogo avan\u00e7a, alian\u00e7as s\u00e3o formadas entre eles. A rela\u00e7\u00e3o de alian\u00e7a \u00e9 transitiva, o que significa que se \\(A\\) e \\(B\\) s\u00e3o aliados e \\(B\\) e \\(C\\) s\u00e3o aliados, ent\u00e3o \\(A\\) e \\(C\\) tamb\u00e9m s\u00e3o aliados. Voc\u00ea sabe quando as alian\u00e7as s\u00e3o formadas. Em certos momentos voc\u00ea precisa saber se dois amigos em particular est\u00e3o no mesmo time ou n\u00e3o. Uma estrat\u00e9gia natural seria construir um grafo e, a cada atualiza\u00e7\u00e3o, incluir uma nova aresta ligando dois vertices do grafo. Para cada consulta pode-se realizar um percurso no grafo (usando Busca em Largura ou Busca em Profundidade ) come\u00e7ando no n\u00f3 \\(A\\) e verificando se o n\u00f3 \\(B\\) \u00e9 visitado. Adicionar uma aresta \u00e9 muito r\u00e1pido, mas as consultas s\u00e3o lentas. Uma estrat\u00e9gia mais eficiente para resolver esse problema \u00e9 usar Disjoint Set Union . Um conjunto disjunto , tamb\u00e9m chamado union-find , \u00e9 uma estrutura de dados que opera com um conjunto particionado em v\u00e1rios subconjuntos disjuntos. As duas principais opera\u00e7\u00f5es dessa estrutura s\u00e3o: find : Dado um elemento particular do conjunto, a fun\u00e7\u00e3o identifica o subconjunto do elemento. Para isso, a fun\u00e7\u00e3o retorna o representante do conjunto. join : Une dois subconjuntos em um \u00fanico subconjunto. Um conjunto disjunto funciona representando cada componente conectado como uma \u00e1rvore, onde a raiz de cada \u00e1rvore \u00e9 o representante do componente. O pai de cada n\u00f3 \u00e9 outro n\u00f3 no mesmo componente. Considere o exemplo dos amigos jogando para ver como a estrutura funciona. Suponha que existam 6 amigos jogando. Inicialmente, n\u00e3o h\u00e1 alian\u00e7as, ent\u00e3o cada n\u00f3 \u00e9 a raiz de uma \u00e1rvore (os amigos s\u00e3o numerados de 0 a 5): 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Em seguida, suponha que 1 e 3 se tornem aliados. Considere que o n\u00f3 1 seja escolhido como representante: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Ent\u00e3o 2 e 4 se tornam aliados: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Os amigos 0 e 5 s\u00e3o os pr\u00f3ximos. Considere que 5 seja escolhido como representante: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Finalmente, uma alian\u00e7a \u00e9 formada entre 4 e 3. Nesse caso, \u00e9 preciso pegar a raiz de uma \u00e1rvore e anex\u00e1-la como filho da raiz da outra \u00e1rvore: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Implementa\u00e7\u00e3o A estrutura DSU pode ser implementada usando arrays. Na implementa\u00e7\u00e3o a seguir, o array pai cont\u00e9m para cada elemento o pr\u00f3ximo elemento do encadeamento ou o pr\u00f3prio elemento se ele for um representante. Inicialmente, cada elemento pertence a um conjunto distinto: 1 2 3 4 5 6 vll pai ; void init ( ll N ) { pai . resize ( N + 1 ); iota ( pai . begin (), pai . end (), 0 ); // (1) } std:iota A fun\u00e7\u00e3o find retorna o representante do elemento x . O representante pode ser encontrado seguindo o encadeamento que come\u00e7a em x . O c\u00f3digo abaixo ilustra essa opera\u00e7\u00e3o, note que a complexidade da fun\u00e7\u00e3o \u00e9 \\(O(n)\\) : 1 2 3 4 5 6 ll find ( ll x ) { if ( x == pai [ x ]) return x ; else return find ( pai [ x ]); } 1 2 3 void join ( ll a , ll b ) { pai [ find ( a )] = find ( b ); } Otimiza\u00e7\u00f5es do Union-Find A primeira otimiza\u00e7\u00e3o do algoritmo, conhecida como Path Compression , est\u00e1 na busca do representante de um elemento, ou seja, na fun\u00e7\u00e3o find . Observe que se a fun\u00e7\u00e3o find for eficiente, a fun\u00e7\u00e3o join tamb\u00e9m se torna eficiente. Note que o que gasta tempo na fun\u00e7\u00e3o s\u00e3o as chamadas recursivas da fun\u00e7\u00e3o que precisam passar por todos os ancestrais de um determinado elemento. Por\u00e9m, pode-se usar um princ\u00edpio da Programa\u00e7\u00e3o Din\u00e2mica: evitar o rec\u00e1lculo! Uma vez que calculado o representante de um elemento x (ou seja, find(x) ), pode-se salv\u00e1-lo diretamente como seu pai ( pai[x]=find(x); ). Assim, nas pr\u00f3ximas vezes que for calculado o valor de find(x) , a fun\u00e7\u00e3o retornar\u00e1 seu representante rapidamente, pois ele j\u00e1 estar\u00e1 salvo em pai[x] , o que evita a necessidade de percorrer todos os ancestrais que estavam entre x e o representante. Para fazer essa otimiza\u00e7\u00e3o basta que, na hora de o valor de find(x) for retornado, o mesmo seja salvo em pai[x] . Segue a implementa\u00e7\u00e3o da fun\u00e7\u00e3o find otimizada: 1 2 3 4 5 6 ll find ( ll x ) { if ( x == pai [ x ]) return x ; else return pai [ x ] = find ( pai [ x ]); } Outra otimiza\u00e7ao, conhecida como Union by size , altera a forma como \u00e9 feita a uni\u00e3o dos conjuntos. Na primeira implementa\u00e7\u00e3o da fun\u00e7\u00e3o join , o segundo conjunto sempre \u00e9 anexado ao primeiro, o que pode levar a \u00e1rvores degeneradas. Nessa otimiza\u00e7\u00e3o, o menor conjunto (menor n\u00famero de elementos) \u00e9 unido ao maior conjunto. Segue a implementa\u00e7\u00e3o da fun\u00e7\u00e3o join otimizada: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 vll pai ; vll tamanho ; void init ( ll N ) { pai . resize ( N + 1 ); tamanho . resize ( N + 1 , 1 ); iota ( pai . begin (), pai . end (), 0 ); } void join ( ll a , ll b ) { a = find ( a ); b = find ( b ); if ( a != b ) { if ( tamanho [ a ] < tamanho [ b ]) swap ( a , b ); pai [ b ] = a ; tamanho [ a ] += tamanho [ b ]; } } Material complementar \u2b50\ufe0f Disjoint Sets Union \ud83e\udd2f \u2b50\ufe0f Disjoint Set Union \u2b50\ufe0f Union-Find (Neps Academy) Disjoint-set Data Structures (CSAcademy) Disjoint Set Data Structures (GeeksforGeeks)","title":"Estrutura de Dados (Parte 2)"},{"location":"ed2/#estrutura-de-dados","text":"Nesta parte, ser\u00e3o apresentados duas estruturas baseadas em \u00e1rvores e uma implementa\u00e7\u00e3o de set do GNU C++.","title":"Estrutura de Dados"},{"location":"ed2/#gnu-c-policy-based-sets","text":"O compilador GNU g++ tamb\u00e9m suporta algumas estruturas de dados que n\u00e3o fazem parte da biblioteca padr\u00e3o do C++. Essas estruturas s\u00e3o chamadas de estruturas de dados baseadas em pol\u00edticas ( Policy-Based Data Structures - PBDS ). Para usar essas estruturas \u00e9 necess\u00e1rio incluir o seguinte c\u00f3digo: 1 2 3 #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds ; Alternativamente, pode-se simplificar o c\u00f3digo anterior da seguinte forma: 1 2 #include <bits/extc++.h> using namespace __gnu_pbds ; Ap\u00f3s isso, \u00e9 poss\u00edvel definir um conjunto ordenado indexado (entre as dispon\u00edveis, essa \u00e9 a principal estrutura usada em competi\u00e7\u00f5es de programa\u00e7\u00e3o). Esta estrutura \u00e9 como o set , mas com a possibilidade de acessar os elementos de acordo com a sua posi\u00e7\u00e3o (\u00edndice), como em um array . O c\u00f3digo abaixo, define um conjunto ordenado indexado usando template . 1 2 template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; Veja alguns exemplos de uso da defini\u00e7\u00e3o anterior: 1 2 3 4 indexed_set < int > setInt ; // Conjunto ordenado indexado de inteiros indexed_set < double > setDouble ; // Conjunto ordenado indexado de doubles indexed_set < pair < int , int >> setPairInt ; // Conjunto ordenado indexado de pares de inteiros indexed_set < Pessoa > setPessoa ; // Conjunto ordenado indexado de Pessoas (precisa do operator<) Al\u00e9m das opera\u00e7\u00f5es comuns do set ( insert , erase , size , clear , find , begin , end ), ainda existem duas fun\u00e7\u00f5es muito \u00fateis e que justificam o uso do PBDS: find_by_order(k) : retorna um iterador para o \\(k\\) -\u00e9simo menor elemento (contando a partir de zero) do conjunto em tempo \\(O(\\log n)\\) ; order_of_key(x) : retorna ao n\u00famero de itens estritamente menores que o x em tempo \\(O(\\log n)\\) . Veja um exemplo completo de utiliza\u00e7\u00e3o do PBDS (Fonte: pbds.cpp ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <bits/stdc++.h> #include <bits/extc++.h> // pbds using namespace std ; using namespace __gnu_pbds ; template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; int main () { int n = 9 ; vector < int > A = { 71 , 10 , 2 , 4 , 23 , 7 , 10 , 15 , 23 , 50 , 65 , 71 }; indexed_set < int > iset ; for ( int i = 0 ; i < A . size (); ++ i ) // O(n log n) iset . insert ( A [ i ]); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 9 for ( auto x : iset ) cout << x << \" \" ; cout << \" \\n \" ; // O(log n) select cout << * iset . find_by_order ( 0 ) << \" \\n \" ; // 1-smallest = 2 cout << * iset . find_by_order ( n -1 ) << \" \\n \" ; // 9-smallest/largest = 71 cout << * iset . find_by_order ( 4 ) << \" \\n \" ; // 5-smallest = 15 // O(log n) rank cout << iset . order_of_key ( 2 ) << \" \\n \" ; // index 0 (rank 1) cout << iset . order_of_key ( 71 ) << \" \\n \" ; // index 8 (rank 9) cout << iset . order_of_key ( 15 ) << \" \\n \" ; // index 4 (rank 5) iset . erase ( 2 ); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 8 return 0 ; } Complemente sua leitura e seu conhecimento: Ordered Set and GNU C++ PBDS (GeeksforGeeks) C++ STL: Policy based data structures PBDS Examples","title":"GNU C++ Policy-Based Sets"},{"location":"ed2/#fenwick-binary-indexed-tree","text":"Considere o seguinte problema: Voc\u00ea possui \\(n\\) caixas com bolinhas de gude e deseja: Adicionar bolinhas de gude a caixa \\(i\\) ; Saber a quantidade de bolinhas de gude que existem da caixa \\(a\\) at\u00e9 a caixa \\(b\\) , ou seja, a soma das bolinhas nas caixas \\([a, a+1, a+2, \\dots, b]\\) . O objetivo \u00e9 implementar essas duas opera\u00e7\u00f5es de forma eficiente. Esse problema \u00e9 conhecido como Range Sum Queries (RSQ) . Uma abordagem ing\u00eanua, mostrada abaixo, possui \\(O(1)\\) para a opera\u00e7\u00e3o 1 e \\(O(n)\\) para a 2. Se forem feitas \\(m\\) opera\u00e7\u00f5es 2, no pior caso, a complexidade de tempo ser\u00e1 \\(O(n*m)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 vector < ll > caixas ( n , 0 ); void add ( vector < ll >& caixas , ll i , ll n ) { // O(1) caixas [ i ] += n ; } void sum ( vector < ll >& caixas , ll a , ll b ){ // O(n) ll s = 0 ; for ( ll i = a ; i <= b ; i ++ ) s += caixas [ i ]; return s ; } Para responder range sum queries em sequ\u00eancias din\u00e2micas com melhor complexidade \u00e9 preciso usar estruturas mais sofisticadas, que permitam a atualiza\u00e7\u00e3o das somas pr\u00e9-computadas de forma eficiente. Uma destas estruturas \u00e9 a Binary Indexed Tree ( BIT ou Fenwick Tree ), proposta por Peter M. Fenwick em 1994 . Usando BIT, ambas as opera\u00e7\u00f5es s\u00e3o feitas em \\(O(\\log n)\\) . A ideia da BIT \u00e9 que, assim como um n\u00famero pode ser representado como uma soma de algumas pot\u00eancias de dois, uma soma cumulativa pode ser representada como uma soma de algumas somas cumulativas parciais. Para isso, cada \u00edndice \\(i\\) no array de soma cumulativa \u00e9 respons\u00e1vel pela soma cumulativa do \u00edndice \\(i\\) at\u00e9 \\((i - (1<<r) + 1)\\) , onde \\(r\\) representa a posi\u00e7\u00e3o do \u00faltimo bit 1 da representa\u00e7\u00e3o bin\u00e1ria de \\(i\\) (o \\(p(i) = (1<<r)\\) tamb\u00e9m pode ser visto como a maior pot\u00eancia de \\(2\\) que divide \\(i\\) ). Por exemplo, o \u00edndice \\(15_{10} = 1111_2\\) ficar\u00e1 respons\u00e1vel pela soma do intervalo \\(15 - (1<<0) + 1 = 15 - 1 + 1\\) a \\(15\\) . J\u00e1 o \u00edndice \\(12_{10} = 1100_2\\) ficar\u00e1 respons\u00e1vel pela soma do intervalo \\(12 - (1<<3) + 1 = 12 - 8 + 1 = 9\\) a \\(12\\) , e assim por diante. A tabela abaixo mostra a responsabilidade dos \u00edndices 1 a 16. \u00cdndice Respons\u00e1vel pela soma parcial do intervalo 16 [01, 16] 15 [15, 15] 14 [13, 14] 13 [13, 13] 12 [09, 12] 11 [11, 11] 10 [09, 10] 09 [09, 09] 08 [01, 08] 07 [07, 07] 06 [05, 06] 05 [05, 05] 04 [01, 04] 03 [03, 03] 02 [01, 02] 01 [01, 01] Perceba que todo \u00edndice \u00edmpar fica respons\u00e1vel por um intervalo de tamanho 1 (porqu\u00ea?). J\u00e1 os \u00edndices \\(i\\) que s\u00e3o pot\u00eancia de 2, ficam respons\u00e1veis pelo intervalo \\([1, i]\\) . Tipicamente, a Fenwick Tree \u00e9 implementada usando um array ( vector ), digamos ft , de modo que: 1 ft [ i ] = sum ( i - p ( i ) + 1 , i ); Assim, cada posi\u00e7\u00e3o i cont\u00e9m a soma dos valores de um intervalo do array original cujo comprimento \u00e9 p(i) e que termina na posi\u00e7\u00e3o i . Por exemplo, como p(6) = 2 , ft[6] cont\u00e9m o valor de sum(5,6) . Considere o seguinte array original: A Fenwick Tree correspondente \u00e9 a seguinte: A figura abaixo mostra mais claramente como cada valor na BIT corresponde a um intervalo no array original: Usando uma BIT, qualquer valor de sum(1,i) pode ser calculado em tempo \\(O(\\log n)\\) , pois um intervalo \\([1,i]\\) sempre pode ser dividido em intervalos \\(O(\\log n)\\) cujas somas s\u00e3o armazenadas na \u00e1rvore. Por exemplo, o intervalo \\([1,7]\\) consiste nos seguintes intervalos: Assim, pode-se calcular a soma correspondente da seguinte forma: \\[ sum(1,7) = sum(1,4)+sum(5,6)+sum(7,7) = 16+7+4 = 27 \\] Para calcular o valor de \\(sum(a,b)\\) onde \\(a > 1\\) , pode-se usar o mesmo truque que usado na soma de prefixo: \\[ sum(a,b) = sum(1,b)\u2212sum(1,a\u22121). \\] Como pode-se calcular tanto \\(sum(1, b)\\) quanto \\(sum(1, a\u22121)\\) em tempo \\(O(\\log n)\\) , a complexidade de tempo total \u00e9 \\(O(\\log n)\\) . Al\u00e9m de calcular a soma parcial, tamb\u00e9m \u00e9 poss\u00edvel/necess\u00e1rio atualizar o valor de uma determinada posi\u00e7\u00e3o no array original. Ap\u00f3s a atualiza\u00e7\u00e3o, alguns valores na BIT devem ser atualizados. Por exemplo, se o valor na posi\u00e7\u00e3o 3 mudar, as somas dos seguintes intervalos mudam: Como cada elemento do array pertence a \\(O(\\log n)\\) intervalos na BIT, basta atualizar os \\(O(\\log n)\\) valores na \u00e1rvore.","title":"Fenwick (Binary Indexed) Tree"},{"location":"ed2/#implementacao","text":"O primeiro passo \u00e9 definir como calcular o valor de p(i) , ou seja, a maior pot\u00eancia de \\(2\\) que divide \\(i\\) . Este valor \u00e9 conhecido como o bit menos significativo , abreviado lsb , da representa\u00e7\u00e3o bin\u00e1ria de \\(i\\) . O fun\u00e7\u00e3o abaixo calcula esse valor: 1 2 3 4 5 6 7 int p ( int i ) { int bit = 0 ; while (( i >> bit ) & 1 == 0 ) { ++ bit ; } return ( 1 << bit ); } Essa fun\u00e7\u00e3o possui complexidade \\(O(\\log n)\\) . Entretanto, usando manipula\u00e7\u00e3o de bits , pode-se encontrar esse valor de forma mais eficiente. Lembre-se que um n\u00famero negativo \u00e9 representado usando complemento de 2, ou seja, pega-se a representa\u00e7\u00e3o bin\u00e1ria de x , inverte-se os bits e adiciona 1 (ignorando o resto final). Por exemplo, considere x = 108 e que os valores s\u00e3o representados em 8 bits: 1 2 3 x = 01101100 ~x = 10010011 -x = 10010100 Observe que os bits mais significativos que o lsb s\u00e3o diferentes para x e -x , enquanto o lsb e os 0s seguintes s\u00e3o os mesmos. Portanto, x & \u2212x d\u00e1 a resposta desejada, ou seja: x & -x = 00000100 . Com essa estrat\u00e9gia, pode-se calcular o valor de lsb , consequentemente, o valor de p(i) em \\(O(1)\\) : 1 2 3 long long lsb ( long long i ) { // (1) return i & - i ; } Normalmente, essa fun\u00e7\u00e3o \u00e9 feita como uma macro: #define lsb(i) ((i) & -(i)) A fun\u00e7\u00f5es a seguir calculam o valor de \\(sum(1,i)\\) e \\(sum(a, b)\\) , respectivamente: 1 2 3 4 5 6 7 8 9 10 11 long long sum ( long long i ) { long long s = 0 ; while ( i >= 1 ) { s += ft [ i ]; i -= lsb ( i ); } return s ; } long long sum ( long long a , long long b ) { return sum ( b ) - sum ( a -1 ); } A seguinte fun\u00e7\u00e3o aumenta o valor do array na posi\u00e7\u00e3o \\(i\\) em \\(x\\) ( \\(x\\) pode ser positivo ou negativo): 1 2 3 4 5 6 void add ( int i , int x ) { // Normalmente, essa fun\u00e7\u00e3o tamb\u00e9m \u00e9 chamada de update while ( i < ft . size ()) { ft [ i ] += x ; i += lsb ( i ); } } Para construir a BIT a partir de um array original, uma primeira estrat\u00e9gia \u00e9 iniciar o array ft com valor 0 em todas as posi\u00e7\u00f5es. Em seguida, para cada posi\u00e7\u00e3o \\(i\\) , chama-se a fun\u00e7\u00e3o add passando o valor do array original como valor a ser incrementado, o que daria resultaria em \\(O(n \\log n)\\) opera\u00e7\u00f5es. Veja a fun\u00e7\u00e3o abaixo: 1 2 3 4 5 void build ( const vector < ll >& a ) { ft . assign ( a . size () + 1 , 0 ); for ( ll i = 1 ; i < a . size (); i ++ ) add ( i , a [ i ]); } Entretanto, note que ap\u00f3s atualizar o valor de ft[i] , pode-se verificar se o \"pai\" de \\(i\\) \u00e9 menor que \\(N\\) (tamanho do array). Se for, atualiza-se o \"pai\" tamb\u00e9m. Dessa forma, temos uma fun\u00e7\u00e3o com complexidade \\(O(n)\\) . 1 2 3 4 5 6 7 8 9 void build ( const vector < ll >& a ) { ll m = ( ll ) a . size () - 1 ; ft . assign ( m + 1 , 0 ); for ( ll i = 1 ; i <= m ; i ++ ) { ft [ i ] += a [ i ]; if ( i + lsb ( i ) <= m ) ft [ i + lsb ( i )] += a [ i ]; } } Tamb\u00e9m \u00e9 poss\u00edvel encontrar o menor \u00edndice \\(i\\) tal que soma acumulativa do intervalo \\([1..i] \\geq k\\) . Como as somas acumulativas dos valores est\u00e3o ordenadas, pode-se usar a busca bin\u00e1ria para encontrar tal \u00edndice. Basicamente, testa-se o \u00edndice do meio \\(m = n / 2\\) do intervalo inicial \\([1..n]\\) e verifica se sum(1, i) \u00e9 menor que \\(k\\) ou n\u00e3o. Para cada valor de \\(m\\) , tem-se \\(O(\\log n)\\) opera\u00e7\u00f5es, logo, essa fun\u00e7\u00e3o ter\u00e1 complexidade \\(O(\\log n \\times \\log n) = O(\\log^2 n)\\) . O c\u00f3digo abaixo ilustra tal fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 ll select ( ll k ) { ll ini = 1 , fim = ft . size () - 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { // (1) ll m = ( ini + fim ) / 2 ; if ( sum ( 1 , m ) < k ) ini = m ; else fim = m ; } return fim ; } \\(2^{30} > 10^9\\) , normalmente \u00e9 suficiente. O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o completa de uma BIT. Note que foi usado uma vers\u00e3o baseada em orienta\u00e7\u00e3o \u00e0 objetos, mas isso n\u00e3o \u00e9 necess\u00e1rio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vll ; #define lsb(i) ((i) & -(i)) class FenwickTree { private : vll ft ; public : FenwickTree ( ll m ) { ft . resize ( m + 1 , 0 ); } FenwickTree ( const vll & a ) { build ( a ); } ll sum ( ll i ) { ll s = 0 ; while ( i >= 1 ) { s += ft [ i ]; i -= lsb ( i ); } return s ; } ll sum ( ll a , ll b ) { return sum ( b ) - sum ( a -1 ); } void add ( ll i , ll x ) { while ( i < ( ll ) ft . size ()) { ft [ i ] += x ; i += lsb ( i ); } } void build ( const vll & a ) { ll m = ( ll ) a . size () - 1 ; ft . resize ( m + 1 , 0 ); for ( ll i = 1 ; i <= m ; i ++ ) { ft [ i ] += a [ i ]; if ( i + lsb ( i ) <= m ) ft [ i + lsb ( i )] += ft [ i ]; } } ll select ( ll k ) { ll ini = 1 , fim = ( ll ) ft . size () - 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { ll m = ini + ( fim - ini ) / 2 ; if ( sum ( 1 , m ) < k ) ini = m ; else fim = m ; } return fim ; } }; int main () { // 1 2 3 4 5 6 7 8 vll f = { 0 , 1 , 3 , 4 , 8 , 6 , 1 , 4 , 2 }; // Indice 0 n\u00e3o \u00e9 utilizado FenwickTree ft ( f ); cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 29 cout << ft . sum ( 1 , 3 ) << \" \\n \" ; // ft[3] + ft[2] = 4 + 4 = 8 cout << ft . sum ( 1 , 7 ) << \" \\n \" ; // ft[7] + ft[6] + ft[4] = 16 + 7 + 4 = 27 cout << ft . sum ( 2 , 4 ) << \" \\n \" ; // sum(1, 4) - sum(1, 1) = ft[4] - ft[1] = 16 - 1 = 15 cout << ft . sum ( 6 , 8 ) << \" \\n \" ; // sum(1, 8) - sum(1, 5) = ft[8] - (ft[5] + ft[4]) = 29 - (6 + 16) = 7 ft . add ( 8 , 2 ); // Aumenta em duas unidades o valor da posi\u00e7\u00e3o 8 cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 31 ft . add ( 8 , -2 ); // Reduz em duas unidades o valor da posi\u00e7\u00e3o 8 cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 29 ft . add ( 8 , - f [ 8 ]); // Zera o valor da posi\u00e7\u00e3o 8 cout << ft . sum ( 1 , 8 ) << \" \\n \" ; // ft[8] = 27 cout << ft . select ( 4 ) << \" \\n \" ; // Indice 2, sum(1, 2) == 4, que \u00e9 >= 4 cout << ft . select ( 5 ) << \" \\n \" ; // Indice 3, sum(1, 3) == 8, que \u00e9 >= 8 cout << ft . select ( 25 ) << \" \\n \" ; // Indice 7, sum(1, 7) == 27, que \u00e9 >= 25 return 0 ; }","title":"Implementa\u00e7\u00e3o"},{"location":"ed2/#quando-usar","text":"Para utilizar uma \u00e1rvore de Fenwick para realizar a opera\u00e7\u00e3o \\(\\odot\\) em um intervalo de \u00edndices \\([i,j]\\) da sequ\u00eancia \\(a_k\\) , \u00e9 necess\u00e1rio que esta opera\u00e7\u00e3o tenha duas propriedades: Associatividade: para quaisquer \\(x, y, z \\in a_k\\) , deve valer que: \\((x \\odot y)\\odot z = x \\odot (y \\odot z)\\) ; Invertibilidade: para qualquer \\(x \\in a_k\\) , deve existir um valor \\(y\\) tal que \\(x\\odot y = I\\) , onde \\(I\\) \u00e9 o elemento neutro/identidade da opera\u00e7\u00e3o \\(\\odot\\) . Como exemplos de opera\u00e7\u00f5es que t\u00eam ambas propriedades tem-se a adi\u00e7\u00e3o e a multiplica\u00e7\u00e3o de racionais, a adi\u00e7\u00e3o de matrizes e o ou exclusivo (xor).","title":"Quando usar?"},{"location":"ed2/#material-complementar","text":"Binary Indexed Tree or Fenwick Tree (GeeksforGeeks) Fenwick Tree Binary Indexed Trees (Topcoder) Fenwick Tree (Binary Index Tree) - Quick Tutorial and Source Code Explanation Tutorial: Binary Indexed Tree (Fenwick Tree) Binary Indexed (Fenwick) Tree - VisuAlgo","title":"Material complementar"},{"location":"ed2/#segment-tree","text":"Segment tree (\u00c1rvore de Segmento ou SegTree ) \u00e9 outra estrutura de dados para lidar com problemas de consulta em intervalos. O que torna as SegTrees poderosas \u00e9 sua capacidade de fazer atualiza\u00e7\u00e3o e consulta em intervalos com complexidade \\(O(\\log n)\\) , al\u00e9m do tipo da consulta ser bem abrangente. Entretanto, comparada a BIT, uma SegTree requer mais mem\u00f3ria e \u00e9 um pouco mais dif\u00edcil de implementar. A ideia da SegTree \u00e9 a seguinte: cria-se uma \u00e1rvore de forma que cada n\u00f3 representa a informa\u00e7\u00e3o que deseja-se saber a respeito de um segmento do vetor (por exemplo, a soma). Cada n\u00f3 (exceto as folhas) possui dois filhos, um filho representa a metade esquerda do intervalo e o outro, a metade direita. Esse processo repete-se (recursivamente) at\u00e9 que os intervalos atinjam tamanho 1. Assim, considerando o Range Sum Queries (RSQ), o n\u00f3 ra\u00edz da \u00e1rvore armazena a soma de todo o array, ou seja, a soma do segmento \\(a[0 \\dots n-1]\\) . Em seguida, essa segmento \u00e9 dividido em dois: o filho da esquerda fica respons\u00e1vel pelo calcular/armazenar a soma da metade da esquerda do segmento (ou seja, \\(a[0 \\dots n/2]\\) ) e o filho da direita respons\u00e1vel pela metade da direita do segmento (ou seja, \\(a[n/2+1 \\dots n-1]\\) ). Cada um desses n\u00f3s \u00e9 novamente dividido e calcula-se a soma de cada novo intervalo. Repete-se o processo at\u00e9 todos os segmentos atingirem tamanho 1. Nesse link voc\u00ea encontra uma demonstra\u00e7\u00e3o visual de como a SegTree funciona. Veja uma representa\u00e7\u00e3o visual de uma SegTree para o array a = [1,3,\u22122,8,\u22127] : Fonte: Algorithms for Competitive Programming Note que o primeiro n\u00edvel da \u00e1rvore cont\u00e9m um \u00fanico n\u00f3 (a raiz), o segundo n\u00edvel cont\u00e9m 2 n\u00f3s, no terceiro cont\u00e9m 4, e assim por diante, at\u00e9 que o n\u00famero de n\u00f3s alcance \\(n\\) . Portanto, o n\u00famero de n\u00f3s, no pior caso, pode ser estimado pela soma \\(1+2+4+\\cdots+2^{\\lceil \\log_2 n \\rceil}=2^{ \\lceil \\log_2 n \\rceil+1} < 4n\\) .","title":"Segment Tree"},{"location":"ed2/#consultas","text":"Suponha que deseja-se fazer uma consulta (por exemplo, calcular a soma, valor m\u00ednimo/m\u00e1ximo, etc.) no intervalo \\(l\\) e \\(r\\) , ou seja, deseja-se fazer um consulta no segmento \\(a[l \\dots r]\\) . Para isso, deve-se percorrer a \u00e1rvore de segmentos e usar os valores pr\u00e9-computados dos segmentos. Considere que a consulta esteja no v\u00e9rtice que cobre o segmento \\(a[tl \\dots tr]\\) . Existem tr\u00eas possibilidades: O n\u00f3 est\u00e1 fora do intervalo de interesse, ou seja, tr < l || r < tl . Retorne um valor neutro que n\u00e3o afete a cunsulta (por exemplo, se a opera\u00e7\u00e3o for a soma, retorne 0); O n\u00f3 est\u00e1 completamente inclu\u00eddo no intervalos de interesse, ou seja, tl >= l && tr <= r . Retorne a informa\u00e7\u00e3o armazenada no n\u00f3; O n\u00f3 est\u00e1 parcialmente contido no intervalo de interesse, ou seja, ( l <= tr && tr <= r ) || ( l <= tl && tl <= r ) . Ent\u00e3o, a consulta continua nos n\u00f3s filhos. A figura abaixo ilustra esse processo para encontrar a soma do segmento \\(a[2 \\dots 4]\\) para o array a = [1,3,\u22122,8,\u22127] . Os n\u00f3s coloridos ser\u00e3o visitados e usa-se os valores pr\u00e9-calculados dos n\u00f3s verdes. Assim, o resultado ser\u00e1 \\(\u22122 + 1=\u22121\\) . O n\u00famero de n\u00f3s visitados \u00e9 proporcional \u00e0 altura da \u00e1rvore, ou seja, \\(O(\\log n)\\) . Fonte: Algorithms for Competitive Programming","title":"Consultas"},{"location":"ed2/#atualizacoes","text":"Fazer uma atualiza\u00e7\u00e3o no array original (por exemplo, fazer a[i] = x ) implica que a SegTree tamb\u00e9m deve ter alguns n\u00f3s atualizados, de modo que ela corresponda ao novo array modificado. Perceba que cada n\u00edvel de uma SegTree forma uma parti\u00e7\u00e3o do array. Portanto, um elemento a[i] apenas contribui para um segmento de cada n\u00edvel. Assim, apenas \\(O(\\log n)\\) n\u00f3s necessitam ser atualizadas. A atualiza\u00e7\u00e3o dos elementos pode ser facilmente implementada usando uma fun\u00e7\u00e3o recursiva. A fun\u00e7\u00e3o passa pelo n\u00f3 atual da \u00e1rvore e recursivamente chama a si mesma com um dos dois n\u00f3s filhos (aquele que cont\u00e9m a[i] em seu segmento) e, em seguida, recalcula seu valor. Considerando a SegTree do array a = [1,3,\u22122,8,\u22127] , ao fazer a[2] = 3 , os n\u00f3s verdes s\u00e3o os n\u00f3s visitados e atualizados. Fonte: Algorithms for Competitive Programming","title":"Atualiza\u00e7\u00f5es"},{"location":"ed2/#implementacao_1","text":"A primeira fun\u00e7\u00e3o a ser analisada/implementada \u00e9 a build , respons\u00e1vel por criar a SegTree. Assim como na BIT, aqui tamb\u00e9m pode-se usar um array para armazenar os n\u00f3s da SegTree (considere que o array se chama st ). O \u00edndice 0 \u00e9 a ra\u00edz e os filhos da esquerda e direita do \u00edndice \\(i\\) s\u00e3o os \u00edndices \\(2 \\times i + 1\\) e \\(2 \\times i + 2\\) , respectivamente. A raiz da SegTree representa o segmento completo [0, n-1] do array A . Para cada segmento [L, R] armazenado no \u00edndice \\(i\\) , onde L != R , o segmento \u00e9 dividido no sub-segmento [L, (L+R)/2] (armazenado no \u00edndice \\(2 \\times i + 1\\) ) e sub-segmento [(L+R)/2 + 1, R] (armazenado no \u00edndice \\(2 \\times i + 2\\) ). Essa divis\u00e3o continua at\u00e9 que o segmento tenha tamanho 1 (isto \u00e9, L == R ), o que indica que chegou-se em um n\u00f3 folha e, pela defini\u00e7\u00e3o de SegTree, esse n\u00f3 deve receber o valor correspondente de A , ou seja, st[i] = A[L] ou st[i] = A[R] . A fun\u00e7\u00e3o build abaixo ilustra o processo de constru\u00e7\u00e3o de uma SegTree a partir do array A . Perceba que foi usada a fun\u00e7\u00e3o funcao para fazer a atualiza\u00e7\u00e3o dos n\u00f3s da \u00e1rvore. Nesse exemplo, a SegTree ser\u00e1 respons\u00e1vel por realizar a soma dos elementos (RSQ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #define filhoEsq(i) (2*(i) + 1) #define filhoDir(i) (2*(i) + 2) long long funcao ( long long a , long long b ) { // Fun\u00e7\u00e3o usada na SegTree: soma return a + b ; } void build ( long long i , long long L , long long R ) { if ( L > R ) return ; //N\u00f3 (folha) que deve conter o valor de A[L] ou A[R] if ( L == R ) st [ i ] = A [ L ]; else { //Recursivamente constroi-se a SegTree long long m = L + ( R - L ) / 2 ; build ( filhoEsq ( i ), L , m ); build ( filhoDir ( i ), m + 1 , R ); //Ap\u00f3s atualizar o valor dos n\u00f3s filhos de 'i', atualiza-se o valor do n\u00f3 'i' st [ i ] = funcao ( st [ filhoEsq ( i )], st [ filhoDir ( i )]); } } A pr\u00f3xima fun\u00e7\u00e3o a ser analisada/implementada \u00e9 a query , respons\u00e1vel por fazer as consultas. Ao analisar o n\u00f3 \\(i\\) , respons\u00e1vel pelo intervalo [tl, tr] , como explicado na se\u00e7\u00e3o Atualiza\u00e7\u00f5es , existem tr\u00eas possibilidades. O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o da fun\u00e7\u00e3o query , ela recebe como par\u00e2metros informa\u00e7\u00f5es sobre o n\u00f3/segmento atual (ou seja, o \u00edndice \\(i\\) e os limites \\(tl\\) e \\(tr\\) ) e tamb\u00e9m os limites da consulta, \\(l\\) e \\(r\\) . Para fazer uma consulta no intervalo [l, r] , a fun\u00e7\u00e3o deve ser chamada da seguinte forma: query(0, 0, n - 1, l, r) , onde n representa o n\u00famero de elementos de A . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 long long query ( long long i , long long tl , long long tr , long long l , long long r ){ //O n\u00f3 i est\u00e1 fora do intervalo de interesse. //Retorne o elemento neutro que n\u00e3o afeta a consulta. if ( tr < l || r < tl ) return 0 ; // Elemento neutro da RSQ // O n\u00f3 i est\u00e1 completamente inclu\u00eddo no intervalo de interesse. // Retorne a informa\u00e7\u00e3o contida no n\u00f3. if ( tl >= l and tr <= r ) return st [ i ]; // Se a execu\u00e7\u00e3o chegou nesse ponto, significa que o n\u00f3 i est\u00e1 parcialmente // contido no intervalo de interesse. Ent\u00e3o, continua-se a procura nos n\u00f3s filhos. long long m = tl + ( tr - tl ) / 2 ; return funcao ( query ( filhoEsq ( i ), tl , m , l , r ), query ( filhoDir ( i ), m + 1 , tr , l , r )); } A fun\u00e7\u00e3o update \u00e9 respons\u00e1vel por fazer atualiza\u00e7\u00f5es no array A e, consequentemente, na SegTree. O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o da fun\u00e7\u00e3o update , ela recebe como par\u00e2metros informa\u00e7\u00f5es sobre o n\u00f3/segmento atual (ou seja, o \u00edndice \\(no\\) e os limites \\(tl\\) e \\(tr\\) ), o \u00edndice \\(i\\) que se deseja atualizar e o novo valor a ser armazenado na posi\u00e7\u00e3o \\(i\\) . Para fazer A[i] = x , a fun\u00e7\u00e3o deve ser chamada da seguinte forma: update(0, 0, n - 1, i, x); , onde n representa o n\u00famero de elementos de A . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void update ( long long no , long long tl , long long tr , long long i , long long novoValor ){ // \u00cdndice cujo valor deve ser atualizado if ( tl == i and tr == i ){ st [ no ] = novoValor ; A [ i ] = novoValor ; return ; } // O intervalo n\u00e3o contem o \u00edndice a ser atualizado if ( tl > i or tr < i ) return ; // O intervalo cont\u00e9m o \u00edndice, mas deve-se chegar no n\u00f3 espec\u00edfico. // O processo \u00e9 repetido recursivamente nos filhos. long long m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , i , novoValor ); update ( filhoDir ( no ), m + 1 , tr , i , novoValor ); // Ap\u00f3s atualizar os filhos (esquerdo ou direito), deve-se atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } O c\u00f3digo abaixo mostra uma implementa\u00e7\u00e3o completa de uma SegTree. Note que foi usado uma vers\u00e3o baseada em orienta\u00e7\u00e3o \u00e0 objetos, mas isso n\u00e3o \u00e9 necess\u00e1rio. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vll ; #define filhoEsq(i) (2*(i) + 1) #define filhoDir(i) (2*(i) + 2) class SegTree { private : vll st , A ; ll size ; ll el_neutro = 0 ; ll funcao ( ll a , ll b ) { // Fun\u00e7\u00e3o usada na SegTree: soma return a + b ; } ll query ( ll no , ll tl , ll tr , ll l , ll r ){ //O n\u00f3 est\u00e1 fora do intervalo de interesse. //Retorne o elemento neutro que n\u00e3o afeta a consulta. if ( tr < l || r < tl ) return el_neutro ; // O n\u00f3 est\u00e1 completamente inclu\u00eddo no intervalo de interesse. // Retorne a informa\u00e7\u00e3o contida no n\u00f3. if ( tl >= l and tr <= r ) return st [ no ]; // Se chegarmos aqui, \u00e9 porque esse n\u00f3 est\u00e1 parcialmente contido no intervalo de interesse. // Ent\u00e3o, continuamos procurando nos filhos. ll m = tl + ( tr - tl ) / 2 ; return funcao ( query ( filhoEsq ( no ), tl , m , l , r ), query ( filhoDir ( no ), m + 1 , tr , l , r )); } void update ( ll no , ll tl , ll tr , ll i , ll novoValor ){ // Chegamos no \u00edndice que queremos atualizar o valor if ( tl == i and tr == i ){ st [ no ] = novoValor ; A [ i ] = novoValor ; return ; } // O intervalo que estamos n\u00e3o contem o \u00edndice que queremos atualizar, retorne if ( tl > i or tr < i ) return ; // O intervalo cont\u00e9m o \u00edndice, mas temos que chegar no n\u00f3 espec\u00edfico. // Repetimos o processo recursivamente nos filhos. ll m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , i , novoValor ); update ( filhoDir ( no ), m + 1 , tr , i , novoValor ); // Ap\u00f3s atualizar o filho (esquerdo ou direito), precisamos atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } void build ( ll no , ll L , ll R ) { //Chegamos no n\u00f3 que deve conter o valor de A[L] ou A[R] if ( L == R ) st [ no ] = A [ L ]; else { //Recursivamente construimos a SegTree ll m = L + ( R - L ) / 2 ; build ( filhoEsq ( no ), L , m ); build ( filhoDir ( no ), m + 1 , R ); st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } } public : SegTree ( ll n ) : st ( 4 * n , 0 ), A ( n , 0 ), size ( n ){} SegTree ( const vll & a ) { A = a ; st . resize ( 4 * A . size (), 0 ); size = A . size (); build ( 0 , 0 , size - 1 ); } ll query ( ll l , ll r ) { return query ( 0 , 0 , size - 1 , l , r ); } void update ( ll i , ll x ){ update ( 0 , 0 , size - 1 , i , x ); } }; int main () { // 0 1 2 3 4 5 6 7 8 vll a = { 0 , 1 , 3 , 4 , 8 , 6 , 1 , 4 , 2 }; SegTree st ( a ); cout << st . query ( 0 , 8 ) << \" \\n \" ; // 29 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 0 cout << st . query ( 0 , 3 ) << \" \\n \" ; // 8 cout << st . query ( 0 , 7 ) << \" \\n \" ; // 27 cout << st . query ( 2 , 4 ) << \" \\n \" ; // 15 cout << st . query ( 6 , 8 ) << \" \\n \" ; // 7 st . update ( 0 , 10 ); // A[0] = 10 cout << st . query ( 0 , 8 ) << \" \\n \" ; // 39 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 10 cout << st . query ( 0 , 3 ) << \" \\n \" ; // 18 st . update ( 8 , 7 ); // A[8] = 7; cout << st . query ( 8 , 8 ) << \" \\n \" ; // 7 cout << st . query ( 0 , 8 ) << \" \\n \" ; // 44 return 0 ; }","title":"Implementa\u00e7\u00e3o"},{"location":"ed2/#atualizacoes-em-intervalos-lazy-propagation","text":"Como visto, a fun\u00e7\u00e3o update atualiza apenas uma posi\u00e7\u00e3o do array, mas em alguns casos \u00e9 necess\u00e1rio alterar o valor de um intervalo do array, por exemplo, alterar os elementos da posi\u00e7\u00e3o \\(l\\) a \\(r\\) para \\(x\\) . Uma estrat\u00e9gia ing\u00eanua \u00e9 chamar a fun\u00e7\u00e3o update para cada posi\u00e7\u00e3o do array (complexidade \\(O(n)\\) ). Note que se for necess\u00e1rio alterar todos os elementos do array, uma alternativa \u00e9 alterar apenas a raiz e postergar a atualiza\u00e7\u00e3o dos outros n\u00f3s. Dessa forma, os n\u00f3s filhos s\u00e3o atualizados somente quando for realmente necess\u00e1rio. Esse processo \u00e9 conhecido como Lazy Propagation . \u00c9 importante destacar que, para implementar lazy propagation , cada tipo de SegTree vai requerer uma implementa\u00e7\u00e3o um pouco diferente, por isso, ser\u00e1 importante entender como essa estrat\u00e9gia funciona. Na SegTree com Lazy Propagation , cada segmento (n\u00f3) ter\u00e1 tamb\u00e9m um valor lazy associado. Uma atualiza\u00e7\u00e3o dividir\u00e1 o segmento da mesma forma feita anteriormente e definir\u00e1 o valor lazy em cada segmento alcan\u00e7ado. Assim, sempre que um n\u00f3 for analisado, seja por meio de uma atualiza\u00e7\u00e3o ou uma consulta, uma fun\u00e7\u00e3o, propagate , ser\u00e1 chamada. Essa fun\u00e7\u00e3o fica respons\u00e1vel por atualizar a informa\u00e7\u00e3o no segmento atual e passar o valor lazy para seus filhos. Considere o problema de saber a soma dos elementos de um intervalo e que uma atualiza\u00e7\u00e3o de intervalo significa alterar o valor de todos os elementos do intervalo para um determinado valor. Para isso \u00e9 necess\u00e1rio, al\u00e9m do vetor que armazena a SegTree, outros dois vetores: lazy e marked . O vetor lazy fica respons\u00e1vel por armazenar o valor do segmento que ainda n\u00e3o foi propagado para os n\u00f3s filhos. J\u00e1 o vetor marked (vetor booleano) indica se h\u00e1 uma atualiza\u00e7\u00e3o para ser feita no n\u00f3. A fun\u00e7\u00e3o de propaga\u00e7\u00e3o ( propagate ) \u00e9 a fun\u00e7\u00e3o que atualiza o valor de um n\u00f3 e posterga a atualiza\u00e7\u00e3o para os filhos. Essa fun\u00e7\u00e3o deve ser chamada toda vez que um n\u00f3 for analisado (seja por uma atualiza\u00e7\u00e3o ou uma consulta). O c\u00f3digo abaixo ilustra essa fun\u00e7\u00e3o. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void propagate ( ll p , ll L , ll R ) { // (1) // Verifica se o n\u00f3 precisa ser atualizado if ( marked [ p ]) { // O valor do n\u00f3 ser\u00e1: n\u00famero de elementos que esse intervalo representa vezes o novo valor de cada elemento do intervalo st [ p ] = ( R - L + 1 ) * lazy [ p ]; // Se o n\u00f3 n\u00e3o for uma folha, propague a atualiza\u00e7\u00e3o para os filhos. if ( L != R ) { lazy [ filhoDir ( p )] = lazy [ filhoEsq ( p )] = lazy [ p ]; marked [ filhoDir ( p )] = marked [ filhoEsq ( p )] = true ; } // N\u00e3o \u00e9 mais necess\u00e1rio atualizar esse n\u00f3 marked [ p ] = false ; } } Par\u00e2metros: p : n\u00f3 atual L : limite inferior do intervalo que p representa (inclusivo) R : limite superior do intervalo que p representa (inclusivo) A fun\u00e7\u00e3o abaixo altera o valor dos elementos do intervalo [l, r] para novoValor . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void update ( ll no , ll tl , ll tr , ll l , ll r , ll novoValor ) { // (1) //Precisamos propagar a poss\u00edvel atualiza\u00e7\u00e3o do n\u00f3 propagate ( no , tl , tr ); // Chegamos no \u00edndice que queremos atualizar o valor if ( tl >= l and tr <= r ) { lazy [ no ] = novoValor ; marked [ no ] = true ; propagate ( no , tl , tr ); return ; } // O intervalo que estamos n\u00e3o contem o \u00edndice que queremos atualizar, retorne if ( tl > r or tr < l ) return ; // O intervalo cont\u00e9m o \u00edndice, mas temos que chegar no n\u00f3 espec\u00edfico. // Repetimos o processo recursivamente nos filhos. ll m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , l , r , novoValor ); update ( filhoDir ( no ), m + 1 , tr , l , r , novoValor ); // Ap\u00f3s atualizar o filho (esquerdo ou direito), precisamos atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } Par\u00e2metros: no : n\u00f3 atual tl : limite inferior do intervalo que no representa (inclusivo) tr : limite superior do intervalo que no representa (inclusivo) l : limite inferior do intervalo que se deseja atualizar no vetor r : limite superior do intervalo que se deseja atualizar no vetor novoValor : novo valor dos elementos no intervalo Vers\u00e3o final da classe SegTree com alguns exemplos de utiliza\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vll ; #define filhoEsq(i) (2*(i) + 1) #define filhoDir(i) (2*(i) + 2) class SegTree { private : vll st , lazy ; vector < bool > marked ; ll size ; ll funcao ( ll a , ll b ) { // Fun\u00e7\u00e3o usada na SegTree: soma return a + b ; } void propagate ( ll p , ll L , ll R ) { if ( marked [ p ]) { // O valor do n\u00f3 ser\u00e1: n\u00famero de elementos que esse intervalo representa vezes o novo valor de cada elemento do intervalo st [ p ] = lazy [ p ] * ( R - L + 1 ); if ( L != R ) { lazy [ filhoDir ( p )] = lazy [ filhoEsq ( p )] = lazy [ p ]; marked [ filhoDir ( p )] = marked [ filhoEsq ( p )] = true ; } marked [ p ] = false ; } } ll query ( ll no , ll tl , ll tr , ll l , ll r ){ //Precisamos propagar a poss\u00edvel atualiza\u00e7\u00e3o do n\u00f3 propagate ( no , tl , tr ); //O n\u00f3 est\u00e1 fora do intervalo de interesse. Retorne o elemento neutro que n\u00e3o afeta a consulta. if ( tr < l || r < tl ) return 0 ; // O n\u00f3 est\u00e1 completamente inclu\u00eddo no intervalo de interesse. Retorne a informa\u00e7\u00e3o contida no n\u00f3. if ( tl >= l and tr <= r ) return st [ no ]; // Se chegarmos aqui, \u00e9 porque esse n\u00f3 est\u00e1 parcialmente contido no intervalo de interesse. Ent\u00e3o, continuamos procurando nos filhos. ll m = tl + ( tr - tl ) / 2 ; return funcao ( query ( filhoEsq ( no ), tl , m , l , r ), query ( filhoDir ( no ), m + 1 , tr , l , r )); } void update ( ll no , ll tl , ll tr , ll l , ll r , ll novoValor ){ //Precisamos propagar a poss\u00edvel atualiza\u00e7\u00e3o do n\u00f3 propagate ( no , tl , tr ); // Chegamos no \u00edndice que queremos atualizar o valor if ( tl >= l and tr <= r ) { lazy [ no ] = novoValor ; marked [ no ] = true ; propagate ( no , tl , tr ); return ; } // O intervalo que estamos n\u00e3o contem o \u00edndice que queremos atualizar, retorne if ( tl > r or tr < l ) return ; // O intervalo cont\u00e9m o \u00edndice, mas temos que chegar no n\u00f3 espec\u00edfico. Repetimos o processo recursivamente nos filhos. ll m = tl + ( tr - tl ) / 2 ; update ( filhoEsq ( no ), tl , m , l , r , novoValor ); update ( filhoDir ( no ), m + 1 , tr , l , r , novoValor ); // Ap\u00f3s atualizar o filho (esquerdo ou direito), precisamos atualizar o valor do n\u00f3. st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } void build ( ll no , ll L , ll R , const vll & A ) { //Chegamos no n\u00f3 que deve conter o valor de A[L] ou A[R] if ( L == R ) st [ no ] = A [ L ]; else { //Recursivamente construimos a SegTree ll m = L + ( R - L ) / 2 ; build ( filhoEsq ( no ), L , m , A ); build ( filhoDir ( no ), m + 1 , R , A ); st [ no ] = funcao ( st [ filhoEsq ( no )], st [ filhoDir ( no )]); } } public : SegTree ( ll n ) : st ( 4 * n , 0 ), lazy ( 4 * n , 0 ), marked ( 4 * n , false ), size ( n ) {} SegTree ( const vll & a ) { size = a . size (); st . resize ( 4 * size , 0 ); lazy . resize ( 4 * size , 0 ); marked . resize ( 4 * size , false ); build ( 0 , 0 , size - 1 , a ); } ll query ( ll l , ll r ) { return query ( 0 , 0 , size - 1 , l , r ); } void update ( ll i , ll x ){ update ( 0 , 0 , size - 1 , i , i , x ); } void update ( ll l , ll r , ll x ){ update ( 0 , 0 , size - 1 , l , r , x ); } }; int main () { SegTree st ( 10 ); st . update ( 0 , 4 , 1 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 0 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 5 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 0 st . update ( 5 , 9 , 2 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 10 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 15 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 2 st . update ( 0 , 9 , 1 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 5 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 10 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 1 st . update ( 5 , 20 ); cout << st . query ( 0 , 4 ) << \" \\n \" ; // 5 cout << st . query ( 5 , 9 ) << \" \\n \" ; // 24 cout << st . query ( 0 , 9 ) << \" \\n \" ; // 29 cout << st . query ( 0 , 0 ) << \" \\n \" ; // 1 cout << st . query ( 5 , 5 ) << \" \\n \" ; // 20 return 0 ; }","title":"Atualiza\u00e7\u00f5es em Intervalos (Lazy Propagation)"},{"location":"ed2/#material-complementar_1","text":"\u2b50\ufe0f Segment Tree, part 1 (ITMO Academy) \ud83e\udd2f \u2b50\ufe0f Segment Tree, part 2 (ITMO Academy) \ud83e\udd2f \u2b50\ufe0f Segment Tree \u2b50\ufe0f Segment Tree (\u00c1rvore de Segmentos) \u2b50\ufe0f Segment Tree com Lazy Propagation Segment Tree (CS Academy) Segment Trees Segment Tree - VisuAlgo Segment Tree Data Structure - Min Max Queries","title":"Material complementar"},{"location":"ed2/#disjoint-set-union-dsu","text":"Para entender DSU, considere o seguinte problema (extra\u00eddo desse link ): suponha que exista um grupo de \\(N\\) amigos em um jogo. Inicialmente, cada um deles joga contra todos os outros. Conforme o jogo avan\u00e7a, alian\u00e7as s\u00e3o formadas entre eles. A rela\u00e7\u00e3o de alian\u00e7a \u00e9 transitiva, o que significa que se \\(A\\) e \\(B\\) s\u00e3o aliados e \\(B\\) e \\(C\\) s\u00e3o aliados, ent\u00e3o \\(A\\) e \\(C\\) tamb\u00e9m s\u00e3o aliados. Voc\u00ea sabe quando as alian\u00e7as s\u00e3o formadas. Em certos momentos voc\u00ea precisa saber se dois amigos em particular est\u00e3o no mesmo time ou n\u00e3o. Uma estrat\u00e9gia natural seria construir um grafo e, a cada atualiza\u00e7\u00e3o, incluir uma nova aresta ligando dois vertices do grafo. Para cada consulta pode-se realizar um percurso no grafo (usando Busca em Largura ou Busca em Profundidade ) come\u00e7ando no n\u00f3 \\(A\\) e verificando se o n\u00f3 \\(B\\) \u00e9 visitado. Adicionar uma aresta \u00e9 muito r\u00e1pido, mas as consultas s\u00e3o lentas. Uma estrat\u00e9gia mais eficiente para resolver esse problema \u00e9 usar Disjoint Set Union . Um conjunto disjunto , tamb\u00e9m chamado union-find , \u00e9 uma estrutura de dados que opera com um conjunto particionado em v\u00e1rios subconjuntos disjuntos. As duas principais opera\u00e7\u00f5es dessa estrutura s\u00e3o: find : Dado um elemento particular do conjunto, a fun\u00e7\u00e3o identifica o subconjunto do elemento. Para isso, a fun\u00e7\u00e3o retorna o representante do conjunto. join : Une dois subconjuntos em um \u00fanico subconjunto. Um conjunto disjunto funciona representando cada componente conectado como uma \u00e1rvore, onde a raiz de cada \u00e1rvore \u00e9 o representante do componente. O pai de cada n\u00f3 \u00e9 outro n\u00f3 no mesmo componente. Considere o exemplo dos amigos jogando para ver como a estrutura funciona. Suponha que existam 6 amigos jogando. Inicialmente, n\u00e3o h\u00e1 alian\u00e7as, ent\u00e3o cada n\u00f3 \u00e9 a raiz de uma \u00e1rvore (os amigos s\u00e3o numerados de 0 a 5): 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Em seguida, suponha que 1 e 3 se tornem aliados. Considere que o n\u00f3 1 seja escolhido como representante: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Ent\u00e3o 2 e 4 se tornam aliados: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Os amigos 0 e 5 s\u00e3o os pr\u00f3ximos. Considere que 5 seja escolhido como representante: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures Finalmente, uma alian\u00e7a \u00e9 formada entre 4 e 3. Nesse caso, \u00e9 preciso pegar a raiz de uma \u00e1rvore e anex\u00e1-la como filho da raiz da outra \u00e1rvore: 0 1 2 3 4 5 Fonte: Disjoint-set Data Structures","title":"Disjoint Set Union (DSU)"},{"location":"ed2/#implementacao_2","text":"A estrutura DSU pode ser implementada usando arrays. Na implementa\u00e7\u00e3o a seguir, o array pai cont\u00e9m para cada elemento o pr\u00f3ximo elemento do encadeamento ou o pr\u00f3prio elemento se ele for um representante. Inicialmente, cada elemento pertence a um conjunto distinto: 1 2 3 4 5 6 vll pai ; void init ( ll N ) { pai . resize ( N + 1 ); iota ( pai . begin (), pai . end (), 0 ); // (1) } std:iota A fun\u00e7\u00e3o find retorna o representante do elemento x . O representante pode ser encontrado seguindo o encadeamento que come\u00e7a em x . O c\u00f3digo abaixo ilustra essa opera\u00e7\u00e3o, note que a complexidade da fun\u00e7\u00e3o \u00e9 \\(O(n)\\) : 1 2 3 4 5 6 ll find ( ll x ) { if ( x == pai [ x ]) return x ; else return find ( pai [ x ]); } 1 2 3 void join ( ll a , ll b ) { pai [ find ( a )] = find ( b ); }","title":"Implementa\u00e7\u00e3o"},{"location":"ed2/#otimizacoes-do-union-find","text":"A primeira otimiza\u00e7\u00e3o do algoritmo, conhecida como Path Compression , est\u00e1 na busca do representante de um elemento, ou seja, na fun\u00e7\u00e3o find . Observe que se a fun\u00e7\u00e3o find for eficiente, a fun\u00e7\u00e3o join tamb\u00e9m se torna eficiente. Note que o que gasta tempo na fun\u00e7\u00e3o s\u00e3o as chamadas recursivas da fun\u00e7\u00e3o que precisam passar por todos os ancestrais de um determinado elemento. Por\u00e9m, pode-se usar um princ\u00edpio da Programa\u00e7\u00e3o Din\u00e2mica: evitar o rec\u00e1lculo! Uma vez que calculado o representante de um elemento x (ou seja, find(x) ), pode-se salv\u00e1-lo diretamente como seu pai ( pai[x]=find(x); ). Assim, nas pr\u00f3ximas vezes que for calculado o valor de find(x) , a fun\u00e7\u00e3o retornar\u00e1 seu representante rapidamente, pois ele j\u00e1 estar\u00e1 salvo em pai[x] , o que evita a necessidade de percorrer todos os ancestrais que estavam entre x e o representante. Para fazer essa otimiza\u00e7\u00e3o basta que, na hora de o valor de find(x) for retornado, o mesmo seja salvo em pai[x] . Segue a implementa\u00e7\u00e3o da fun\u00e7\u00e3o find otimizada: 1 2 3 4 5 6 ll find ( ll x ) { if ( x == pai [ x ]) return x ; else return pai [ x ] = find ( pai [ x ]); } Outra otimiza\u00e7ao, conhecida como Union by size , altera a forma como \u00e9 feita a uni\u00e3o dos conjuntos. Na primeira implementa\u00e7\u00e3o da fun\u00e7\u00e3o join , o segundo conjunto sempre \u00e9 anexado ao primeiro, o que pode levar a \u00e1rvores degeneradas. Nessa otimiza\u00e7\u00e3o, o menor conjunto (menor n\u00famero de elementos) \u00e9 unido ao maior conjunto. Segue a implementa\u00e7\u00e3o da fun\u00e7\u00e3o join otimizada: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 vll pai ; vll tamanho ; void init ( ll N ) { pai . resize ( N + 1 ); tamanho . resize ( N + 1 , 1 ); iota ( pai . begin (), pai . end (), 0 ); } void join ( ll a , ll b ) { a = find ( a ); b = find ( b ); if ( a != b ) { if ( tamanho [ a ] < tamanho [ b ]) swap ( a , b ); pai [ b ] = a ; tamanho [ a ] += tamanho [ b ]; } }","title":"Otimiza\u00e7\u00f5es do Union-Find"},{"location":"ed2/#material-complementar_2","text":"\u2b50\ufe0f Disjoint Sets Union \ud83e\udd2f \u2b50\ufe0f Disjoint Set Union \u2b50\ufe0f Union-Find (Neps Academy) Disjoint-set Data Structures (CSAcademy) Disjoint Set Data Structures (GeeksforGeeks)","title":"Material complementar"},{"location":"gc/","text":"Geometria Computacional 1 A Geometria Computacional \u00e9 mais um t\u00f3pico que aparece com frequ\u00eancia em programa\u00e7\u00e3o competitiva. Por exemplo, calcular a \u00e1rea de um pol\u00edgo; verificar se um determinado ponto est\u00e1 dentro ou fora de um pol\u00edgono; verificar se existe interse\u00e7\u00e3o entre dois segmentos de reta; etc. Assim, nesta se\u00e7\u00e3o, ser\u00e3o apresentados alguns algoritmos e estrat\u00e9gias para responder essas e outras perguntas. Leituras e aulas fortemente recomendadas: \u2b50\ufe0f Geometria (Summer School 2020) \u2b50\ufe0f Introdu\u00e7\u00e3o \u00e0 Geometria Computacional (Unesp) Geometry Cap\u00edtulo 7 do livro \"Competitive Programming\" Cap\u00edtulo 29 do livro \"Competitive Programmer\u2019s Handbook\" Basic Geometry Pontos O objeto mais simples em geometr\u00eda computacional \u00e9 o Ponto . No espa\u00e7o Euclidiano 2D, pontos normalmente s\u00e3o representados usando struct em C/C++ com dois membros: as coordenadas \\(x\\) e \\(y\\) . Sempre que poss\u00edvel use coordenadas inteiras ( long long ), caso contr\u00e1rio use double . O c\u00f3digo abaixo ilustra um struct considerando coordenadas reais e algumas fun\u00e7\u00f5es \u00fateis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #define EPS 1e-9 #define DEG2RAD(d) (d)*M_PI / 180.0 #define RAD2DEG(r) (r)*180.0 / M_PI struct Ponto { double x , y ; Ponto ( double _x = 0 , double _y = 0 ) : x ( _x ), y ( _y ){} Ponto operator + ( const Ponto & p ) const { return Ponto ( x + p . x , y + p . y ); } Ponto operator - ( const Ponto & p ) const { return Ponto ( x - p . x , y - p . y ); } Ponto operator * ( double k ) const { return Ponto ( x * k , y * k ); } bool operator < ( const Ponto & p ) const { if ( fabs ( x - p . x ) > EPS ) return x < p . x ; return y < p . y ; } bool operator == ( const Ponto & p ) const { return ( fabs ( x - p . x ) < EPS ) && ( fabs ( y - p . y ) < EPS ); } double norma () { return hypot ( x , y ); // (1) } Ponto normaliza () { return Ponto ( x , y ) * ( 1.0 / norma ()); } double angulo () { return atan2 ( y , x ); } double anguloPolar () { double a = atan2 ( y , x ); return a < 0 ? a + 2 * acos ( -1.0 ) : a ; } }; double distancia ( const Ponto & p1 , const Ponto & p2 ) { return hypot ( p1 . x - p2 . x , p1 . y - p2 . y ); } // Rataciona o ponto 'p' em 'theta' graus no sentido // hor\u00e1rio (counter clockwise - CCW) em torno da origem (0, 0) Ponto rotaciona ( const Ponto & p , double theta ) { double rad = DEG2RAD ( theta ); return Ponto ( p . x * cos ( rad ) - p . y * sin ( rad ), p . x * sin ( rad ) + p . y * cos ( rad )); } // Retorna o produto interno de 'p1' e 'p2' double inner ( const Ponto & p1 , const Ponto & p2 ) { return p1 . x * p2 . x + p1 . y * p2 . y ; } // Retorna o produto vetorial de 'p1' e 'p2' double cross ( const Ponto & p1 , const Ponto & p2 ) { return p1 . x * p2 . y - p1 . y * p2 . x ; } // Verifica se o ponto 'r' est\u00e1 no lado esquerdo da linha 'pq' bool ccw ( const Ponto & p , const Ponto & q , const Ponto & r ) { return cross ( q - p , r - p ) > 0 ; } // Verifica se o ponto 'r' est\u00e1 na mesma linha que a linha 'pq' bool colinear ( const Ponto & p , const Ponto & q , const Ponto & r ) { return fabs ( cross ( p - q , r - p )) < EPS ; } hypot ( x , y ) retorna sqrt ( x * x + y * y ) . Para saber mais clique aqui . Linhas Uma Linha no espa\u00e7o euclidiano 2D \u00e9 o conjunto de pontos cujas coordenadas satisfazem uma dada equa\u00e7\u00e3o linear \\(ax + by + c = 0\\) . Linhas s\u00e3o normalmente representadas com um struct em C/C++ com tr\u00eas membros: os tr\u00eas coeficientes \\(a\\) , \\(b\\) e \\(c\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct Linha { double a , b , c ; Linha ( double _a = NAN , double _b = NAN , double _c = NAN ) : a ( _a ), b ( _b ), c ( _c ) {} }; Linha pontosParaLinha ( const Ponto & p1 , const Ponto & p2 ) { if ( fabs ( p1 . x - p2 . x ) < EPS && fabs ( p1 . y - p2 . y ) < EPS ) return Linha (); else if ( fabs ( p1 . x - p2 . x ) < EPS ) return Linha ( 1.0 , 0.0 , - p1 . x ); else { double a = - ( p1 . y - p2 . y ) / ( p1 . x - p2 . x ); double b = 1.0 ; double c = - ( a * p1 . x ) - p1 . y ; return Linha ( a , b , c ); } } bool saoParalelas ( const Linha & l1 , const Linha & l2 ) { return ( fabs ( l1 . a - l2 . a ) < EPS ) && ( fabs ( l1 . b - l2 . b ) < EPS ); } bool saoIguais ( const Linha & l1 , const Linha & l2 ) { return saoParalelas ( l1 , l2 ) && ( fabs ( l1 . c - l2 . c ) < EPS ); } // Verifica se h\u00e1 interse\u00e7\u00e3o entre as linhas 'l1' e 'l2'. // Se houver, salva o ponto de interse\u00e7\u00e3o em 'p'. bool intersecao ( const Linha & l1 , const Linha & l2 , Ponto & p ) { if ( saoParalelas ( l1 , l2 )) return false ; p . x = ( l2 . b * l1 . c - l1 . b * l2 . c ) / ( l2 . a * l1 . b - l1 . a * l2 . b ); if ( fabs ( l1 . b ) > EPS ) p . y = - ( l1 . a * p . x + l1 . c ); else p . y = - ( l2 . a * p . x + l2 . c ); return true ; } Um segmento de linha \u00e9 uma linha de tamanho finito limitado por dois pontos. J\u00e1 um vetor \u00e9 um segmento de linha com uma dire\u00e7\u00e3o. Normalmente, um vetor \u00e9 representado por um struct em C/C++ com dois membros: a magnitude \\(x\\) e \\(y\\) do vetor. Se necess\u00e1rio o vetor pode ser escalado e movido. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 struct Vetor { double x , y ; Vetor ( double _x = NAN , double _y = NAN ) : x ( _x ), y ( _y ){} }; // Converte dois pontos no vetor a->b Vetor paraVetor ( const Ponto & a , const Ponto & b ) { return Vetor ( b . x - a . x , b . y - a . y ); } Vetor scale ( const Vetor & v , double s ) { return Vetor ( v . x * s , v . y * s ); } // Move 'p' de acordo com 'v' e retorna um novo ponto Ponto translate ( const Ponto & p , const Vetor & v ) { return Ponto ( p . x + v . x , p . y + v . y ); } // Retorna o produto vetorial dos vetores 'a' e 'b' double cross ( const Vetor & a , const Vetor & b ) { return a . x * b . y - a . y * b . x ; } // Retorna o produto escalar dos vetores 'a' e 'b' double dot ( const Vetor & a , const Vetor & b ) { return ( a . x * b . x + a . y * b . y ); } // Retorna o valor ao quadrado do vetor normalizado double norm_sq ( const Vetor & v ) { return v . x * v . x + v . y * v . y ; } // Retorna a dist\u00e2ncia de 'p' at\u00e9 a linha definida pelos pontos 'a' e 'b'. // O ponto mais pr\u00f3ximo \u00e9 armazenado no par\u00e2metro 'c'. double distToLine ( const Ponto & p , const Ponto & a , const Ponto & b , Ponto & c ) { vec ap = paraVetor ( a , p ), ab = paraVetor ( a , b ); double u = dot ( ap , ab ) / norm_sq ( ab ); // Formula: c = a + u*ab c = translate ( a , scale ( ab , u )); return distancia ( p , c ); } // Retorna a dist\u00e2ncia de 'p' ao segmento de linha 'ab' definido pelos pontos 'a' e 'b'. // O ponto mais pr\u00f3ximo \u00e9 armazenado no par\u00e2metro 'c'. double distToLineSegment ( const Ponto & p , const Ponto & a , const Ponto & b , Ponto & c ) { vec ap = paraVetor ( a , p ), ab = paraVetor ( a , b ); double u = dot ( ap , ab ) / norm_sq ( ab ); if ( u < 0.0 ) { c = Ponto ( a . x , a . y ); return dist ( p , a ); } if ( u > 1.0 ) { c = Ponto ( b . x , b . y ); return dist ( p , b ); } return distToLine ( p , a , b , c ); } C\u00edrculos Leia o conte\u00fado da se\u00e7\u00e3o 7.2.3 deste livro . Tri\u00e2ngulos Leia o conte\u00fado da se\u00e7\u00e3o 7.2.4 deste livro . Quadril\u00e1teros Leia o conte\u00fado da se\u00e7\u00e3o 7.2.5 deste livro . Pol\u00edgonos Em constru\u00e7\u00e3o... Fecho Convexo (Convex Hull) Em constru\u00e7\u00e3o... Material Complementar Al\u00e9m dos links recomendados no \u00ednicio dessa se\u00e7\u00e3o, os links abaixo complementam o seu conhecimento pelo assunto. Geometria Computacional (IME-USP) Geometric Routines (Igor's Code Archive) Geometry: 2D points and lines [Tutorial] Geometric Algorithms (GeeksforGeeks) Handbook of geometry for competitive programmers Os textos dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados nesses links: 1 e 2 \u21a9","title":"Geometria Computacional"},{"location":"gc/#geometria-computacional1","text":"A Geometria Computacional \u00e9 mais um t\u00f3pico que aparece com frequ\u00eancia em programa\u00e7\u00e3o competitiva. Por exemplo, calcular a \u00e1rea de um pol\u00edgo; verificar se um determinado ponto est\u00e1 dentro ou fora de um pol\u00edgono; verificar se existe interse\u00e7\u00e3o entre dois segmentos de reta; etc. Assim, nesta se\u00e7\u00e3o, ser\u00e3o apresentados alguns algoritmos e estrat\u00e9gias para responder essas e outras perguntas. Leituras e aulas fortemente recomendadas: \u2b50\ufe0f Geometria (Summer School 2020) \u2b50\ufe0f Introdu\u00e7\u00e3o \u00e0 Geometria Computacional (Unesp) Geometry Cap\u00edtulo 7 do livro \"Competitive Programming\" Cap\u00edtulo 29 do livro \"Competitive Programmer\u2019s Handbook\" Basic Geometry","title":"Geometria Computacional1"},{"location":"gc/#pontos","text":"O objeto mais simples em geometr\u00eda computacional \u00e9 o Ponto . No espa\u00e7o Euclidiano 2D, pontos normalmente s\u00e3o representados usando struct em C/C++ com dois membros: as coordenadas \\(x\\) e \\(y\\) . Sempre que poss\u00edvel use coordenadas inteiras ( long long ), caso contr\u00e1rio use double . O c\u00f3digo abaixo ilustra um struct considerando coordenadas reais e algumas fun\u00e7\u00f5es \u00fateis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #define EPS 1e-9 #define DEG2RAD(d) (d)*M_PI / 180.0 #define RAD2DEG(r) (r)*180.0 / M_PI struct Ponto { double x , y ; Ponto ( double _x = 0 , double _y = 0 ) : x ( _x ), y ( _y ){} Ponto operator + ( const Ponto & p ) const { return Ponto ( x + p . x , y + p . y ); } Ponto operator - ( const Ponto & p ) const { return Ponto ( x - p . x , y - p . y ); } Ponto operator * ( double k ) const { return Ponto ( x * k , y * k ); } bool operator < ( const Ponto & p ) const { if ( fabs ( x - p . x ) > EPS ) return x < p . x ; return y < p . y ; } bool operator == ( const Ponto & p ) const { return ( fabs ( x - p . x ) < EPS ) && ( fabs ( y - p . y ) < EPS ); } double norma () { return hypot ( x , y ); // (1) } Ponto normaliza () { return Ponto ( x , y ) * ( 1.0 / norma ()); } double angulo () { return atan2 ( y , x ); } double anguloPolar () { double a = atan2 ( y , x ); return a < 0 ? a + 2 * acos ( -1.0 ) : a ; } }; double distancia ( const Ponto & p1 , const Ponto & p2 ) { return hypot ( p1 . x - p2 . x , p1 . y - p2 . y ); } // Rataciona o ponto 'p' em 'theta' graus no sentido // hor\u00e1rio (counter clockwise - CCW) em torno da origem (0, 0) Ponto rotaciona ( const Ponto & p , double theta ) { double rad = DEG2RAD ( theta ); return Ponto ( p . x * cos ( rad ) - p . y * sin ( rad ), p . x * sin ( rad ) + p . y * cos ( rad )); } // Retorna o produto interno de 'p1' e 'p2' double inner ( const Ponto & p1 , const Ponto & p2 ) { return p1 . x * p2 . x + p1 . y * p2 . y ; } // Retorna o produto vetorial de 'p1' e 'p2' double cross ( const Ponto & p1 , const Ponto & p2 ) { return p1 . x * p2 . y - p1 . y * p2 . x ; } // Verifica se o ponto 'r' est\u00e1 no lado esquerdo da linha 'pq' bool ccw ( const Ponto & p , const Ponto & q , const Ponto & r ) { return cross ( q - p , r - p ) > 0 ; } // Verifica se o ponto 'r' est\u00e1 na mesma linha que a linha 'pq' bool colinear ( const Ponto & p , const Ponto & q , const Ponto & r ) { return fabs ( cross ( p - q , r - p )) < EPS ; } hypot ( x , y ) retorna sqrt ( x * x + y * y ) . Para saber mais clique aqui .","title":"Pontos"},{"location":"gc/#linhas","text":"Uma Linha no espa\u00e7o euclidiano 2D \u00e9 o conjunto de pontos cujas coordenadas satisfazem uma dada equa\u00e7\u00e3o linear \\(ax + by + c = 0\\) . Linhas s\u00e3o normalmente representadas com um struct em C/C++ com tr\u00eas membros: os tr\u00eas coeficientes \\(a\\) , \\(b\\) e \\(c\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct Linha { double a , b , c ; Linha ( double _a = NAN , double _b = NAN , double _c = NAN ) : a ( _a ), b ( _b ), c ( _c ) {} }; Linha pontosParaLinha ( const Ponto & p1 , const Ponto & p2 ) { if ( fabs ( p1 . x - p2 . x ) < EPS && fabs ( p1 . y - p2 . y ) < EPS ) return Linha (); else if ( fabs ( p1 . x - p2 . x ) < EPS ) return Linha ( 1.0 , 0.0 , - p1 . x ); else { double a = - ( p1 . y - p2 . y ) / ( p1 . x - p2 . x ); double b = 1.0 ; double c = - ( a * p1 . x ) - p1 . y ; return Linha ( a , b , c ); } } bool saoParalelas ( const Linha & l1 , const Linha & l2 ) { return ( fabs ( l1 . a - l2 . a ) < EPS ) && ( fabs ( l1 . b - l2 . b ) < EPS ); } bool saoIguais ( const Linha & l1 , const Linha & l2 ) { return saoParalelas ( l1 , l2 ) && ( fabs ( l1 . c - l2 . c ) < EPS ); } // Verifica se h\u00e1 interse\u00e7\u00e3o entre as linhas 'l1' e 'l2'. // Se houver, salva o ponto de interse\u00e7\u00e3o em 'p'. bool intersecao ( const Linha & l1 , const Linha & l2 , Ponto & p ) { if ( saoParalelas ( l1 , l2 )) return false ; p . x = ( l2 . b * l1 . c - l1 . b * l2 . c ) / ( l2 . a * l1 . b - l1 . a * l2 . b ); if ( fabs ( l1 . b ) > EPS ) p . y = - ( l1 . a * p . x + l1 . c ); else p . y = - ( l2 . a * p . x + l2 . c ); return true ; } Um segmento de linha \u00e9 uma linha de tamanho finito limitado por dois pontos. J\u00e1 um vetor \u00e9 um segmento de linha com uma dire\u00e7\u00e3o. Normalmente, um vetor \u00e9 representado por um struct em C/C++ com dois membros: a magnitude \\(x\\) e \\(y\\) do vetor. Se necess\u00e1rio o vetor pode ser escalado e movido. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 struct Vetor { double x , y ; Vetor ( double _x = NAN , double _y = NAN ) : x ( _x ), y ( _y ){} }; // Converte dois pontos no vetor a->b Vetor paraVetor ( const Ponto & a , const Ponto & b ) { return Vetor ( b . x - a . x , b . y - a . y ); } Vetor scale ( const Vetor & v , double s ) { return Vetor ( v . x * s , v . y * s ); } // Move 'p' de acordo com 'v' e retorna um novo ponto Ponto translate ( const Ponto & p , const Vetor & v ) { return Ponto ( p . x + v . x , p . y + v . y ); } // Retorna o produto vetorial dos vetores 'a' e 'b' double cross ( const Vetor & a , const Vetor & b ) { return a . x * b . y - a . y * b . x ; } // Retorna o produto escalar dos vetores 'a' e 'b' double dot ( const Vetor & a , const Vetor & b ) { return ( a . x * b . x + a . y * b . y ); } // Retorna o valor ao quadrado do vetor normalizado double norm_sq ( const Vetor & v ) { return v . x * v . x + v . y * v . y ; } // Retorna a dist\u00e2ncia de 'p' at\u00e9 a linha definida pelos pontos 'a' e 'b'. // O ponto mais pr\u00f3ximo \u00e9 armazenado no par\u00e2metro 'c'. double distToLine ( const Ponto & p , const Ponto & a , const Ponto & b , Ponto & c ) { vec ap = paraVetor ( a , p ), ab = paraVetor ( a , b ); double u = dot ( ap , ab ) / norm_sq ( ab ); // Formula: c = a + u*ab c = translate ( a , scale ( ab , u )); return distancia ( p , c ); } // Retorna a dist\u00e2ncia de 'p' ao segmento de linha 'ab' definido pelos pontos 'a' e 'b'. // O ponto mais pr\u00f3ximo \u00e9 armazenado no par\u00e2metro 'c'. double distToLineSegment ( const Ponto & p , const Ponto & a , const Ponto & b , Ponto & c ) { vec ap = paraVetor ( a , p ), ab = paraVetor ( a , b ); double u = dot ( ap , ab ) / norm_sq ( ab ); if ( u < 0.0 ) { c = Ponto ( a . x , a . y ); return dist ( p , a ); } if ( u > 1.0 ) { c = Ponto ( b . x , b . y ); return dist ( p , b ); } return distToLine ( p , a , b , c ); }","title":"Linhas"},{"location":"gc/#circulos","text":"Leia o conte\u00fado da se\u00e7\u00e3o 7.2.3 deste livro .","title":"C\u00edrculos"},{"location":"gc/#triangulos","text":"Leia o conte\u00fado da se\u00e7\u00e3o 7.2.4 deste livro .","title":"Tri\u00e2ngulos"},{"location":"gc/#quadrilateros","text":"Leia o conte\u00fado da se\u00e7\u00e3o 7.2.5 deste livro .","title":"Quadril\u00e1teros"},{"location":"gc/#poligonos","text":"Em constru\u00e7\u00e3o...","title":"Pol\u00edgonos"},{"location":"gc/#fecho-convexo-convex-hull","text":"Em constru\u00e7\u00e3o...","title":"Fecho Convexo (Convex Hull)"},{"location":"gc/#material-complementar","text":"Al\u00e9m dos links recomendados no \u00ednicio dessa se\u00e7\u00e3o, os links abaixo complementam o seu conhecimento pelo assunto. Geometria Computacional (IME-USP) Geometric Routines (Igor's Code Archive) Geometry: 2D points and lines [Tutorial] Geometric Algorithms (GeeksforGeeks) Handbook of geometry for competitive programmers Os textos dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados nesses links: 1 e 2 \u21a9","title":"Material Complementar"},{"location":"grafos/","text":"Grafos Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"grafos/#grafos","text":"Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"guloso%20%28c%C3%B3pia%29/","text":"Algoritmos Gulosos 1 Um algoritmo \u00e9 dito guloso se, em cada passo, ele faz uma escolha localmente \u00f3tima na esperan\u00e7a de que essa escolha leve a uma solu\u00e7\u00e3o globalmente \u00f3tima. Um algoritmo guloso nunca retoma suas escolhas, de forma a construir diretamente a solu\u00e7\u00e3o final. Por esta raz\u00e3o, algoritmos gulosos s\u00e3o geralmente muito eficientes. Por exemplo, uma maneira natural de se calcular o menor caminho entre os vertices \\(x\\) e \\(y\\) de um grafo pode ser sair de \\(x\\) e, repetidamente, seguir a aresta mais barata at\u00e9 se alcan\u00e7ar o vertice \\(y\\) . Natural, mas errada! A maior dificuldade em projetar um algoritmo guloso \u00e9 encontrar uma estrat\u00e9gia gulosa que sempre produza uma solu\u00e7\u00e3o \u00f3tima para o problema, uma vez que as escolhas localmente \u00f3timas tamb\u00e9m devem ser globalmente \u00f3timas. Muitas vezes \u00e9 dif\u00edcil provar que um algoritmo guloso funciona. Ent\u00e3o, como saber se um algoritmo guloso resolver\u00e1 determinando problema? De forma simplificada, um algoritmo guloso deve possuir dois componentes fundamentais: Propriedade de escolha gulosa Uma solu\u00e7\u00e3o globalmente \u00f3tima \u00e9 construida fazendo escolhas (gulosas) locais \u00f3tima. Em outras palavras, quando o algoritmo est\u00e1 considerando qual escolha fazer, ele escolhe a que parece melhor para o problema em quest\u00e3o, sem considerar resultados dos subproblemas e sem reconsiderar as escolhas anteriores. Subestrutura \u00f3tima Solu\u00e7\u00e3o \u00f3tima do problema cont\u00e9m solu\u00e7\u00f5es \u00f3timas dos subproblemas. Como voc\u00ea deve ter percebido, algoritmo guloso n\u00e3o se refere a um \u00fanico algoritmo, mas sim a uma forma de pensar que se aplica aos problemas, ou seja, n\u00e3o h\u00e1 uma (\u00fanica) maneira de fazer algoritmos gulos. Por isso, segue uma sele\u00e7\u00e3o de exemplos bem conhecidos para ajud\u00e1-lo a entender o paradigma guloso. Exemplos Estudando algoritmos Considere o problema onde voc\u00ea deseja estudar um determinado assunto, por exemplo, diferentes algoritmos e voc\u00ea possui \\(X\\) ( \\(1 \\leq X \\leq 10^4\\) ) minutos para se dedicar ao aprendizado. Existem \\(N\\) ( \\(1 \\leq N \\leq 100\\) ) algoritmos e cada um requer \\(a_i\\) ( \\(1 \\leq a_i \\leq 100\\) ) minutos de dedica\u00e7\u00e3o. Qual o n\u00famero m\u00e1ximo de algoritmos que voc\u00ea pode/consegue aprender? Solu\u00e7\u00e3o Como voc\u00ea deseja aprender o n\u00famero m\u00e1ximo de algoritmos, voc\u00ea deve priorizar os algoritmos de aprendizado do mais f\u00e1cil aos mais dif\u00edcil, ou seja, comece aprendendo o algoritmo que requer a menor quantidade de tempo e, em seguida, escolha outros algoritmos em ordem crescente de tempo necess\u00e1rio. Por exemplo, considere a seguinte entrada: \\[ X = 15, N = 6, a_i = \\{4, 3, 8, 4, 7, 3\\} \\] Depois de ordenar o array, temos \\(\\{ 3, 3, 4, 4, 7, 8 \\}\\) . Assim, dentro dos 15 minutos voc\u00ea pode aprender quatro algoritmos em um total de \\(3+3+4+4 = 14\\) minutos. C++ Python 1 1 Festival de Cinema Problema da mochila fracion\u00e1ria Troco - vers\u00e3o gulosa Escalonamento Quando o guloso falha? Como j\u00e1 dito, nem sempre um algoritmo guloso ir\u00e1 funcionar. Por isso, seguem dois exemplos de problemas em que ele falha. Problema do troco Problema da mochila 0-1 O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 e 4 \u21a9","title":"Algoritmos Gulosos[^1]"},{"location":"guloso%20%28c%C3%B3pia%29/#algoritmos-gulosos1","text":"Um algoritmo \u00e9 dito guloso se, em cada passo, ele faz uma escolha localmente \u00f3tima na esperan\u00e7a de que essa escolha leve a uma solu\u00e7\u00e3o globalmente \u00f3tima. Um algoritmo guloso nunca retoma suas escolhas, de forma a construir diretamente a solu\u00e7\u00e3o final. Por esta raz\u00e3o, algoritmos gulosos s\u00e3o geralmente muito eficientes. Por exemplo, uma maneira natural de se calcular o menor caminho entre os vertices \\(x\\) e \\(y\\) de um grafo pode ser sair de \\(x\\) e, repetidamente, seguir a aresta mais barata at\u00e9 se alcan\u00e7ar o vertice \\(y\\) . Natural, mas errada! A maior dificuldade em projetar um algoritmo guloso \u00e9 encontrar uma estrat\u00e9gia gulosa que sempre produza uma solu\u00e7\u00e3o \u00f3tima para o problema, uma vez que as escolhas localmente \u00f3timas tamb\u00e9m devem ser globalmente \u00f3timas. Muitas vezes \u00e9 dif\u00edcil provar que um algoritmo guloso funciona. Ent\u00e3o, como saber se um algoritmo guloso resolver\u00e1 determinando problema? De forma simplificada, um algoritmo guloso deve possuir dois componentes fundamentais: Propriedade de escolha gulosa Uma solu\u00e7\u00e3o globalmente \u00f3tima \u00e9 construida fazendo escolhas (gulosas) locais \u00f3tima. Em outras palavras, quando o algoritmo est\u00e1 considerando qual escolha fazer, ele escolhe a que parece melhor para o problema em quest\u00e3o, sem considerar resultados dos subproblemas e sem reconsiderar as escolhas anteriores. Subestrutura \u00f3tima Solu\u00e7\u00e3o \u00f3tima do problema cont\u00e9m solu\u00e7\u00f5es \u00f3timas dos subproblemas. Como voc\u00ea deve ter percebido, algoritmo guloso n\u00e3o se refere a um \u00fanico algoritmo, mas sim a uma forma de pensar que se aplica aos problemas, ou seja, n\u00e3o h\u00e1 uma (\u00fanica) maneira de fazer algoritmos gulos. Por isso, segue uma sele\u00e7\u00e3o de exemplos bem conhecidos para ajud\u00e1-lo a entender o paradigma guloso.","title":"Algoritmos Gulosos1"},{"location":"guloso%20%28c%C3%B3pia%29/#exemplos","text":"","title":"Exemplos"},{"location":"guloso%20%28c%C3%B3pia%29/#estudando-algoritmos","text":"Considere o problema onde voc\u00ea deseja estudar um determinado assunto, por exemplo, diferentes algoritmos e voc\u00ea possui \\(X\\) ( \\(1 \\leq X \\leq 10^4\\) ) minutos para se dedicar ao aprendizado. Existem \\(N\\) ( \\(1 \\leq N \\leq 100\\) ) algoritmos e cada um requer \\(a_i\\) ( \\(1 \\leq a_i \\leq 100\\) ) minutos de dedica\u00e7\u00e3o. Qual o n\u00famero m\u00e1ximo de algoritmos que voc\u00ea pode/consegue aprender? Solu\u00e7\u00e3o Como voc\u00ea deseja aprender o n\u00famero m\u00e1ximo de algoritmos, voc\u00ea deve priorizar os algoritmos de aprendizado do mais f\u00e1cil aos mais dif\u00edcil, ou seja, comece aprendendo o algoritmo que requer a menor quantidade de tempo e, em seguida, escolha outros algoritmos em ordem crescente de tempo necess\u00e1rio. Por exemplo, considere a seguinte entrada: \\[ X = 15, N = 6, a_i = \\{4, 3, 8, 4, 7, 3\\} \\] Depois de ordenar o array, temos \\(\\{ 3, 3, 4, 4, 7, 8 \\}\\) . Assim, dentro dos 15 minutos voc\u00ea pode aprender quatro algoritmos em um total de \\(3+3+4+4 = 14\\) minutos. C++ Python 1 1","title":"Estudando algoritmos"},{"location":"guloso%20%28c%C3%B3pia%29/#festival-de-cinema","text":"","title":"Festival de Cinema"},{"location":"guloso%20%28c%C3%B3pia%29/#problema-da-mochila-fracionaria","text":"","title":"Problema da mochila fracion\u00e1ria"},{"location":"guloso%20%28c%C3%B3pia%29/#troco-versao-gulosa","text":"","title":"Troco - vers\u00e3o gulosa"},{"location":"guloso%20%28c%C3%B3pia%29/#escalonamento","text":"","title":"Escalonamento"},{"location":"guloso%20%28c%C3%B3pia%29/#quando-o-guloso-falha","text":"Como j\u00e1 dito, nem sempre um algoritmo guloso ir\u00e1 funcionar. Por isso, seguem dois exemplos de problemas em que ele falha. Problema do troco Problema da mochila 0-1 O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 e 4 \u21a9","title":"Quando o guloso falha?"},{"location":"guloso/","text":"Algoritmos Gulosos 1 Um algoritmo \u00e9 dito guloso se, em cada passo, ele faz uma escolha localmente \u00f3tima na esperan\u00e7a de que essa escolha leve a uma solu\u00e7\u00e3o globalmente \u00f3tima. Um algoritmo guloso nunca retoma suas escolhas, de forma a construir diretamente a solu\u00e7\u00e3o final. Por esta raz\u00e3o, algoritmos gulosos s\u00e3o geralmente muito eficientes. Por exemplo, uma maneira natural de se calcular o menor caminho entre os v\u00e9rtices \\(x\\) e \\(y\\) de um grafo pode ser sair de \\(x\\) e, repetidamente, seguir a aresta mais barata at\u00e9 se alcan\u00e7ar o v\u00e9rtice \\(y\\) . Natural, mas errada! A maior dificuldade em projetar um algoritmo guloso \u00e9 encontrar uma estrat\u00e9gia gulosa que sempre produza uma solu\u00e7\u00e3o \u00f3tima para o problema, uma vez que as escolhas localmente \u00f3timas tamb\u00e9m devem ser globalmente \u00f3timas. Muitas vezes \u00e9 dif\u00edcil provar que um algoritmo guloso funciona. Ent\u00e3o, como saber se um algoritmo guloso resolver\u00e1 determinado problema? De forma simplificada, um algoritmo guloso deve possuir dois componentes fundamentais: Propriedade de escolha gulosa Uma solu\u00e7\u00e3o globalmente \u00f3tima \u00e9 constru\u00edda fazendo escolhas (gulosas) locais \u00f3tima. Em outras palavras, quando o algoritmo est\u00e1 considerando qual escolha fazer, ele escolhe a que parece melhor para o problema em quest\u00e3o, sem considerar resultados dos subproblemas e sem reconsiderar as escolhas anteriores. Subestrutura \u00f3tima A solu\u00e7\u00e3o \u00f3tima do problema cont\u00e9m solu\u00e7\u00f5es \u00f3timas dos subproblemas. Como voc\u00ea deve ter percebido, algoritmo guloso n\u00e3o se refere a um \u00fanico algoritmo, mas sim a uma forma de pensar que se aplica aos problemas, ou seja, n\u00e3o h\u00e1 uma (\u00fanica) maneira de fazer algoritmos gulosos. Por isso, segue uma sele\u00e7\u00e3o de exemplos bem conhecidos para ajud\u00e1-lo a entender o paradigma guloso. Exemplos Sele\u00e7\u00e3o de tarefas Considere o problema onde voc\u00ea precisa realizar algumas tarefas e voc\u00ea possui \\(X\\) ( \\(1 \\leq X \\leq 10^4\\) ) minutos para se realiz\u00e1-las. Existem \\(N\\) ( \\(1 \\leq N \\leq 100\\) ) tarefas e cada uma requer \\(a_i\\) ( \\(1 \\leq a_i \\leq 100\\) ) minutos para serem conclu\u00eddas. Qual o n\u00famero m\u00e1ximo de tarefas que voc\u00ea pode/consegue finalizar? Solu\u00e7\u00e3o Como voc\u00ea deseja concluir o n\u00famero m\u00e1ximo de tarefas, voc\u00ea deve priorizar as tarefas mais r\u00e1pidas, ou seja, comece realizando a tarefa que requer a menor quantidade de tempo e, em seguida, escolha outras tarefas em ordem crescente de tempo necess\u00e1rio. Por exemplo, considere a seguinte entrada: \\[ X = 15, N = 6, a_i = \\{4, 3, 8, 4, 7, 3\\} \\] Depois de ordenar o array, temos \\(\\{ 3, 3, 4, 4, 7, 8 \\}\\) . Assim, dentro dos 15 minutos voc\u00ea pode finalizar quatro tarefas em um total de \\(3+3+4+4 = 14\\) minutos. A implementa\u00e7\u00e3o \u00e9 bem simples. Ordene o array com o tempo necess\u00e1rio de finaliza\u00e7\u00e3o das tarefas e, em seguida, selecione o maior n\u00famero poss\u00edvel de tarefas enquanto a soma dos tempos das tarefas for menor que \\(X\\) . C++ Python 1 2 3 4 5 6 7 8 9 10 // Fa\u00e7a a leitura dos dados e armazene o tempo das tarefas em um vector 'a' sort ( all ( a )); ll tempo = 0 ; // Quantidade de minutos usados at\u00e9 o momento ll i = 0 ; while ( i < N && tempo + a [ i ] <= X ) { // Enquanto houver tempo dispon\u00edvel, realize mais tarefas tempo += a [ i ]; i ++ ; } cout << i << endl ; 1 2 3 4 5 6 7 8 9 # Fa\u00e7a a leitura dos dados e armazene o tempo das tarefas em uma lista 'a' a . sort () tempo = 0 # Quantidade de minutos usados at\u00e9 o momento i = 0 while i < N and tempo + a [ i ] <= X : # Enquanto houver tempo dispon\u00edvel, realize mais tarefas tempo += a [ i ] i += 1 print ( i ) Escalonamento Muitos problemas de escalonamento podem ser resolvidos usando algoritmos gulosos. Um problema cl\u00e1ssico \u00e9 o seguinte: dados \\(n\\) eventos (ou tarefas) com seus hor\u00e1rios de in\u00edcio e t\u00e9rmino, encontre uma programa\u00e7\u00e3o que inclua o maior n\u00famero poss\u00edvel de eventos. N\u00e3o \u00e9 poss\u00edvel selecionar um evento parcialmente. Por exemplo, considere os seguintes eventos: Evento Tempo de in\u00edcio Tempo de fim A 1 3 B 2 5 C 3 9 D 6 8 Neste caso, o n\u00famero m\u00e1ximo de eventos \u00e9 dois. Por exemplo, selecionar os eventos \\(B\\) e \\(D\\) : Fonte: Competitive Programmer\u2019s Handbook Perceba que \u00e9 f\u00e1cil pensar em diferentes estrat\u00e9gias gulosas para resolver este problema, mas qual delas funciona em todos os casos? Algoritmo 1 A primeira ideia \u00e9 ordenar os eventos de acordo com o seu \"comprimento\" e, enquanto for poss\u00edvel, ir selecionando os eventos que n\u00e3o se sobrep\u00f5em. Para o exemplo anterior, este algoritmo seleciona os seguintes eventos: Fonte: Competitive Programmer\u2019s Handbook No entanto, este algoritmo falha, por exemplo, no seguinte caso: Fonte: Competitive Programmer\u2019s Handbook Algoritmo 2 Outra ideia \u00e9 sempre selecionar o pr\u00f3ximo evento vi\u00e1vel que comece o mais cedo poss\u00edvel. Para o exemplo, este algoritmo seleciona os seguintes eventos: Fonte: Competitive Programmer\u2019s Handbook No entanto, este algoritmo tamb\u00e9m falha. Por exemplo: Fonte: Competitive Programmer\u2019s Handbook Algoritmo 3 A terceira ideia \u00e9 sempre selecionar o pr\u00f3ximo evento vi\u00e1vel que termine o mais cedo poss\u00edvel. Para o exemplo, este algoritmo seleciona os seguintes eventos: Fonte: Competitive Programmer\u2019s Handbook Este algoritmo sempre produz uma solu\u00e7\u00e3o \u00f3tima. Voc\u00ea pode encontrar a prova neste link . Problema da mochila fracion\u00e1ria Imagine um conjunto de objetos que voc\u00ea gostaria de colocar em uma mochila com capacidade de \\(C\\) kg. Cada objeto tem um certo peso e um certo valor. Voc\u00ea pode escolher uma fra\u00e7\u00e3o, entre 0% e 100%, de cada objeto para colocar na mochila. Que fra\u00e7\u00e3o de cada objeto voc\u00ea deve colocar na mochila de modo a maximizar o valor total? Aten\u00e7\u00e3o No problema da mochila 0-1 , n\u00e3o podemos fracionar os itens. Ou pegamos o item inteiro ou n\u00e3o o pegamos. Solu\u00e7\u00e3o A ideia b\u00e1sica da abordagem gulosa \u00e9 calcular a propor\u00e7\u00e3o \\(valor/peso\\) de cada item e ordenar os itens com base nesta propor\u00e7\u00e3o. Em seguida, enquanto for poss\u00edvel, pegue o item com a propor\u00e7\u00e3o mais alta que cabe totalmente na mochila. No final, adicione o pr\u00f3ximo item o m\u00e1ximo que for poss\u00edvel. Esta estrat\u00e9gia gulosa produzir\u00e1 uma solu\u00e7\u00e3o \u00f3tima para o problema. Por exemplo, considere a inst\u00e2ncia do problema da mochila fracion\u00e1ria que tem \\(N = 5\\) objetos, capacidade \\(C = 50\\) e os pesos e valores conforme a figura abaixo. A \u00faltima linha da figura exibe a propor\u00e7\u00e3o do item que deve ser adicionado na mochila para que a mesma tenha valor m\u00e1ximo. O valor dessa solu\u00e7\u00e3o \u00e9 1040. O valor da solu\u00e7\u00e3o do correspondente problema da mochila 0-1 \u00e9 1000. Fonte: Mochila fracion\u00e1ria Esta estrat\u00e9gia gulosa funciona se for considerado o problema da mochila 0-1 ? Quando o guloso falha? Como j\u00e1 dito, nem sempre um algoritmo guloso ir\u00e1 funcionar para todo problema. Por isso, seguem dois exemplos de problemas em que ele falha. Problema do troco O problema do troco pode ser descrito como: dado um certo valor \\(V\\) e uma lista \\(m\\) de \\(n\\) moedas, supondo que exista uma quantidade ilimitada de moedas de todos os tipos, o problema consiste em descobrir qual o n\u00famero m\u00ednimo de moedas para representar \\(V\\) . Por exemplo, se \\(n = 4\\) , \\(m = \\{25, 10, 5, 1\\}\\) centavos e se deseja representar \\(V = 42\\) centavos, a solu\u00e7\u00e3o \u00f3tima \u00e9 usar \\(5\\) moedas ( \\(25 + 10 + 5 + 1 + 1\\) ). Existe um algoritmo guloso natural para resolver o problema: sempre selecionar a maior moeda poss\u00edvel para que a soma dos valores das moedas n\u00e3o exceda \\(V\\) . Veja que esta estrat\u00e9gia gera a solu\u00e7\u00e3o \u00f3tima do exemplo anterior. Entretanto, esta estrat\u00e9gia nem sempre funciona. Por exemplo, se \\(n = 3\\) , \\(m = \\{4, 3, 1\\}\\) centavos e \\(V = 6\\) , o algoritmo guloso ir\u00e1 selecionar 3 moedas \\((4 + 1 + 1)\\) ao inv\u00e9s da solu\u00e7\u00e3o \u00f3tima que usa 2 moedas \\((3 + 3)\\) . Para resolver este problema de forma \u00f3tima, precisamos usar Programa\u00e7\u00e3o Din\u00e2mica . Problema da mochila 0-1 Diferente do problema da mochila fracion\u00e1ria , no problema da mochila 0-1 (ou mochila booleana), n\u00e3o podemos fracionar os itens, ou seja, ou pegamos o item inteiro ou n\u00e3o o pegamos. Neste caso, uma estrat\u00e9gia gulosa n\u00e3o funciona. Por exemplo, para a inst\u00e2ncia apresentada no problema da mochila fracion\u00e1ria a solu\u00e7\u00e3o gulosa pegaria o item de peso 40 e o item de peso 10, na qual a solu\u00e7\u00e3o \u00e9 940. No entanto, a solu\u00e7\u00e3o \u00f3tima \u00e9 selecionar os itens de peso 30 e 20, cuja solu\u00e7\u00e3o \u00e9 1000. Para resolver este problema de forma \u00f3tima, tamb\u00e9m precisamos usar Programa\u00e7\u00e3o Din\u00e2mica . Material complementar \u2b50\ufe0f Introduction to Greedy Algorithms \u2b50\ufe0f Greedy Algorithms with Sorting \u2b50\ufe0f Greedy Algorithms (GeeksforGeeks) M\u00e9todo Guloso (IME-USP) Principles of Algorithmic Problem Solving Competitive Programmer's Handbook O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 e 4 \u21a9","title":"Algoritmos Gulosos"},{"location":"guloso/#algoritmos-gulosos1","text":"Um algoritmo \u00e9 dito guloso se, em cada passo, ele faz uma escolha localmente \u00f3tima na esperan\u00e7a de que essa escolha leve a uma solu\u00e7\u00e3o globalmente \u00f3tima. Um algoritmo guloso nunca retoma suas escolhas, de forma a construir diretamente a solu\u00e7\u00e3o final. Por esta raz\u00e3o, algoritmos gulosos s\u00e3o geralmente muito eficientes. Por exemplo, uma maneira natural de se calcular o menor caminho entre os v\u00e9rtices \\(x\\) e \\(y\\) de um grafo pode ser sair de \\(x\\) e, repetidamente, seguir a aresta mais barata at\u00e9 se alcan\u00e7ar o v\u00e9rtice \\(y\\) . Natural, mas errada! A maior dificuldade em projetar um algoritmo guloso \u00e9 encontrar uma estrat\u00e9gia gulosa que sempre produza uma solu\u00e7\u00e3o \u00f3tima para o problema, uma vez que as escolhas localmente \u00f3timas tamb\u00e9m devem ser globalmente \u00f3timas. Muitas vezes \u00e9 dif\u00edcil provar que um algoritmo guloso funciona. Ent\u00e3o, como saber se um algoritmo guloso resolver\u00e1 determinado problema? De forma simplificada, um algoritmo guloso deve possuir dois componentes fundamentais: Propriedade de escolha gulosa Uma solu\u00e7\u00e3o globalmente \u00f3tima \u00e9 constru\u00edda fazendo escolhas (gulosas) locais \u00f3tima. Em outras palavras, quando o algoritmo est\u00e1 considerando qual escolha fazer, ele escolhe a que parece melhor para o problema em quest\u00e3o, sem considerar resultados dos subproblemas e sem reconsiderar as escolhas anteriores. Subestrutura \u00f3tima A solu\u00e7\u00e3o \u00f3tima do problema cont\u00e9m solu\u00e7\u00f5es \u00f3timas dos subproblemas. Como voc\u00ea deve ter percebido, algoritmo guloso n\u00e3o se refere a um \u00fanico algoritmo, mas sim a uma forma de pensar que se aplica aos problemas, ou seja, n\u00e3o h\u00e1 uma (\u00fanica) maneira de fazer algoritmos gulosos. Por isso, segue uma sele\u00e7\u00e3o de exemplos bem conhecidos para ajud\u00e1-lo a entender o paradigma guloso.","title":"Algoritmos Gulosos1"},{"location":"guloso/#exemplos","text":"","title":"Exemplos"},{"location":"guloso/#selecao-de-tarefas","text":"Considere o problema onde voc\u00ea precisa realizar algumas tarefas e voc\u00ea possui \\(X\\) ( \\(1 \\leq X \\leq 10^4\\) ) minutos para se realiz\u00e1-las. Existem \\(N\\) ( \\(1 \\leq N \\leq 100\\) ) tarefas e cada uma requer \\(a_i\\) ( \\(1 \\leq a_i \\leq 100\\) ) minutos para serem conclu\u00eddas. Qual o n\u00famero m\u00e1ximo de tarefas que voc\u00ea pode/consegue finalizar? Solu\u00e7\u00e3o Como voc\u00ea deseja concluir o n\u00famero m\u00e1ximo de tarefas, voc\u00ea deve priorizar as tarefas mais r\u00e1pidas, ou seja, comece realizando a tarefa que requer a menor quantidade de tempo e, em seguida, escolha outras tarefas em ordem crescente de tempo necess\u00e1rio. Por exemplo, considere a seguinte entrada: \\[ X = 15, N = 6, a_i = \\{4, 3, 8, 4, 7, 3\\} \\] Depois de ordenar o array, temos \\(\\{ 3, 3, 4, 4, 7, 8 \\}\\) . Assim, dentro dos 15 minutos voc\u00ea pode finalizar quatro tarefas em um total de \\(3+3+4+4 = 14\\) minutos. A implementa\u00e7\u00e3o \u00e9 bem simples. Ordene o array com o tempo necess\u00e1rio de finaliza\u00e7\u00e3o das tarefas e, em seguida, selecione o maior n\u00famero poss\u00edvel de tarefas enquanto a soma dos tempos das tarefas for menor que \\(X\\) . C++ Python 1 2 3 4 5 6 7 8 9 10 // Fa\u00e7a a leitura dos dados e armazene o tempo das tarefas em um vector 'a' sort ( all ( a )); ll tempo = 0 ; // Quantidade de minutos usados at\u00e9 o momento ll i = 0 ; while ( i < N && tempo + a [ i ] <= X ) { // Enquanto houver tempo dispon\u00edvel, realize mais tarefas tempo += a [ i ]; i ++ ; } cout << i << endl ; 1 2 3 4 5 6 7 8 9 # Fa\u00e7a a leitura dos dados e armazene o tempo das tarefas em uma lista 'a' a . sort () tempo = 0 # Quantidade de minutos usados at\u00e9 o momento i = 0 while i < N and tempo + a [ i ] <= X : # Enquanto houver tempo dispon\u00edvel, realize mais tarefas tempo += a [ i ] i += 1 print ( i )","title":"Sele\u00e7\u00e3o de tarefas"},{"location":"guloso/#escalonamento","text":"Muitos problemas de escalonamento podem ser resolvidos usando algoritmos gulosos. Um problema cl\u00e1ssico \u00e9 o seguinte: dados \\(n\\) eventos (ou tarefas) com seus hor\u00e1rios de in\u00edcio e t\u00e9rmino, encontre uma programa\u00e7\u00e3o que inclua o maior n\u00famero poss\u00edvel de eventos. N\u00e3o \u00e9 poss\u00edvel selecionar um evento parcialmente. Por exemplo, considere os seguintes eventos: Evento Tempo de in\u00edcio Tempo de fim A 1 3 B 2 5 C 3 9 D 6 8 Neste caso, o n\u00famero m\u00e1ximo de eventos \u00e9 dois. Por exemplo, selecionar os eventos \\(B\\) e \\(D\\) : Fonte: Competitive Programmer\u2019s Handbook Perceba que \u00e9 f\u00e1cil pensar em diferentes estrat\u00e9gias gulosas para resolver este problema, mas qual delas funciona em todos os casos? Algoritmo 1 A primeira ideia \u00e9 ordenar os eventos de acordo com o seu \"comprimento\" e, enquanto for poss\u00edvel, ir selecionando os eventos que n\u00e3o se sobrep\u00f5em. Para o exemplo anterior, este algoritmo seleciona os seguintes eventos: Fonte: Competitive Programmer\u2019s Handbook No entanto, este algoritmo falha, por exemplo, no seguinte caso: Fonte: Competitive Programmer\u2019s Handbook Algoritmo 2 Outra ideia \u00e9 sempre selecionar o pr\u00f3ximo evento vi\u00e1vel que comece o mais cedo poss\u00edvel. Para o exemplo, este algoritmo seleciona os seguintes eventos: Fonte: Competitive Programmer\u2019s Handbook No entanto, este algoritmo tamb\u00e9m falha. Por exemplo: Fonte: Competitive Programmer\u2019s Handbook Algoritmo 3 A terceira ideia \u00e9 sempre selecionar o pr\u00f3ximo evento vi\u00e1vel que termine o mais cedo poss\u00edvel. Para o exemplo, este algoritmo seleciona os seguintes eventos: Fonte: Competitive Programmer\u2019s Handbook Este algoritmo sempre produz uma solu\u00e7\u00e3o \u00f3tima. Voc\u00ea pode encontrar a prova neste link .","title":"Escalonamento"},{"location":"guloso/#problema-da-mochila-fracionaria","text":"Imagine um conjunto de objetos que voc\u00ea gostaria de colocar em uma mochila com capacidade de \\(C\\) kg. Cada objeto tem um certo peso e um certo valor. Voc\u00ea pode escolher uma fra\u00e7\u00e3o, entre 0% e 100%, de cada objeto para colocar na mochila. Que fra\u00e7\u00e3o de cada objeto voc\u00ea deve colocar na mochila de modo a maximizar o valor total? Aten\u00e7\u00e3o No problema da mochila 0-1 , n\u00e3o podemos fracionar os itens. Ou pegamos o item inteiro ou n\u00e3o o pegamos. Solu\u00e7\u00e3o A ideia b\u00e1sica da abordagem gulosa \u00e9 calcular a propor\u00e7\u00e3o \\(valor/peso\\) de cada item e ordenar os itens com base nesta propor\u00e7\u00e3o. Em seguida, enquanto for poss\u00edvel, pegue o item com a propor\u00e7\u00e3o mais alta que cabe totalmente na mochila. No final, adicione o pr\u00f3ximo item o m\u00e1ximo que for poss\u00edvel. Esta estrat\u00e9gia gulosa produzir\u00e1 uma solu\u00e7\u00e3o \u00f3tima para o problema. Por exemplo, considere a inst\u00e2ncia do problema da mochila fracion\u00e1ria que tem \\(N = 5\\) objetos, capacidade \\(C = 50\\) e os pesos e valores conforme a figura abaixo. A \u00faltima linha da figura exibe a propor\u00e7\u00e3o do item que deve ser adicionado na mochila para que a mesma tenha valor m\u00e1ximo. O valor dessa solu\u00e7\u00e3o \u00e9 1040. O valor da solu\u00e7\u00e3o do correspondente problema da mochila 0-1 \u00e9 1000. Fonte: Mochila fracion\u00e1ria Esta estrat\u00e9gia gulosa funciona se for considerado o problema da mochila 0-1 ?","title":"Problema da mochila fracion\u00e1ria"},{"location":"guloso/#quando-o-guloso-falha","text":"Como j\u00e1 dito, nem sempre um algoritmo guloso ir\u00e1 funcionar para todo problema. Por isso, seguem dois exemplos de problemas em que ele falha.","title":"Quando o guloso falha?"},{"location":"guloso/#problema-do-troco","text":"O problema do troco pode ser descrito como: dado um certo valor \\(V\\) e uma lista \\(m\\) de \\(n\\) moedas, supondo que exista uma quantidade ilimitada de moedas de todos os tipos, o problema consiste em descobrir qual o n\u00famero m\u00ednimo de moedas para representar \\(V\\) . Por exemplo, se \\(n = 4\\) , \\(m = \\{25, 10, 5, 1\\}\\) centavos e se deseja representar \\(V = 42\\) centavos, a solu\u00e7\u00e3o \u00f3tima \u00e9 usar \\(5\\) moedas ( \\(25 + 10 + 5 + 1 + 1\\) ). Existe um algoritmo guloso natural para resolver o problema: sempre selecionar a maior moeda poss\u00edvel para que a soma dos valores das moedas n\u00e3o exceda \\(V\\) . Veja que esta estrat\u00e9gia gera a solu\u00e7\u00e3o \u00f3tima do exemplo anterior. Entretanto, esta estrat\u00e9gia nem sempre funciona. Por exemplo, se \\(n = 3\\) , \\(m = \\{4, 3, 1\\}\\) centavos e \\(V = 6\\) , o algoritmo guloso ir\u00e1 selecionar 3 moedas \\((4 + 1 + 1)\\) ao inv\u00e9s da solu\u00e7\u00e3o \u00f3tima que usa 2 moedas \\((3 + 3)\\) . Para resolver este problema de forma \u00f3tima, precisamos usar Programa\u00e7\u00e3o Din\u00e2mica .","title":"Problema do troco"},{"location":"guloso/#problema-da-mochila-0-1","text":"Diferente do problema da mochila fracion\u00e1ria , no problema da mochila 0-1 (ou mochila booleana), n\u00e3o podemos fracionar os itens, ou seja, ou pegamos o item inteiro ou n\u00e3o o pegamos. Neste caso, uma estrat\u00e9gia gulosa n\u00e3o funciona. Por exemplo, para a inst\u00e2ncia apresentada no problema da mochila fracion\u00e1ria a solu\u00e7\u00e3o gulosa pegaria o item de peso 40 e o item de peso 10, na qual a solu\u00e7\u00e3o \u00e9 940. No entanto, a solu\u00e7\u00e3o \u00f3tima \u00e9 selecionar os itens de peso 30 e 20, cuja solu\u00e7\u00e3o \u00e9 1000. Para resolver este problema de forma \u00f3tima, tamb\u00e9m precisamos usar Programa\u00e7\u00e3o Din\u00e2mica .","title":"Problema da mochila 0-1"},{"location":"guloso/#material-complementar","text":"\u2b50\ufe0f Introduction to Greedy Algorithms \u2b50\ufe0f Greedy Algorithms with Sorting \u2b50\ufe0f Greedy Algorithms (GeeksforGeeks) M\u00e9todo Guloso (IME-USP) Principles of Algorithmic Problem Solving Competitive Programmer's Handbook O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 e 4 \u21a9","title":"Material complementar"},{"location":"inicio/","text":"Programa\u00e7\u00e3o Competitiva Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 . Caracter\u00edsticas da linguagem 1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada. Entrada e Sa\u00edda Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output Trabalhando com n\u00fameros Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types Simplificando o c\u00f3digo Nomes de tipos Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ; Macros Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) . Dicas e truques de C++ A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Inicio"},{"location":"inicio/#programacao-competitiva","text":"Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 .","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"inicio/#caracteristicas-da-linguagem","text":"1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada.","title":"Caracter\u00edsticas da linguagem"},{"location":"inicio/#entrada-e-saida","text":"Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output","title":"Entrada e Sa\u00edda"},{"location":"inicio/#trabalhando-com-numeros","text":"Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types","title":"Trabalhando com n\u00fameros"},{"location":"inicio/#simplificando-o-codigo","text":"","title":"Simplificando o c\u00f3digo"},{"location":"inicio/#nomes-de-tipos","text":"Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ;","title":"Nomes de tipos"},{"location":"inicio/#macros","text":"Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) .","title":"Macros"},{"location":"inicio/#dicas-e-truques-de-c","text":"A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Dicas e truques de C++"},{"location":"manipulacaobits/","text":"Manipula\u00e7\u00e3o de Bits Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequ\u00eancia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequ\u00eancia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valores inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorrer\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois). Operadores sobre Bits Operador AND ( & e &= ) Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) . Operador OR inclusivo ( | e |= ) Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110 Operador OR exclusivo ( ^ e ^= ) Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110 Operador NOT ( ~ e ~= ) Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A f\u00f3rmula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 . Operador de deslocamento \u00e0 esquerda ( << e <<= ) Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56 Operador de deslocamento \u00e0 direita ( >> e >>= ) Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010000 -> 16 a = a >> 1 // 00001000 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7 Fun\u00e7\u00f5es adicionais O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x) Alguns truques e aplica\u00e7\u00f5es Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois. std::bitset Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o . Material complementar Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#manipulacao-de-bits","text":"Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequ\u00eancia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequ\u00eancia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valores inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorrer\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois).","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#operadores-sobre-bits","text":"","title":"Operadores sobre Bits"},{"location":"manipulacaobits/#operador-and-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) .","title":"Operador AND (&amp; e &amp;=)"},{"location":"manipulacaobits/#operador-or-inclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110","title":"Operador OR inclusivo (| e |=)"},{"location":"manipulacaobits/#operador-or-exclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110","title":"Operador OR exclusivo (^ e ^=)"},{"location":"manipulacaobits/#operador-not-e","text":"Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A f\u00f3rmula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 .","title":"Operador NOT (~ e ~=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-esquerda-e","text":"Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56","title":"Operador de deslocamento \u00e0 esquerda (&lt;&lt; e &lt;&lt;=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-direita-e","text":"Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010000 -> 16 a = a >> 1 // 00001000 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7","title":"Operador de deslocamento \u00e0 direita (&gt;&gt; e &gt;&gt;=)"},{"location":"manipulacaobits/#funcoes-adicionais","text":"O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x)","title":"Fun\u00e7\u00f5es adicionais"},{"location":"manipulacaobits/#alguns-truques-e-aplicacoes","text":"Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois.","title":"Alguns truques e aplica\u00e7\u00f5es"},{"location":"manipulacaobits/#stdbitset","text":"Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o .","title":"std::bitset"},{"location":"manipulacaobits/#material-complementar","text":"Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Material complementar"},{"location":"ordenacao/","text":"Ordena\u00e7\u00e3o 1 A maioria das linguagens de programa\u00e7\u00e3o modernas implementa uma fun\u00e7\u00e3o de ordena\u00e7\u00e3o eficiente. Em C++, tem-se a fun\u00e7\u00e3o sort da biblioteca <algorithm> . Veja alguns exemplos de uso desta fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 int n = 7 ; int a [] = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( a , a + n ); // (1) vector < int > v = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( v . begin (), v . end ()); // (2) vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . begin (), alunos . end ()); // (3) for ( auto a : alunos ) cout << a . first << \" \" << a . second << endl ; // (4) [2, 3, 3, 4, 5, 5, 8] [2, 3, 3, 4, 5, 5, 8] Por padr\u00e3o, um pair sempre \u00e9 ordenado pelo campo first . {123, Paulo} {456, Ana} {789, Paulo} A ordena\u00e7\u00e3o padr\u00e3o \u00e9 a n\u00e3o-decrescente, mas pode-se obter a ordem inversa da seguinte forma: 1 2 3 4 vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . rbegin (), alunos . rend ()); for ( auto a : alunos ) // (1) cout << a . first << \" \" << a . second << endl ; {789, Paulo} {456, Ana} {123, Paulo} Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Agora suponha que seja necess\u00e1rio ordenar objetos do tipo Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ // (1) this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; Construtor padr\u00e3o usado quando n\u00e3o passamos nenhum argumento para a classe. Sempre fa\u00e7a o construtor padr\u00e3o. Caso contr\u00e1rio, n\u00e3o ser\u00e1 possivel fazer, por exemplo: Pessoa p ; //Chama o construtor padr\u00e3o . Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Usando uma fun\u00e7\u00e3o de compara\u00e7\u00e3o A primeira alternativa \u00e9 definir uma fun\u00e7\u00e3o que compara dois objetos e retorna true caso o primeiro seja considerado menor que o segundo e false , caso contr\u00e1rio. Por exemplo, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool compara ( const Pessoa & p1 , const Pessoa & p2 ) { // (1) if ( p1 . nome < p2 . nome ) return true ; else if ( p1 . nome == p2 . nome ) { if ( p1 . sobrenome < p2 . sobrenome ) return true ; else if ( p1 . sobrenome == p2 . sobrenome ) return p1 . idade > p2 . idade ; else return false ; } else return false ; } O const diz ao compilador que os objetos passados para a fun\u00e7\u00e3o n\u00e3o ser\u00e3o alterados internamento. J\u00e1 o & representa passagem por refer\u00eancia , uma alternativa a passagem por ponteiro . Dessa forma, n\u00e3o passamos uma c\u00f3pia dos objetos e sim refer\u00eancias (endere\u00e7os) dos mesmos, o que torna o c\u00f3digo mais eficiente. Por qu\u00ea? Com a fun\u00e7\u00e3o de compara\u00e7\u00e3o definida, basta pass\u00e1-la como argumento na fun\u00e7\u00e3o sort : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); // (1) lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end (), compara ); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Inclui o elemento no fim do vector . Leia mais sobre vector aqui . Usa a fun\u00e7\u00e3o compara para fazer a ordena\u00e7\u00e3o. Tamb\u00e9m \u00e9 possivel usar uma fun\u00e7\u00e3o lambda como fun\u00e7\u00e3o de compara\u00e7\u00e3o. Por exemplo, para ordenar um pair pelo campo second (ou usando-o como crit\u00e9rio de desempate), pode-se fazer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool compara ( const pair < int , int > & p1 , const pair < int , int > & p2 ) { if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; } int main () { vector < pair < int , int >> pontos = {{ 0 , 2 }, { 0 , 1 }, { 0 , 0 }, { 0 , -5 }, { 1 , 2 }, { -1 , 10 }}; sort ( pontos . begin (), pontos . end (), compara ); // (1) for ( auto a : pontos ) // (2) cout << \"(\" << a . first << \", \" << a . second << \") \" ; sort ( pontos . begin (), pontos . end (), []( const pair < int , int > & p1 , const pair < int , int > & p2 ) { // (3) if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; }); for ( auto a : pontos ) cout << \"(\" << a . first << \", \" << a . second << \") \" ; return 0 ; } Usando a fun\u00e7\u00e3o compara (-1, 10) (0, -5) (0, 0) (0, 1) (0, 2) (1, 2) Usando fun\u00e7\u00e3o lambda Fazando a sobrecarga do operador < Ao inv\u00e9s de ser difinidas fun\u00e7\u00f5es de compara\u00e7\u00f5es, pode-se fazer a sobrecarga do operador < ( operator < ). Isso \u00e9 comum ao se usar class ou struct . Veja como ficaria ao ser considerado a classe Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } bool operator < ( const Pessoa & p ){ // (1) if ( nome < p . nome ) return true ; else if ( nome == p . nome ) { if ( sobrenome < p . sobrenome ) return true ; else if ( sobrenome == p . sobrenome ) return idade > p . idade ; else return false ; } else return false ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end ()); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Sobrecarga/defini\u00e7\u00e3o do operador < para a classe Pessoa . Dessa forma, \u00e9 possivel fazer a compara\u00e7\u00e3o p1 < p2 , considerando que p1 e p2 s\u00e3o objetos do tipo Pessoa . Usa o operador < para fazer a ordena\u00e7\u00e3o. Material complementar Competitive Programmer\u2019s Handbook Sorting (CS Academy) std::sort std::partial_sort std::stable_sort std::nth_element O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9","title":"Ordena\u00e7\u00e3o"},{"location":"ordenacao/#ordenacao1","text":"A maioria das linguagens de programa\u00e7\u00e3o modernas implementa uma fun\u00e7\u00e3o de ordena\u00e7\u00e3o eficiente. Em C++, tem-se a fun\u00e7\u00e3o sort da biblioteca <algorithm> . Veja alguns exemplos de uso desta fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 int n = 7 ; int a [] = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( a , a + n ); // (1) vector < int > v = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( v . begin (), v . end ()); // (2) vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . begin (), alunos . end ()); // (3) for ( auto a : alunos ) cout << a . first << \" \" << a . second << endl ; // (4) [2, 3, 3, 4, 5, 5, 8] [2, 3, 3, 4, 5, 5, 8] Por padr\u00e3o, um pair sempre \u00e9 ordenado pelo campo first . {123, Paulo} {456, Ana} {789, Paulo} A ordena\u00e7\u00e3o padr\u00e3o \u00e9 a n\u00e3o-decrescente, mas pode-se obter a ordem inversa da seguinte forma: 1 2 3 4 vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . rbegin (), alunos . rend ()); for ( auto a : alunos ) // (1) cout << a . first << \" \" << a . second << endl ; {789, Paulo} {456, Ana} {123, Paulo} Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Agora suponha que seja necess\u00e1rio ordenar objetos do tipo Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ // (1) this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; Construtor padr\u00e3o usado quando n\u00e3o passamos nenhum argumento para a classe. Sempre fa\u00e7a o construtor padr\u00e3o. Caso contr\u00e1rio, n\u00e3o ser\u00e1 possivel fazer, por exemplo: Pessoa p ; //Chama o construtor padr\u00e3o . Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < .","title":"Ordena\u00e7\u00e3o1"},{"location":"ordenacao/#usando-uma-funcao-de-comparacao","text":"A primeira alternativa \u00e9 definir uma fun\u00e7\u00e3o que compara dois objetos e retorna true caso o primeiro seja considerado menor que o segundo e false , caso contr\u00e1rio. Por exemplo, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool compara ( const Pessoa & p1 , const Pessoa & p2 ) { // (1) if ( p1 . nome < p2 . nome ) return true ; else if ( p1 . nome == p2 . nome ) { if ( p1 . sobrenome < p2 . sobrenome ) return true ; else if ( p1 . sobrenome == p2 . sobrenome ) return p1 . idade > p2 . idade ; else return false ; } else return false ; } O const diz ao compilador que os objetos passados para a fun\u00e7\u00e3o n\u00e3o ser\u00e3o alterados internamento. J\u00e1 o & representa passagem por refer\u00eancia , uma alternativa a passagem por ponteiro . Dessa forma, n\u00e3o passamos uma c\u00f3pia dos objetos e sim refer\u00eancias (endere\u00e7os) dos mesmos, o que torna o c\u00f3digo mais eficiente. Por qu\u00ea? Com a fun\u00e7\u00e3o de compara\u00e7\u00e3o definida, basta pass\u00e1-la como argumento na fun\u00e7\u00e3o sort : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); // (1) lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end (), compara ); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Inclui o elemento no fim do vector . Leia mais sobre vector aqui . Usa a fun\u00e7\u00e3o compara para fazer a ordena\u00e7\u00e3o. Tamb\u00e9m \u00e9 possivel usar uma fun\u00e7\u00e3o lambda como fun\u00e7\u00e3o de compara\u00e7\u00e3o. Por exemplo, para ordenar um pair pelo campo second (ou usando-o como crit\u00e9rio de desempate), pode-se fazer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool compara ( const pair < int , int > & p1 , const pair < int , int > & p2 ) { if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; } int main () { vector < pair < int , int >> pontos = {{ 0 , 2 }, { 0 , 1 }, { 0 , 0 }, { 0 , -5 }, { 1 , 2 }, { -1 , 10 }}; sort ( pontos . begin (), pontos . end (), compara ); // (1) for ( auto a : pontos ) // (2) cout << \"(\" << a . first << \", \" << a . second << \") \" ; sort ( pontos . begin (), pontos . end (), []( const pair < int , int > & p1 , const pair < int , int > & p2 ) { // (3) if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; }); for ( auto a : pontos ) cout << \"(\" << a . first << \", \" << a . second << \") \" ; return 0 ; } Usando a fun\u00e7\u00e3o compara (-1, 10) (0, -5) (0, 0) (0, 1) (0, 2) (1, 2) Usando fun\u00e7\u00e3o lambda","title":"Usando uma fun\u00e7\u00e3o de compara\u00e7\u00e3o"},{"location":"ordenacao/#fazando-a-sobrecarga-do-operador","text":"Ao inv\u00e9s de ser difinidas fun\u00e7\u00f5es de compara\u00e7\u00f5es, pode-se fazer a sobrecarga do operador < ( operator < ). Isso \u00e9 comum ao se usar class ou struct . Veja como ficaria ao ser considerado a classe Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } bool operator < ( const Pessoa & p ){ // (1) if ( nome < p . nome ) return true ; else if ( nome == p . nome ) { if ( sobrenome < p . sobrenome ) return true ; else if ( sobrenome == p . sobrenome ) return idade > p . idade ; else return false ; } else return false ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end ()); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Sobrecarga/defini\u00e7\u00e3o do operador < para a classe Pessoa . Dessa forma, \u00e9 possivel fazer a compara\u00e7\u00e3o p1 < p2 , considerando que p1 e p2 s\u00e3o objetos do tipo Pessoa . Usa o operador < para fazer a ordena\u00e7\u00e3o.","title":"Fazando a sobrecarga do operador &lt;"},{"location":"ordenacao/#material-complementar","text":"Competitive Programmer\u2019s Handbook Sorting (CS Academy) std::sort std::partial_sort std::stable_sort std::nth_element O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9","title":"Material complementar"},{"location":"ordenacao_e_busca/","text":"Ordena\u00e7\u00e3o e Busca 1 Ordena\u00e7\u00e3o A maioria das linguagens de programa\u00e7\u00e3o modernas implementa uma fun\u00e7\u00e3o de ordena\u00e7\u00e3o eficiente. Em C++, tem-se a fun\u00e7\u00e3o sort da biblioteca <algorithm> . Veja alguns exemplos de uso desta fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 int n = 7 ; int a [] = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( a , a + n ); // (1) vector < int > v = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( v . begin (), v . end ()); // (2) vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . begin (), alunos . end ()); // (3) for ( auto a : alunos ) cout << a . first << \" \" << a . second << endl ; // (4) [2, 3, 3, 4, 5, 5, 8] [2, 3, 3, 4, 5, 5, 8] Por padr\u00e3o, um pair sempre \u00e9 ordenado pelo campo first . {123, Paulo} {456, Ana} {789, Paulo} A ordena\u00e7\u00e3o padr\u00e3o \u00e9 a n\u00e3o-decrescente, mas pode-se obter a ordem inversa da seguinte forma: 1 2 3 4 vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . rbegin (), alunos . rend ()); for ( auto a : alunos ) // (1) cout << a . first << \" \" << a . second << endl ; {789, Paulo} {456, Ana} {123, Paulo} Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Agora suponha que seja necess\u00e1rio ordenar objetos do tipo Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ // (1) this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; Construtor padr\u00e3o usado quando n\u00e3o passamos nenhum argumento para a classe. Sempre fa\u00e7a o construtor padr\u00e3o. Caso contr\u00e1rio, n\u00e3o ser\u00e1 possivel fazer, por exemplo: Pessoa p ; //Chama o construtor padr\u00e3o . Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Usando uma fun\u00e7\u00e3o de compara\u00e7\u00e3o A primeira alternativa \u00e9 definir uma fun\u00e7\u00e3o que compara dois objetos e retorna true caso o primeiro seja considerado menor que o segundo e false , caso contr\u00e1rio. Por exemplo, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool compara ( const Pessoa & p1 , const Pessoa & p2 ) { // (1) if ( p1 . nome < p2 . nome ) return true ; else if ( p1 . nome == p2 . nome ) { if ( p1 . sobrenome < p2 . sobrenome ) return true ; else if ( p1 . sobrenome == p2 . sobrenome ) return p1 . idade > p2 . idade ; else return false ; } else return false ; } O const diz ao compilador que os objetos passados para a fun\u00e7\u00e3o n\u00e3o ser\u00e3o alterados internamento. J\u00e1 o & representa passagem por refer\u00eancia , uma alternativa a passagem por ponteiro . Dessa forma, n\u00e3o passamos uma c\u00f3pia dos objetos e sim refer\u00eancias (endere\u00e7os) dos mesmos, o que torna o c\u00f3digo mais eficiente. Por qu\u00ea? Com a fun\u00e7\u00e3o de compara\u00e7\u00e3o definida, basta pass\u00e1-la como argumento na fun\u00e7\u00e3o sort : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); // (1) lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end (), compara ); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Inclui o elemento no fim do vector . Leia mais sobre vector aqui . Usa a fun\u00e7\u00e3o compara para fazer a ordena\u00e7\u00e3o. Tamb\u00e9m \u00e9 possivel usar uma fun\u00e7\u00e3o lambda como fun\u00e7\u00e3o de compara\u00e7\u00e3o. Por exemplo, para ordenar um pair pelo campo second (ou usando-o como crit\u00e9rio de desempate), pode-se fazer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool compara ( const pair < int , int > & p1 , const pair < int , int > & p2 ) { if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; } int main () { vector < pair < int , int >> pontos = {{ 0 , 2 }, { 0 , 1 }, { 0 , 0 }, { 0 , -5 }, { 1 , 2 }, { -1 , 10 }}; sort ( pontos . begin (), pontos . end (), compara ); // (1) for ( auto a : pontos ) // (2) cout << \"(\" << a . first << \", \" << a . second << \") \" ; sort ( pontos . begin (), pontos . end (), []( const pair < int , int > & p1 , const pair < int , int > & p2 ) { // (3) if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; }); for ( auto a : pontos ) cout << \"(\" << a . first << \", \" << a . second << \") \" ; return 0 ; } Usando a fun\u00e7\u00e3o compara (-1, 10) (0, -5) (0, 0) (0, 1) (0, 2) (1, 2) Usando fun\u00e7\u00e3o lambda Fazando a sobrecarga do operador < Ao inv\u00e9s de ser difinidas fun\u00e7\u00f5es de compara\u00e7\u00f5es, pode-se fazer a sobrecarga do operador < ( operator < ). Isso \u00e9 comum ao se usar class ou struct . Veja como ficaria ao ser considerado a classe Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } bool operator < ( const Pessoa & p ){ // (1) if ( nome < p . nome ) return true ; else if ( nome == p . nome ) { if ( sobrenome < p . sobrenome ) return true ; else if ( sobrenome == p . sobrenome ) return idade > p . idade ; else return false ; } else return false ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end ()); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Sobrecarga/defini\u00e7\u00e3o do operador < para a classe Pessoa . Dessa forma, \u00e9 possivel fazer a compara\u00e7\u00e3o p1 < p2 , considerando que p1 e p2 s\u00e3o objetos do tipo Pessoa . Usa o operador < para fazer a ordena\u00e7\u00e3o. Complemente sua leitura e seu conhecimento Competitive Programmer\u2019s Handbook Sorting (CS Academy) std::sort std::partial_sort std::stable_sort std::nth_element Busca Busca sequencial A forma mais intuitiva para procurar um elemento em um array \u00e9 usar um loop que percorre todos os elementos do array e parando assim que o elemento buscado \u00e9 encontrado. No pior caso, \u00e9 necess\u00e1rio percorrer todos os elementos, logo a complexidade ser\u00e1 \\(O(n)\\) . O c\u00f3digo abaixo verifica se x est\u00e1 no array : 1 2 3 4 5 for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] == x ) { // x encontrado na posi\u00e7\u00e3o i } } Em C++, pode-se usar a fun\u00e7\u00e3o search . Busca bin\u00e1ria Se os elementos do array estiverem ordenados, pode-se usar uma estrat\u00e9gia diferente e mais eficiente para realizar a busca: verifique se o elemento do meio do array \u00e9 o elementos buscado, se for, a busca termina. Caso n\u00e3o seja, verique se o elemento do meio \u00e9 menor que elemento buscaso, se for, repita o processo considerando apenas a segunda metade do array . Sen\u00e3o, considere a primeira metade do array . Assim, a cada passo da busca, o tamanho do array \u00e9 reduzido a metade, logo, a complexidade do algoritmo \u00e9 \\(O(\\log n)\\) . 1 2 3 4 5 6 7 8 9 10 int buscaBinaria ( vector < int > v , int x ) { int ini = 0 , fim = v . size () -1 ; while ( ini <= fim ) { int meio = ini + ( fim - ini ) / 2 ; // (1) if ( v [ meio ] == x ) return meio ; else if ( v [ meio ] < x ) ini = meio + 1 ; else fim = meio - 1 ; } return -1 ; // (2) } Evite usar meio = (ini + fim) / 2; , j\u00e1 que ini + fim pode gerar integer overflow . x n\u00e3o est\u00e1 no vetor v . Em C++, pode-se usar a fun\u00e7\u00e3o std::binary_search . As fun\u00e7\u00f5es abaixo tamb\u00e9m s\u00e3o \u00fateis e baseadas na busca bin\u00e1ria: std::lower_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 pelo menos x ; std::upper_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 maior que x ; As fun\u00e7\u00f5es assumem que o array est\u00e1 ordenado. Se o valor procurado n\u00e3o for encontrado, \u00e9 retornado um ponteiro para o elemento ap\u00f3s o \u00faltimo elemento do array . Por exemplo, o c\u00f3digo a seguir verifica se o array cont\u00e9m um elemento com valor x : 1 2 3 4 5 6 7 vector < int > v = { 1 , 2 , 3 , 5 , 8 , 10 , 20 }; int x = 10 ; auto k = lower_bound ( v . begin (), v . end (), x ); if ( k != v . end () && * k == x ) { // x encontrado no indice k cout << \"Valor encontrado na posi\u00e7\u00e3o: \" << k - v . begin () << endl ; // (1) } Pode-se usar a fun\u00e7\u00e3o std::distance ao inv\u00e9s de k - v.begin() , ou seja, distance(v.begin(), k) . Complemente sua leitura e seu conhecimento: Binary Search tutorial (C++ and Python) Busca Bin\u00e1ria Binary Search Binary Search (ITMO Academy) \ud83e\udd2f Binary Search (CS Academy) Busca bin\u00e1ria em fun\u00e7\u00f5es monot\u00f4nicas 2 Considere uma fun\u00e7\u00e3o booleana \\(f(x)\\) e se deseja encontrar o valor m\u00e1ximo (ou m\u00ednimo) de \\(x\\) tal que \\(f(x)\\) seja true . Da mesma forma que a busca bin\u00e1ria s\u00f3 funciona se o array estiver ordenado, s\u00f3 \u00e9 possivel aplicar a busca bin\u00e1ria em uma fun\u00e7\u00e3o mon\u00f3tona , ou seja, \u00e9 sempre n\u00e3o-decrescente ou sempre n\u00e3o-crescente. Seja check(x) uma fun\u00e7\u00e3o que verifica uma propriedade de x . Se para todo x , check ( x ) = true implica check ( x + 1 ) = true , ou para todo x , check ( x ) = false implica check ( x + 1 ) = false , ent\u00e3o a fun\u00e7\u00e3o check \u00e9 mon\u00f3tona. Suponha a fun\u00e7\u00e3o check abaixo que verifica se um elemento \u00e9 maior ou igual a x .. Se x = 11 e o vetor v = [1,2,3,5, 8, 11, 12, 14, 16] , ent\u00e3o teremos o seguinte vetor de sa\u00edda ao aplicarmos check em v : [0,0,0,0,0,1,1,1,1,1] . 1 2 3 bool check ( int val ) { return val >= x ; } Dessa forma, a fun\u00e7\u00e3o check para essa situa\u00e7\u00e3o \u00e9 mon\u00f3tona e isso \u00e9 relevante porque se um valor do vetor satisfizer a condi\u00e7\u00e3o, todos os valores a direita tamb\u00e9m v\u00e3o satisfaz\u00ea-la, e de forma an\u00e1loga, todos os valores a esquerda de um \u00edndice que n\u00e3o satisfaz a condi\u00e7\u00e3o, tamb\u00e9m n\u00e3o v\u00e3o satisfazer, e \u00e9 isso que nos permite aplicar busca bin\u00e1ria. Al\u00e9m disso, a fun\u00e7\u00e3o check s\u00f3 se torna mon\u00f3tona nesse exemplo quando o vetor est\u00e1 ordenado, por isso a busca bin\u00e1ria s\u00f3 \u00e9 feita em vetores ordenados. Como encontrar o menor valor que torna check verdadeiro? R. inicia-se o processo \"chutanto\" um intervalo onde a resposta com certeza estar\u00e1. Para cada intevalo, checa-se o meio e, dependendo da resposta, descarta-se os elementos a direita ou a esquerda, mas sempre divide-se o tamanho do intervalo por 2, at\u00e9 que o intervalo tenha tamanho 1. Veja uma solu\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int l = a ; // sei que a resposta n\u00e3o \u00e9 menos que a int r = b ; // sei que a resposta n\u00e3o \u00e9 mais que b while ( r > l + 1 ){ // repita enquanto o intervalo tiver tamanho > 2 int mid = l + ( r - l ) / 2 ; if ( check ( mid )){ // mid \u00e9 v\u00e1lido r = mid ; // como queremos minimizar a resposta, e mid \u00e9 uma resposta v\u00e1lida //descartamos tudo a direita de mid (mas n\u00e3o mid) } else { l = mid + 1 ; // Se mid n\u00e3o \u00e9 v\u00e1lido, descartamos ele e tudo abaixo. } } // Ao final desse la\u00e7o, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent\u00e3o se l for v\u00e1lido, // ficaremos com l, e caso contr\u00e1rio, com r int ans = r ; if ( check ( l )) ans = l ; Exemplo: Encontrar o maior valor de \\(x \\in [0, 10]\\) tal que \\(x^2 \\leq 30\\) . 1 2 3 4 5 6 7 8 9 10 11 12 bool check ( int val ) { return val * val <= 30 ; } int lastTrue ( int ini , int fim ) { ini -- ; // Se nenhum valor no intervalor for true, retorna ini - 1 while ( ini < fim ) { int m = ini + ( fim - ini ) / 2 ; if ( check ( m )) ini = m ; // (1) else fim = m - 1 ; // (2) } return ini ; } Se check ( m ) \u00e9 true , ent\u00e3o todos os n\u00fameros menores que m tamb\u00e9m ser\u00e3o true . Se check ( m ) \u00e9 false , ent\u00e3o todos os n\u00fameros maiores que m tamb\u00e9m ser\u00e3o false . Two-Pointers Na t\u00e9cnica chamada Two-Pointers dois \"aponstadores\" caminham pelo vetor. Normalmente, esses apontadores s\u00e3o ``colocados'' nas extremidades opostas do vetor e caminham um em dire\u00e7\u00e3o ao outro, como mostra a figura abaixo. Fonte: AfterAcademy Voc\u00ea consegue pensar em como usar esse t\u00e9cnica para resolver o problema de inverter os elementos de um vetor sem usar um vetor auxiliar? A ideia \u00e9 simples: coloque cada apontador (digamos i e j ) em uma extremidade do vetor, ou seja, i = 0 e j = n - 1 , e, a cada itera\u00e7\u00e3o, troque os elementos que est\u00e3o nas posi\u00e7\u00f5es i e j (ou seja, v[i] <-> v[j] ). Ap\u00f3s a troca, incremente o apontador i e decremente o apontador j . Repita esse processo enquanto i < j . A figura abaixo ilustra parte desse processo. Fonte: AfterAcademy O c\u00f3digo abaixo ilustra essa estrat\u00e9gia (note a simplicidade): 1 2 3 4 5 6 7 8 9 void inverte ( vector < int > & v ) { // (1) int i = 0 ; int j = v . size () - 1 ; while ( i < j ) { swap ( v [ i ], v [ j ]); // (2) i ++ ; j -- ; } } A std::reverse tamb\u00e9m pode ser usada com o mesmo objetivo. O intuito \u00e9 mostrar com a t\u00e9cnica Two-Pointers funciona. std::swap Complemente sua leitura e seu conhecimento: Two Pointers Method (ITMO Academy) \ud83e\udd2f Two Pointers Technique What is the Two pointer technique? O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9 Conte\u00fado extra\u00eddo de Busca Bin\u00e1ria \u21a9","title":"Ordena\u00e7\u00e3o e Busca[^1]"},{"location":"ordenacao_e_busca/#ordenacao-e-busca1","text":"","title":"Ordena\u00e7\u00e3o e Busca1"},{"location":"ordenacao_e_busca/#ordenacao","text":"A maioria das linguagens de programa\u00e7\u00e3o modernas implementa uma fun\u00e7\u00e3o de ordena\u00e7\u00e3o eficiente. Em C++, tem-se a fun\u00e7\u00e3o sort da biblioteca <algorithm> . Veja alguns exemplos de uso desta fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 int n = 7 ; int a [] = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( a , a + n ); // (1) vector < int > v = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( v . begin (), v . end ()); // (2) vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . begin (), alunos . end ()); // (3) for ( auto a : alunos ) cout << a . first << \" \" << a . second << endl ; // (4) [2, 3, 3, 4, 5, 5, 8] [2, 3, 3, 4, 5, 5, 8] Por padr\u00e3o, um pair sempre \u00e9 ordenado pelo campo first . {123, Paulo} {456, Ana} {789, Paulo} A ordena\u00e7\u00e3o padr\u00e3o \u00e9 a n\u00e3o-decrescente, mas pode-se obter a ordem inversa da seguinte forma: 1 2 3 4 vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . rbegin (), alunos . rend ()); for ( auto a : alunos ) // (1) cout << a . first << \" \" << a . second << endl ; {789, Paulo} {456, Ana} {123, Paulo} Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Agora suponha que seja necess\u00e1rio ordenar objetos do tipo Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ // (1) this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; Construtor padr\u00e3o usado quando n\u00e3o passamos nenhum argumento para a classe. Sempre fa\u00e7a o construtor padr\u00e3o. Caso contr\u00e1rio, n\u00e3o ser\u00e1 possivel fazer, por exemplo: Pessoa p ; //Chama o construtor padr\u00e3o . Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < .","title":"Ordena\u00e7\u00e3o"},{"location":"ordenacao_e_busca/#usando-uma-funcao-de-comparacao","text":"A primeira alternativa \u00e9 definir uma fun\u00e7\u00e3o que compara dois objetos e retorna true caso o primeiro seja considerado menor que o segundo e false , caso contr\u00e1rio. Por exemplo, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool compara ( const Pessoa & p1 , const Pessoa & p2 ) { // (1) if ( p1 . nome < p2 . nome ) return true ; else if ( p1 . nome == p2 . nome ) { if ( p1 . sobrenome < p2 . sobrenome ) return true ; else if ( p1 . sobrenome == p2 . sobrenome ) return p1 . idade > p2 . idade ; else return false ; } else return false ; } O const diz ao compilador que os objetos passados para a fun\u00e7\u00e3o n\u00e3o ser\u00e3o alterados internamento. J\u00e1 o & representa passagem por refer\u00eancia , uma alternativa a passagem por ponteiro . Dessa forma, n\u00e3o passamos uma c\u00f3pia dos objetos e sim refer\u00eancias (endere\u00e7os) dos mesmos, o que torna o c\u00f3digo mais eficiente. Por qu\u00ea? Com a fun\u00e7\u00e3o de compara\u00e7\u00e3o definida, basta pass\u00e1-la como argumento na fun\u00e7\u00e3o sort : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); // (1) lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end (), compara ); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Inclui o elemento no fim do vector . Leia mais sobre vector aqui . Usa a fun\u00e7\u00e3o compara para fazer a ordena\u00e7\u00e3o. Tamb\u00e9m \u00e9 possivel usar uma fun\u00e7\u00e3o lambda como fun\u00e7\u00e3o de compara\u00e7\u00e3o. Por exemplo, para ordenar um pair pelo campo second (ou usando-o como crit\u00e9rio de desempate), pode-se fazer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool compara ( const pair < int , int > & p1 , const pair < int , int > & p2 ) { if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; } int main () { vector < pair < int , int >> pontos = {{ 0 , 2 }, { 0 , 1 }, { 0 , 0 }, { 0 , -5 }, { 1 , 2 }, { -1 , 10 }}; sort ( pontos . begin (), pontos . end (), compara ); // (1) for ( auto a : pontos ) // (2) cout << \"(\" << a . first << \", \" << a . second << \") \" ; sort ( pontos . begin (), pontos . end (), []( const pair < int , int > & p1 , const pair < int , int > & p2 ) { // (3) if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; }); for ( auto a : pontos ) cout << \"(\" << a . first << \", \" << a . second << \") \" ; return 0 ; } Usando a fun\u00e7\u00e3o compara (-1, 10) (0, -5) (0, 0) (0, 1) (0, 2) (1, 2) Usando fun\u00e7\u00e3o lambda","title":"Usando uma fun\u00e7\u00e3o de compara\u00e7\u00e3o"},{"location":"ordenacao_e_busca/#fazando-a-sobrecarga-do-operador","text":"Ao inv\u00e9s de ser difinidas fun\u00e7\u00f5es de compara\u00e7\u00f5es, pode-se fazer a sobrecarga do operador < ( operator < ). Isso \u00e9 comum ao se usar class ou struct . Veja como ficaria ao ser considerado a classe Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } bool operator < ( const Pessoa & p ){ // (1) if ( nome < p . nome ) return true ; else if ( nome == p . nome ) { if ( sobrenome < p . sobrenome ) return true ; else if ( sobrenome == p . sobrenome ) return idade > p . idade ; else return false ; } else return false ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end ()); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Sobrecarga/defini\u00e7\u00e3o do operador < para a classe Pessoa . Dessa forma, \u00e9 possivel fazer a compara\u00e7\u00e3o p1 < p2 , considerando que p1 e p2 s\u00e3o objetos do tipo Pessoa . Usa o operador < para fazer a ordena\u00e7\u00e3o.","title":"Fazando a sobrecarga do operador &lt;"},{"location":"ordenacao_e_busca/#complemente-sua-leitura-e-seu-conhecimento","text":"Competitive Programmer\u2019s Handbook Sorting (CS Academy) std::sort std::partial_sort std::stable_sort std::nth_element","title":"Complemente sua leitura e seu conhecimento"},{"location":"ordenacao_e_busca/#busca","text":"","title":"Busca"},{"location":"ordenacao_e_busca/#busca-sequencial","text":"A forma mais intuitiva para procurar um elemento em um array \u00e9 usar um loop que percorre todos os elementos do array e parando assim que o elemento buscado \u00e9 encontrado. No pior caso, \u00e9 necess\u00e1rio percorrer todos os elementos, logo a complexidade ser\u00e1 \\(O(n)\\) . O c\u00f3digo abaixo verifica se x est\u00e1 no array : 1 2 3 4 5 for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] == x ) { // x encontrado na posi\u00e7\u00e3o i } } Em C++, pode-se usar a fun\u00e7\u00e3o search .","title":"Busca sequencial"},{"location":"ordenacao_e_busca/#busca-binaria","text":"Se os elementos do array estiverem ordenados, pode-se usar uma estrat\u00e9gia diferente e mais eficiente para realizar a busca: verifique se o elemento do meio do array \u00e9 o elementos buscado, se for, a busca termina. Caso n\u00e3o seja, verique se o elemento do meio \u00e9 menor que elemento buscaso, se for, repita o processo considerando apenas a segunda metade do array . Sen\u00e3o, considere a primeira metade do array . Assim, a cada passo da busca, o tamanho do array \u00e9 reduzido a metade, logo, a complexidade do algoritmo \u00e9 \\(O(\\log n)\\) . 1 2 3 4 5 6 7 8 9 10 int buscaBinaria ( vector < int > v , int x ) { int ini = 0 , fim = v . size () -1 ; while ( ini <= fim ) { int meio = ini + ( fim - ini ) / 2 ; // (1) if ( v [ meio ] == x ) return meio ; else if ( v [ meio ] < x ) ini = meio + 1 ; else fim = meio - 1 ; } return -1 ; // (2) } Evite usar meio = (ini + fim) / 2; , j\u00e1 que ini + fim pode gerar integer overflow . x n\u00e3o est\u00e1 no vetor v . Em C++, pode-se usar a fun\u00e7\u00e3o std::binary_search . As fun\u00e7\u00f5es abaixo tamb\u00e9m s\u00e3o \u00fateis e baseadas na busca bin\u00e1ria: std::lower_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 pelo menos x ; std::upper_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 maior que x ; As fun\u00e7\u00f5es assumem que o array est\u00e1 ordenado. Se o valor procurado n\u00e3o for encontrado, \u00e9 retornado um ponteiro para o elemento ap\u00f3s o \u00faltimo elemento do array . Por exemplo, o c\u00f3digo a seguir verifica se o array cont\u00e9m um elemento com valor x : 1 2 3 4 5 6 7 vector < int > v = { 1 , 2 , 3 , 5 , 8 , 10 , 20 }; int x = 10 ; auto k = lower_bound ( v . begin (), v . end (), x ); if ( k != v . end () && * k == x ) { // x encontrado no indice k cout << \"Valor encontrado na posi\u00e7\u00e3o: \" << k - v . begin () << endl ; // (1) } Pode-se usar a fun\u00e7\u00e3o std::distance ao inv\u00e9s de k - v.begin() , ou seja, distance(v.begin(), k) . Complemente sua leitura e seu conhecimento: Binary Search tutorial (C++ and Python) Busca Bin\u00e1ria Binary Search Binary Search (ITMO Academy) \ud83e\udd2f Binary Search (CS Academy)","title":"Busca bin\u00e1ria"},{"location":"ordenacao_e_busca/#busca-binaria-em-funcoes-monotonicas2","text":"Considere uma fun\u00e7\u00e3o booleana \\(f(x)\\) e se deseja encontrar o valor m\u00e1ximo (ou m\u00ednimo) de \\(x\\) tal que \\(f(x)\\) seja true . Da mesma forma que a busca bin\u00e1ria s\u00f3 funciona se o array estiver ordenado, s\u00f3 \u00e9 possivel aplicar a busca bin\u00e1ria em uma fun\u00e7\u00e3o mon\u00f3tona , ou seja, \u00e9 sempre n\u00e3o-decrescente ou sempre n\u00e3o-crescente. Seja check(x) uma fun\u00e7\u00e3o que verifica uma propriedade de x . Se para todo x , check ( x ) = true implica check ( x + 1 ) = true , ou para todo x , check ( x ) = false implica check ( x + 1 ) = false , ent\u00e3o a fun\u00e7\u00e3o check \u00e9 mon\u00f3tona. Suponha a fun\u00e7\u00e3o check abaixo que verifica se um elemento \u00e9 maior ou igual a x .. Se x = 11 e o vetor v = [1,2,3,5, 8, 11, 12, 14, 16] , ent\u00e3o teremos o seguinte vetor de sa\u00edda ao aplicarmos check em v : [0,0,0,0,0,1,1,1,1,1] . 1 2 3 bool check ( int val ) { return val >= x ; } Dessa forma, a fun\u00e7\u00e3o check para essa situa\u00e7\u00e3o \u00e9 mon\u00f3tona e isso \u00e9 relevante porque se um valor do vetor satisfizer a condi\u00e7\u00e3o, todos os valores a direita tamb\u00e9m v\u00e3o satisfaz\u00ea-la, e de forma an\u00e1loga, todos os valores a esquerda de um \u00edndice que n\u00e3o satisfaz a condi\u00e7\u00e3o, tamb\u00e9m n\u00e3o v\u00e3o satisfazer, e \u00e9 isso que nos permite aplicar busca bin\u00e1ria. Al\u00e9m disso, a fun\u00e7\u00e3o check s\u00f3 se torna mon\u00f3tona nesse exemplo quando o vetor est\u00e1 ordenado, por isso a busca bin\u00e1ria s\u00f3 \u00e9 feita em vetores ordenados. Como encontrar o menor valor que torna check verdadeiro? R. inicia-se o processo \"chutanto\" um intervalo onde a resposta com certeza estar\u00e1. Para cada intevalo, checa-se o meio e, dependendo da resposta, descarta-se os elementos a direita ou a esquerda, mas sempre divide-se o tamanho do intervalo por 2, at\u00e9 que o intervalo tenha tamanho 1. Veja uma solu\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int l = a ; // sei que a resposta n\u00e3o \u00e9 menos que a int r = b ; // sei que a resposta n\u00e3o \u00e9 mais que b while ( r > l + 1 ){ // repita enquanto o intervalo tiver tamanho > 2 int mid = l + ( r - l ) / 2 ; if ( check ( mid )){ // mid \u00e9 v\u00e1lido r = mid ; // como queremos minimizar a resposta, e mid \u00e9 uma resposta v\u00e1lida //descartamos tudo a direita de mid (mas n\u00e3o mid) } else { l = mid + 1 ; // Se mid n\u00e3o \u00e9 v\u00e1lido, descartamos ele e tudo abaixo. } } // Ao final desse la\u00e7o, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent\u00e3o se l for v\u00e1lido, // ficaremos com l, e caso contr\u00e1rio, com r int ans = r ; if ( check ( l )) ans = l ; Exemplo: Encontrar o maior valor de \\(x \\in [0, 10]\\) tal que \\(x^2 \\leq 30\\) . 1 2 3 4 5 6 7 8 9 10 11 12 bool check ( int val ) { return val * val <= 30 ; } int lastTrue ( int ini , int fim ) { ini -- ; // Se nenhum valor no intervalor for true, retorna ini - 1 while ( ini < fim ) { int m = ini + ( fim - ini ) / 2 ; if ( check ( m )) ini = m ; // (1) else fim = m - 1 ; // (2) } return ini ; } Se check ( m ) \u00e9 true , ent\u00e3o todos os n\u00fameros menores que m tamb\u00e9m ser\u00e3o true . Se check ( m ) \u00e9 false , ent\u00e3o todos os n\u00fameros maiores que m tamb\u00e9m ser\u00e3o false .","title":"Busca bin\u00e1ria em fun\u00e7\u00f5es monot\u00f4nicas2"},{"location":"ordenacao_e_busca/#two-pointers","text":"Na t\u00e9cnica chamada Two-Pointers dois \"aponstadores\" caminham pelo vetor. Normalmente, esses apontadores s\u00e3o ``colocados'' nas extremidades opostas do vetor e caminham um em dire\u00e7\u00e3o ao outro, como mostra a figura abaixo. Fonte: AfterAcademy Voc\u00ea consegue pensar em como usar esse t\u00e9cnica para resolver o problema de inverter os elementos de um vetor sem usar um vetor auxiliar? A ideia \u00e9 simples: coloque cada apontador (digamos i e j ) em uma extremidade do vetor, ou seja, i = 0 e j = n - 1 , e, a cada itera\u00e7\u00e3o, troque os elementos que est\u00e3o nas posi\u00e7\u00f5es i e j (ou seja, v[i] <-> v[j] ). Ap\u00f3s a troca, incremente o apontador i e decremente o apontador j . Repita esse processo enquanto i < j . A figura abaixo ilustra parte desse processo. Fonte: AfterAcademy O c\u00f3digo abaixo ilustra essa estrat\u00e9gia (note a simplicidade): 1 2 3 4 5 6 7 8 9 void inverte ( vector < int > & v ) { // (1) int i = 0 ; int j = v . size () - 1 ; while ( i < j ) { swap ( v [ i ], v [ j ]); // (2) i ++ ; j -- ; } } A std::reverse tamb\u00e9m pode ser usada com o mesmo objetivo. O intuito \u00e9 mostrar com a t\u00e9cnica Two-Pointers funciona. std::swap Complemente sua leitura e seu conhecimento: Two Pointers Method (ITMO Academy) \ud83e\udd2f Two Pointers Technique What is the Two pointer technique? O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9 Conte\u00fado extra\u00eddo de Busca Bin\u00e1ria \u21a9","title":"Two-Pointers"},{"location":"pd/","text":"Programa\u00e7\u00e3o Din\u00e2mica Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o din\u00e2mica"},{"location":"pd/#programacao-dinamica","text":"Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o Din\u00e2mica"},{"location":"strings/","text":"Processamento de Strings A resolu\u00e7\u00e3o de problemas envolvendo cadeia de caracteres (ou simplesmente strings ) se tornou um importante dom\u00ednio no estudo de algoritmos. Estes problemas ocorrem, principalmente, no processamento de texto, como verifica\u00e7\u00e3o ortogr\u00e1fica e busca de substrings espec\u00edficos ou de padr\u00f5es mais gerais ( pattern matching ). Por exemplo, o padr\u00e3o ABC ocorre duas vezes na string ABABCBABC . Nesta se\u00e7\u00e3o, diferente das outras, por simplicidade alguns algoritmos ser\u00e3o implementados (tamb\u00e9m) em Python. Leituras fortemente recomendadas: Strings Cap\u00edtulo 14 do livro \"Principles of Algorithmic Problem Solving\" Cap\u00edtulo 6 do livro \"Competitive Programming\" Cap\u00edtulo 26 do livro \"Competitive Programmer\u2019s Handbook\" Terminologia Uma substring \u00e9 uma sequ\u00eancia de caracteres consecutivos em uma string. Usa-se a nota\u00e7\u00e3o s[a...b] para se referir a uma substring de s que come\u00e7a na posi\u00e7\u00e3o a e termina na posi\u00e7\u00e3o b . Uma string de tamanho \\(n\\) tem \\(n ( n + 1)/2\\) substrings. Por exemplo, as substrings de ABCD s\u00e3o A , B , C , D , AB , BC , CD , ABC , BCD e ABCD . Uma subsequ\u00eancia \u00e9 uma sequ\u00eancia de caracteres (n\u00e3o necessariamente consecutivos) em uma string em sua ordem original. Uma string de tamanho \\(n\\) tem \\(2^n \u2212 1\\) subsequ\u00eancias. Por exemplo, as subsequ\u00eancias de ABCD s\u00e3o A , B , C , D , AB , AC , AD , BC , BD , CD , ABC , ABD , ACD , BCD e ABCD . Um prefixo \u00e9 uma substring que come\u00e7a no in\u00edcio de uma string e um sufixo \u00e9 uma substring que termina no final de uma string. Por exemplo, os prefixos de ABCD s\u00e3o A , AB , ABC e ABCD , e os sufixos de ABCD s\u00e3o D , CD , BCD e ABCD . Uma string \\(w\\) \u00e9 um anagrama de uma string \\(v\\) se existir uma permuta\u00e7\u00e3o das caracteres que transformam \\(w\\) em \\(v\\) . Por exemplo, os anagramas de alegria s\u00e3o alergia , alegrai , alergia , regalia , galeria . O c\u00f3digo abaixo ilustra uma forma de gerar todos os anagramas de uma lista de palavras. 1 2 3 4 5 6 7 8 9 10 11 def anagrama ( palavras ): d = {} # dicion\u00e1rio com a 'assinatura' das palavras for palavra in palavras : # agrupa as palavras de acordo com a assinatura s = '' . join ( sorted ( palavra )) # calcula a assinatura da palavra if s in d : d [ s ] . append ( palavra ) # adiciona a palavra a uma assinatura j\u00e1 existente else : d [ s ] = [ palavra ] # cria uma nova assinatura e adiciona sua primeira palavra # retorna os anagramas, ignorando grupos de tamanho 1 return [ d [ s ] for s in d if len ( d [ s ]) > 1 ] Express\u00e3o Regular Alguns problemas de processamento de string s\u00e3o facilmente resolvidos usando express\u00e3o regular (Regex). Tanto C++ quanto Python possuem bibliotecas para lidar com express\u00f5es regulares. Material complementar: Regular Expression Basics in C++ Regular Expressions: Regexes in Python (Part 1) Regular Expressions: Regexes in Python (Part 2) Express\u00f5es Regulares Processamento de String com Programa\u00e7\u00e3o Din\u00e2mica Dois problemas cl\u00e1ssicos de processamento de string que usam programa\u00e7\u00e3o din\u00e2mica s\u00e3o alinhamento de string (dist\u00e2ncia de edi\u00e7\u00e3o) e maior subsequ\u00eancia comum. Dist\u00e2ncia de Edi\u00e7\u00e3o O problema Dist\u00e2ncia de Edi\u00e7\u00e3o (tamb\u00e9m conhecido como Alinhamento de String ou Levenshtein Distance ) \u00e9 definido da seguinte forma: Dadas duas strings \\(x\\) e \\(y\\) , deseja-se saber o m\u00ednimo de opera\u00e7\u00f5es (inser\u00e7\u00e3o, exclus\u00e3o ou substitui\u00e7\u00e3o) que s\u00e3o necess\u00e1rias para transformar \\(x\\) em \\(y\\) . Por exemplo, a dist\u00e2ncia de edi\u00e7\u00e3o entre as palavras inglesas kitten e sitting \u00e9 3, j\u00e1 que com apenas 3 edi\u00e7\u00f5es conseguimos transformar uma palavra na outra e n\u00e3o h\u00e1 maneira de o fazer com menos de tr\u00eas edi\u00e7\u00f5es: kitten sitten (substitui\u00e7\u00e3o de 'k' por 's') sittin (substitui\u00e7\u00e3o de 'e' por 'i') sitting (inser\u00e7\u00e3o de 'g' no final) Uma primeira estrat\u00e9gia (ing\u00eanua) \u00e9 tentar, recursivamente, todas as possibilidades (inserir, remover, substituir): \\[ D(a, b, n, m) = \\begin{cases} n, & \\text{se $m = 0$}\\\\ m, & \\text{se $n = 0$}\\\\ D(a, b, n - 1, m - 1) & \\text{se $a[n - 1] = b[m - 1]$}\\\\ 1 + \\min \\begin{cases} D(a, b, n, m - 1) \\\\ D(a, b, n - 1, m) \\\\ D(a, b, n - 1, m - 1) \\end{cases} & \\text{caso contr\u00e1rio.} \\end{cases} \\] Um c\u00f3digo que implementa esta rela\u00e7\u00e3o de recorr\u00eancia ter\u00e1 complexidade \\(O(3^m)\\) . O pior caso acontece quando nenhum dos caracteres de duas strings s\u00e3o iguais. Neste caso, tem-se varias sobreposi\u00e7\u00f5es de subproblemas. Assim, usar programa\u00e7\u00e3o din\u00e2mica \u00e9 o melhor caminho. O c\u00f3digo abaixo (extraida daqui ) mostra uma implementa\u00e7\u00e3o do algoritmo de dist\u00e2ncia de edi\u00e7\u00e3o usando programa\u00e7\u00e3o din\u00e2mica. A complexidade do c\u00f3digo \u00e9 \\(O(nm)\\) . C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int min ( int x , int y , int z ) { return min ( min ( x , y ), z ); } int distanciaEdicao ( string & a , string & b ) { int n = a . size (), m = b . size (); int dp [ n + 1 ][ m + 1 ]; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ][ 0 ] = i ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i -1 ] != b [ j -1 ]) { dp [ i ][ j ] = 1 + min ( dp [ i -1 ][ j ], // Remover dp [ i ][ j -1 ], // Inserir dp [ i -1 ][ j -1 ]); // Substituir } else dp [ i ][ j ] = dp [ i -1 ][ j -1 ]; } } return dp [ n ][ m ]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def distanciaEdicao ( a , b ): n = len ( a ) m = len ( b ) dp = [[ 0 for x in range ( m + 1 )] for x in range ( n + 1 )] for i in range ( n + 1 ): for j in range ( m + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i elif a [ i - 1 ] != b [ j - 1 ]: dp [ i ][ j ] = 1 + min ( dp [ i - 1 ][ j ], # Remover dp [ i ][ j - 1 ], # Inserir dp [ i - 1 ][ j - 1 ]) # Substituir else : dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] return dp [ n ][ m ] Os links abaixo s\u00e3o fundamentais para entender melhor como o algoritmo funciona. Edit Distance (GeeksforGeeks) Definion of Minimum Edit Distance Maior Subsequ\u00eancia Comum O problema da Maior Subsequ\u00eancia Comum ( Longest Common Subsequence - LCS) \u00e9 definido da seguinte forma: Dadas duas strings \\(A\\) e \\(B\\) , qual \u00e9 a subsequ\u00eancia comum mais longa entre elas. Lembrando que uma subsequ\u00eancia \u00e9 uma sequ\u00eancia que aparece na mesma ordem relativa, mas n\u00e3o necessariamente consecutiva. Por exemplo, A = \"ACAATCC\" e B = \"AGCATGC\" t\u00eam LCS de comprimento 5, ou seja, \"ACATC\" . O c\u00f3digo abaixo (extraida daqui ) mostra uma implementa\u00e7\u00e3o do algoritmo para encontrar o tamanho da maior subsequ\u00eancia comum usando programa\u00e7\u00e3o din\u00e2mica. A complexidade do c\u00f3digo \u00e9 \\(O(nm)\\) . C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lcs ( string & a , string & b ) { int n = a . size (), m = b . size (); int dp [ n + 1 ][ m + 1 ] = { 0 }; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ]) dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 ; else dp [ i + 1 ][ j + 1 ] = max ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j ]); } } return dp [ n ][ m ]; // O c\u00f3digo em Python mostra como gerar a string contendo o LCS. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def lcs ( a , b ): n = len ( a ) m = len ( b ) dp = [[ 0 for x in range ( m + 1 )] for x in range ( n + 1 )] for i in range ( n ): for j in range ( m ): if a [ i ] == b [ j ]: dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 else : dp [ i + 1 ][ j + 1 ] = max ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j ]) # Gera a solu\u00e7\u00e3o. # Caso precise apenas do tamanho do string, basta retornar dp[n][m] sol = [] i , j = n , m while dp [ i ][ j ] > 0 : if dp [ i ][ j ] == dp [ i - 1 ][ j ]: i -= 1 elif dp [ i ][ j ] == dp [ i ][ j - 1 ]: j -= 1 else : i -= 1 j -= 1 sol . append ( a [ i ]) return \"\" . join ( sol [:: - 1 ]) Os links abaixo s\u00e3o fundamentais para entender melhor como o algoritmo funciona. Longest Common Subsequence (GeeksforGeeks) Longest common subsequence Busca em String (String Matching) Busca em string (tamb\u00e9m conhecido como string matching ) \u00e9 um problema de encontrar o indice (ou indices) de uma dada (sub)string (chamada de padr\u00e3o P ) de uma string (chamada de texto T ). Por exemplo, considerando que T = \"STEVEN EVENT\" . Se P = \"EVE\" , ent\u00e3o as respostas s\u00e3o os indices 2 e 7. Se P = \"EVENT\" , ent\u00e3o a resposta \u00e9 apenas o \u00edndice 7. Se P = \"EVENING\" , ent\u00e3o o algoritmo deve retornar que n\u00e3o encontrou o padr\u00e3o P no texto T . Um algoritmo ing\u00eanuo (veja abaixo) consegue resolver esse problema com complexidade \\(O(nm)\\) , onde \\(n\\) \u00e9 o tamanho do texto T e \\(m\\) o tamanho de padr\u00e3o P . 1 2 3 4 5 6 7 8 9 10 11 12 13 void busca ( string & T , string & P ) { int n = T . size (), m = P . size (); for ( int i = 0 ; i < n - m ; ++ i ) { bool achou = true ; for ( int j = 0 ; j < m ; ++ j ) if ( T [ i + j ] != P [ j ]) { achou = false ; break ; } if ( achou ) cout << \"P encontrado no indice \" << i << endl ; } } Com o intuito de melhorar a complexidade do algoritmo anterior, Knuth, Morris e Pratt propuseram um algoritmo mais eficiente (chamado de KMP Algorithm ) que faz uso das informa\u00e7\u00f5es obtidas nas compara\u00e7\u00f5es dos caracteres anteriores, especialmente aqueles que s\u00e3o iguais. Este link mostra uma anima\u00e7\u00e3o do funcionamento do Algoritmo KMP. Voc\u00ea pode encontrar a implementa\u00e7\u00e3o e a explica\u00e7\u00e3o detalhada do algoritmo KMP aqui , aqui e aqui . Os links abaixo detalham mais sobre busca em string e explicam outros algoritmos n\u00e3o descritos aqui. \u2b50\ufe0f KMP Algorithm for Pattern Searching (GeeksforGeeks) \u2b50\ufe0f Strings \u2b50\ufe0f Applications of String Matching Algorithms (GeeksforGeeks) \u2b50\ufe0f String Matching \u2b50\ufe0f Algoritmo KMP para busca de substring Aho-Corasick Algorithm for Pattern Searching (GeeksforGeeks) Rabin-Karp Algorithm for Pattern Searching (GeeksforGeeks) Prefix function. Knuth\u2013Morris\u2013Pratt algorithm String-searching algorithm Trie (GeeksforGeeks) String Hashing Em constru\u00e7\u00e3o... Array de Sufixo Basicamente, array de sufixo ( Suffix Array ) \u00e9 um array que cont\u00e9m inteiros indicando os \u00edndices iniciais dos sufixos de uma determinada string, ap\u00f3s os sufixos serem ordenados. Lembrando que o \\(i\\) -\u00e9simo sufixo de uma string \\(s\\) de tamanho \\(n\\) \u00e9 a substring \\(s[i\u2026n\u22121]\\) . Por exemplo, os sufixos de S = \"banana\" s\u00e3o: \\[ \\begin{array}{|c|l|} \\hline i & \\textbf{sufixo} \\\\ \\hline 0 & banana \\\\ 1 & anana \\\\ 2 & nana \\\\ 3 & ana \\\\ 4 & na \\\\ 5 & a \\\\ \\hline \\end{array} \\] Ap\u00f3s de ordenar essas strings, tem-se: \\[ \\begin{array}{|c|l|} \\hline i & \\textbf{sufixo} \\\\ \\hline 5 & a \\\\ 3 & ana \\\\ 1 & anana \\\\ 0 & banana \\\\ 4 & na \\\\ 2 & nana \\\\ \\hline \\end{array} \\] Portanto, o array de sufixos de \\(S\\) ser\u00e1 \\([5, 3, 1, 0, 4, 2]\\) . Um m\u00e9todo simples para construir um array de sufixos \u00e9 fazer um array de todos os sufixos e ent\u00e3o ordenar o array. O c\u00f3digo abaixo ilustra este procedimento. C++ Python 1 2 3 4 5 6 7 8 9 char S [] = \"banana\" ; ll n = strlen ( S ); vi SA ( n ); iota ( SA . begin (), SA . end (), 0 ); sort ( SA . begin (), SA . end (), [ & ]( int a , int b ) { // o & permite o acesso a vari\u00e1vel externa S return strcmp ( S + a , S + b ) < 0 ; }); for ( auto i : SA ) cout << i << endl ; 1 2 3 4 S = \"banana\" SA = [( i , S [ i :]) for i in range ( len ( S ))] SA . sort ( key = lambda x : x [ 1 ]) print ( SA ) A ordena\u00e7\u00e3o possui complexidade \\(O(n \\log \u2061n)\\) e como comparar duas strings \u00e9 \\(O(n)\\) , a complexidade final do algoritmo ser\u00e1 \\(O(n^2 \\log \u2061n)\\) . Pode-se melhor esta complexidade alterando o m\u00e9todo de ordena\u00e7\u00e3o (usando Radix Sort , por exemplo). Essa vers\u00e3o otimizada ter\u00e1 complexidade \\(O(n \\log n)\\) . Voc\u00ea pode encontrar a explica\u00e7\u00e3o e implementa\u00e7\u00e3o aqui , aqui e aqui . Os links abaixo exemplificam v\u00e1rias aplica\u00e7\u00f5es do array de sufixo: Applications of Suffix Array Suffix Array - Applications Suffix arrays \u2013 Applications in contest problems Material Complementar: \u2b50\ufe0f Suffix Array \ud83e\udd2f \u2b50\ufe0f Array de Sufixos \u2b50\ufe0f Suffix Array Suffix Array Suffix Array (TopCoder) Suffix arrays - a programming contest approach Palindromo Pal\u00edndromos s\u00e3o palavras ou frases que podem ser lidas da esquerda para a direita ou da direita para a esquerda. Por exemplo, ovo , radar , 123321 , a base do teto desaba , Socorram-me, subi no \u00f4nibus em Marrocos , anotaram a data da maratona . C++ Python 1 2 3 4 5 6 7 bool isPalindrome ( string & s , ll l , ll r ) { ll n = ( r - l ) + 1 ; FOR ( i , 0 , n / 2 ) if ( s [ l + i ] != s [ r - i ]) return false ; return true ; } 1 2 3 4 5 6 7 8 9 def isPalindrome ( s , l , r ): n = ( r - l ) + 1 for i in range ( n // 2 ): if s [ l + i ] != s [ r - i ]: return False ; return True #Ou usando fatiamento def isPalindrome ( s , l , r ): return s [ l : r + 1 ] == s [ l : r + 1 : - 1 ] Uma variante comum de problemas de pal\u00edndromos envolve contar o n\u00famero de substrings de uma string \\(s\\) que s\u00e3o pal\u00edndromos. Uma solu\u00e7\u00e3o ing\u00eanua (mostrada abaixo) faz uma busca completa com complexidade \\(O(n^3)\\) . C++ Python 1 2 3 4 5 6 7 8 int countPalindrome ( string & s ) { ll n = s . size (), resp = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( isPalindrome ( s , i , j )) ++ resp return resp ; } 1 2 3 4 5 6 7 8 def countPalindrome ( s ): n = len ( s ) resp = 0 for i in range ( n ): for j in range ( i + 1 , n ): if isPalindrome ( s , i , j ): resp += 1 return resp Perceba que muitos subproblemas (substrings) ser\u00e3o sobrepostos. Assim, pode-se criar uma matriz para armazenar o substring \\(s[l..r]\\) de forma que este substring s\u00f3 seja computado uma vez. Desta forma, teremos uma solu\u00e7\u00e3o que usa programa\u00e7\u00e3o din\u00e2mica com complexidade \\(O(n^2)\\) . Os c\u00f3digos abaixo (extraido daqui ) ilustram esta estrat\u00e9gia. C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int dp [ 1001 ][ 1001 ]; bool isPalindrome ( string & s , ll i , ll j ) { if ( i > j ) return 1 ; if ( dp [ i ][ j ] != -1 ) return dp [ i ][ j ]; if ( s [ i ] != s [ j ]) return dp [ i ][ j ] = 0 ; return dp [ i ][ j ] = isPalindrome ( s , i + 1 , j - 1 ); } int countPalindromes ( string & s ) { ll n = s . size (), resp = 0 ; memset ( dp , -1 , sizeof ( dp )); for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( isPalindrome ( s , i , j )) ++ resp return resp ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dp = [[ - 1 for i in range ( 1001 )] for j in range ( 1001 )] def isPalindrome ( s , i , j ): if i > j : return 1 if dp [ i ][ j ] != - 1 : return dp [ i ][ j ] dp [ i ][ j ] = 0 if s [ i ] == s [ j ]: dp [ i ][ j ] = isPalindrome ( s , i + 1 , j - 1 ) return dp [ i ][ j ] def countPalindromes ( s ): n = len ( s ) resp = 0 for i in range ( n ): for j in range ( i + 1 , n ): if isPalindrome ( s , i , j ): resp += 1 return resp Outro problema comum \u00e9 encontrar o maior palindromo que pode ser gerado deletando zero ou mais caracteres de uma string. Por exemplo: \"ADAM\" -> \"ADA\" (tamanho 3, deletando \"M\" ), \"RACEF1CARFAST\" -> \"RACECAR\" (tamanho 7, deletando \"F1\" e \"FAST\" ). Novamente, a solu\u00e7\u00e3o desse problema pode ser obtida usando programa\u00e7\u00e3o din\u00e2mica: Seja \\(len(l, r)\\) o tamanho do maior palindromo da string \\(S[l..r]\\) . Casos bases: Se \\(l = r\\) , ent\u00e3o \\(len(l, r) = 1\\) ; Se \\(l + 1 = r\\) , ent\u00e3o \\(len(l, r) = 2\\) se \\(S[l] = S[r]\\) ou 1, caso contr\u00e1rio. Recorrencia: Se \\(S[l] = S[r]\\) , ent\u00e3o \\(len(l, r) = 2 + len(l + 1, r - 1)\\) ; Sen\u00e3o, \\(len(l, r) = \\max(len(l, r - 1), len(l + 1, r))\\) Material Complementar: Manacher's Algorithm Manacher's Algorithm - Finding all sub-palindromes in \\(O(n)\\) Manacher's algorithm and code readability Palindromic tree: behind the scenes Palindromic tree","title":"Processamento de strings"},{"location":"strings/#processamento-de-strings","text":"A resolu\u00e7\u00e3o de problemas envolvendo cadeia de caracteres (ou simplesmente strings ) se tornou um importante dom\u00ednio no estudo de algoritmos. Estes problemas ocorrem, principalmente, no processamento de texto, como verifica\u00e7\u00e3o ortogr\u00e1fica e busca de substrings espec\u00edficos ou de padr\u00f5es mais gerais ( pattern matching ). Por exemplo, o padr\u00e3o ABC ocorre duas vezes na string ABABCBABC . Nesta se\u00e7\u00e3o, diferente das outras, por simplicidade alguns algoritmos ser\u00e3o implementados (tamb\u00e9m) em Python. Leituras fortemente recomendadas: Strings Cap\u00edtulo 14 do livro \"Principles of Algorithmic Problem Solving\" Cap\u00edtulo 6 do livro \"Competitive Programming\" Cap\u00edtulo 26 do livro \"Competitive Programmer\u2019s Handbook\"","title":"Processamento de Strings"},{"location":"strings/#terminologia","text":"Uma substring \u00e9 uma sequ\u00eancia de caracteres consecutivos em uma string. Usa-se a nota\u00e7\u00e3o s[a...b] para se referir a uma substring de s que come\u00e7a na posi\u00e7\u00e3o a e termina na posi\u00e7\u00e3o b . Uma string de tamanho \\(n\\) tem \\(n ( n + 1)/2\\) substrings. Por exemplo, as substrings de ABCD s\u00e3o A , B , C , D , AB , BC , CD , ABC , BCD e ABCD . Uma subsequ\u00eancia \u00e9 uma sequ\u00eancia de caracteres (n\u00e3o necessariamente consecutivos) em uma string em sua ordem original. Uma string de tamanho \\(n\\) tem \\(2^n \u2212 1\\) subsequ\u00eancias. Por exemplo, as subsequ\u00eancias de ABCD s\u00e3o A , B , C , D , AB , AC , AD , BC , BD , CD , ABC , ABD , ACD , BCD e ABCD . Um prefixo \u00e9 uma substring que come\u00e7a no in\u00edcio de uma string e um sufixo \u00e9 uma substring que termina no final de uma string. Por exemplo, os prefixos de ABCD s\u00e3o A , AB , ABC e ABCD , e os sufixos de ABCD s\u00e3o D , CD , BCD e ABCD . Uma string \\(w\\) \u00e9 um anagrama de uma string \\(v\\) se existir uma permuta\u00e7\u00e3o das caracteres que transformam \\(w\\) em \\(v\\) . Por exemplo, os anagramas de alegria s\u00e3o alergia , alegrai , alergia , regalia , galeria . O c\u00f3digo abaixo ilustra uma forma de gerar todos os anagramas de uma lista de palavras. 1 2 3 4 5 6 7 8 9 10 11 def anagrama ( palavras ): d = {} # dicion\u00e1rio com a 'assinatura' das palavras for palavra in palavras : # agrupa as palavras de acordo com a assinatura s = '' . join ( sorted ( palavra )) # calcula a assinatura da palavra if s in d : d [ s ] . append ( palavra ) # adiciona a palavra a uma assinatura j\u00e1 existente else : d [ s ] = [ palavra ] # cria uma nova assinatura e adiciona sua primeira palavra # retorna os anagramas, ignorando grupos de tamanho 1 return [ d [ s ] for s in d if len ( d [ s ]) > 1 ]","title":"Terminologia"},{"location":"strings/#expressao-regular","text":"Alguns problemas de processamento de string s\u00e3o facilmente resolvidos usando express\u00e3o regular (Regex). Tanto C++ quanto Python possuem bibliotecas para lidar com express\u00f5es regulares. Material complementar: Regular Expression Basics in C++ Regular Expressions: Regexes in Python (Part 1) Regular Expressions: Regexes in Python (Part 2) Express\u00f5es Regulares","title":"Express\u00e3o Regular"},{"location":"strings/#processamento-de-string-com-programacao-dinamica","text":"Dois problemas cl\u00e1ssicos de processamento de string que usam programa\u00e7\u00e3o din\u00e2mica s\u00e3o alinhamento de string (dist\u00e2ncia de edi\u00e7\u00e3o) e maior subsequ\u00eancia comum.","title":"Processamento de String com Programa\u00e7\u00e3o Din\u00e2mica"},{"location":"strings/#distancia-de-edicao","text":"O problema Dist\u00e2ncia de Edi\u00e7\u00e3o (tamb\u00e9m conhecido como Alinhamento de String ou Levenshtein Distance ) \u00e9 definido da seguinte forma: Dadas duas strings \\(x\\) e \\(y\\) , deseja-se saber o m\u00ednimo de opera\u00e7\u00f5es (inser\u00e7\u00e3o, exclus\u00e3o ou substitui\u00e7\u00e3o) que s\u00e3o necess\u00e1rias para transformar \\(x\\) em \\(y\\) . Por exemplo, a dist\u00e2ncia de edi\u00e7\u00e3o entre as palavras inglesas kitten e sitting \u00e9 3, j\u00e1 que com apenas 3 edi\u00e7\u00f5es conseguimos transformar uma palavra na outra e n\u00e3o h\u00e1 maneira de o fazer com menos de tr\u00eas edi\u00e7\u00f5es: kitten sitten (substitui\u00e7\u00e3o de 'k' por 's') sittin (substitui\u00e7\u00e3o de 'e' por 'i') sitting (inser\u00e7\u00e3o de 'g' no final) Uma primeira estrat\u00e9gia (ing\u00eanua) \u00e9 tentar, recursivamente, todas as possibilidades (inserir, remover, substituir): \\[ D(a, b, n, m) = \\begin{cases} n, & \\text{se $m = 0$}\\\\ m, & \\text{se $n = 0$}\\\\ D(a, b, n - 1, m - 1) & \\text{se $a[n - 1] = b[m - 1]$}\\\\ 1 + \\min \\begin{cases} D(a, b, n, m - 1) \\\\ D(a, b, n - 1, m) \\\\ D(a, b, n - 1, m - 1) \\end{cases} & \\text{caso contr\u00e1rio.} \\end{cases} \\] Um c\u00f3digo que implementa esta rela\u00e7\u00e3o de recorr\u00eancia ter\u00e1 complexidade \\(O(3^m)\\) . O pior caso acontece quando nenhum dos caracteres de duas strings s\u00e3o iguais. Neste caso, tem-se varias sobreposi\u00e7\u00f5es de subproblemas. Assim, usar programa\u00e7\u00e3o din\u00e2mica \u00e9 o melhor caminho. O c\u00f3digo abaixo (extraida daqui ) mostra uma implementa\u00e7\u00e3o do algoritmo de dist\u00e2ncia de edi\u00e7\u00e3o usando programa\u00e7\u00e3o din\u00e2mica. A complexidade do c\u00f3digo \u00e9 \\(O(nm)\\) . C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int min ( int x , int y , int z ) { return min ( min ( x , y ), z ); } int distanciaEdicao ( string & a , string & b ) { int n = a . size (), m = b . size (); int dp [ n + 1 ][ m + 1 ]; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ][ 0 ] = i ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i -1 ] != b [ j -1 ]) { dp [ i ][ j ] = 1 + min ( dp [ i -1 ][ j ], // Remover dp [ i ][ j -1 ], // Inserir dp [ i -1 ][ j -1 ]); // Substituir } else dp [ i ][ j ] = dp [ i -1 ][ j -1 ]; } } return dp [ n ][ m ]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def distanciaEdicao ( a , b ): n = len ( a ) m = len ( b ) dp = [[ 0 for x in range ( m + 1 )] for x in range ( n + 1 )] for i in range ( n + 1 ): for j in range ( m + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i elif a [ i - 1 ] != b [ j - 1 ]: dp [ i ][ j ] = 1 + min ( dp [ i - 1 ][ j ], # Remover dp [ i ][ j - 1 ], # Inserir dp [ i - 1 ][ j - 1 ]) # Substituir else : dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] return dp [ n ][ m ] Os links abaixo s\u00e3o fundamentais para entender melhor como o algoritmo funciona. Edit Distance (GeeksforGeeks) Definion of Minimum Edit Distance","title":"Dist\u00e2ncia de Edi\u00e7\u00e3o"},{"location":"strings/#maior-subsequencia-comum","text":"O problema da Maior Subsequ\u00eancia Comum ( Longest Common Subsequence - LCS) \u00e9 definido da seguinte forma: Dadas duas strings \\(A\\) e \\(B\\) , qual \u00e9 a subsequ\u00eancia comum mais longa entre elas. Lembrando que uma subsequ\u00eancia \u00e9 uma sequ\u00eancia que aparece na mesma ordem relativa, mas n\u00e3o necessariamente consecutiva. Por exemplo, A = \"ACAATCC\" e B = \"AGCATGC\" t\u00eam LCS de comprimento 5, ou seja, \"ACATC\" . O c\u00f3digo abaixo (extraida daqui ) mostra uma implementa\u00e7\u00e3o do algoritmo para encontrar o tamanho da maior subsequ\u00eancia comum usando programa\u00e7\u00e3o din\u00e2mica. A complexidade do c\u00f3digo \u00e9 \\(O(nm)\\) . C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int lcs ( string & a , string & b ) { int n = a . size (), m = b . size (); int dp [ n + 1 ][ m + 1 ] = { 0 }; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] == b [ j ]) dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 ; else dp [ i + 1 ][ j + 1 ] = max ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j ]); } } return dp [ n ][ m ]; // O c\u00f3digo em Python mostra como gerar a string contendo o LCS. } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def lcs ( a , b ): n = len ( a ) m = len ( b ) dp = [[ 0 for x in range ( m + 1 )] for x in range ( n + 1 )] for i in range ( n ): for j in range ( m ): if a [ i ] == b [ j ]: dp [ i + 1 ][ j + 1 ] = dp [ i ][ j ] + 1 else : dp [ i + 1 ][ j + 1 ] = max ( dp [ i ][ j + 1 ], dp [ i + 1 ][ j ]) # Gera a solu\u00e7\u00e3o. # Caso precise apenas do tamanho do string, basta retornar dp[n][m] sol = [] i , j = n , m while dp [ i ][ j ] > 0 : if dp [ i ][ j ] == dp [ i - 1 ][ j ]: i -= 1 elif dp [ i ][ j ] == dp [ i ][ j - 1 ]: j -= 1 else : i -= 1 j -= 1 sol . append ( a [ i ]) return \"\" . join ( sol [:: - 1 ]) Os links abaixo s\u00e3o fundamentais para entender melhor como o algoritmo funciona. Longest Common Subsequence (GeeksforGeeks) Longest common subsequence","title":"Maior Subsequ\u00eancia Comum"},{"location":"strings/#busca-em-string-string-matching","text":"Busca em string (tamb\u00e9m conhecido como string matching ) \u00e9 um problema de encontrar o indice (ou indices) de uma dada (sub)string (chamada de padr\u00e3o P ) de uma string (chamada de texto T ). Por exemplo, considerando que T = \"STEVEN EVENT\" . Se P = \"EVE\" , ent\u00e3o as respostas s\u00e3o os indices 2 e 7. Se P = \"EVENT\" , ent\u00e3o a resposta \u00e9 apenas o \u00edndice 7. Se P = \"EVENING\" , ent\u00e3o o algoritmo deve retornar que n\u00e3o encontrou o padr\u00e3o P no texto T . Um algoritmo ing\u00eanuo (veja abaixo) consegue resolver esse problema com complexidade \\(O(nm)\\) , onde \\(n\\) \u00e9 o tamanho do texto T e \\(m\\) o tamanho de padr\u00e3o P . 1 2 3 4 5 6 7 8 9 10 11 12 13 void busca ( string & T , string & P ) { int n = T . size (), m = P . size (); for ( int i = 0 ; i < n - m ; ++ i ) { bool achou = true ; for ( int j = 0 ; j < m ; ++ j ) if ( T [ i + j ] != P [ j ]) { achou = false ; break ; } if ( achou ) cout << \"P encontrado no indice \" << i << endl ; } } Com o intuito de melhorar a complexidade do algoritmo anterior, Knuth, Morris e Pratt propuseram um algoritmo mais eficiente (chamado de KMP Algorithm ) que faz uso das informa\u00e7\u00f5es obtidas nas compara\u00e7\u00f5es dos caracteres anteriores, especialmente aqueles que s\u00e3o iguais. Este link mostra uma anima\u00e7\u00e3o do funcionamento do Algoritmo KMP. Voc\u00ea pode encontrar a implementa\u00e7\u00e3o e a explica\u00e7\u00e3o detalhada do algoritmo KMP aqui , aqui e aqui . Os links abaixo detalham mais sobre busca em string e explicam outros algoritmos n\u00e3o descritos aqui. \u2b50\ufe0f KMP Algorithm for Pattern Searching (GeeksforGeeks) \u2b50\ufe0f Strings \u2b50\ufe0f Applications of String Matching Algorithms (GeeksforGeeks) \u2b50\ufe0f String Matching \u2b50\ufe0f Algoritmo KMP para busca de substring Aho-Corasick Algorithm for Pattern Searching (GeeksforGeeks) Rabin-Karp Algorithm for Pattern Searching (GeeksforGeeks) Prefix function. Knuth\u2013Morris\u2013Pratt algorithm String-searching algorithm Trie (GeeksforGeeks)","title":"Busca em String (String Matching)"},{"location":"strings/#string-hashing","text":"Em constru\u00e7\u00e3o...","title":"String Hashing"},{"location":"strings/#array-de-sufixo","text":"Basicamente, array de sufixo ( Suffix Array ) \u00e9 um array que cont\u00e9m inteiros indicando os \u00edndices iniciais dos sufixos de uma determinada string, ap\u00f3s os sufixos serem ordenados. Lembrando que o \\(i\\) -\u00e9simo sufixo de uma string \\(s\\) de tamanho \\(n\\) \u00e9 a substring \\(s[i\u2026n\u22121]\\) . Por exemplo, os sufixos de S = \"banana\" s\u00e3o: \\[ \\begin{array}{|c|l|} \\hline i & \\textbf{sufixo} \\\\ \\hline 0 & banana \\\\ 1 & anana \\\\ 2 & nana \\\\ 3 & ana \\\\ 4 & na \\\\ 5 & a \\\\ \\hline \\end{array} \\] Ap\u00f3s de ordenar essas strings, tem-se: \\[ \\begin{array}{|c|l|} \\hline i & \\textbf{sufixo} \\\\ \\hline 5 & a \\\\ 3 & ana \\\\ 1 & anana \\\\ 0 & banana \\\\ 4 & na \\\\ 2 & nana \\\\ \\hline \\end{array} \\] Portanto, o array de sufixos de \\(S\\) ser\u00e1 \\([5, 3, 1, 0, 4, 2]\\) . Um m\u00e9todo simples para construir um array de sufixos \u00e9 fazer um array de todos os sufixos e ent\u00e3o ordenar o array. O c\u00f3digo abaixo ilustra este procedimento. C++ Python 1 2 3 4 5 6 7 8 9 char S [] = \"banana\" ; ll n = strlen ( S ); vi SA ( n ); iota ( SA . begin (), SA . end (), 0 ); sort ( SA . begin (), SA . end (), [ & ]( int a , int b ) { // o & permite o acesso a vari\u00e1vel externa S return strcmp ( S + a , S + b ) < 0 ; }); for ( auto i : SA ) cout << i << endl ; 1 2 3 4 S = \"banana\" SA = [( i , S [ i :]) for i in range ( len ( S ))] SA . sort ( key = lambda x : x [ 1 ]) print ( SA ) A ordena\u00e7\u00e3o possui complexidade \\(O(n \\log \u2061n)\\) e como comparar duas strings \u00e9 \\(O(n)\\) , a complexidade final do algoritmo ser\u00e1 \\(O(n^2 \\log \u2061n)\\) . Pode-se melhor esta complexidade alterando o m\u00e9todo de ordena\u00e7\u00e3o (usando Radix Sort , por exemplo). Essa vers\u00e3o otimizada ter\u00e1 complexidade \\(O(n \\log n)\\) . Voc\u00ea pode encontrar a explica\u00e7\u00e3o e implementa\u00e7\u00e3o aqui , aqui e aqui . Os links abaixo exemplificam v\u00e1rias aplica\u00e7\u00f5es do array de sufixo: Applications of Suffix Array Suffix Array - Applications Suffix arrays \u2013 Applications in contest problems Material Complementar: \u2b50\ufe0f Suffix Array \ud83e\udd2f \u2b50\ufe0f Array de Sufixos \u2b50\ufe0f Suffix Array Suffix Array Suffix Array (TopCoder) Suffix arrays - a programming contest approach","title":"Array de Sufixo"},{"location":"strings/#palindromo","text":"Pal\u00edndromos s\u00e3o palavras ou frases que podem ser lidas da esquerda para a direita ou da direita para a esquerda. Por exemplo, ovo , radar , 123321 , a base do teto desaba , Socorram-me, subi no \u00f4nibus em Marrocos , anotaram a data da maratona . C++ Python 1 2 3 4 5 6 7 bool isPalindrome ( string & s , ll l , ll r ) { ll n = ( r - l ) + 1 ; FOR ( i , 0 , n / 2 ) if ( s [ l + i ] != s [ r - i ]) return false ; return true ; } 1 2 3 4 5 6 7 8 9 def isPalindrome ( s , l , r ): n = ( r - l ) + 1 for i in range ( n // 2 ): if s [ l + i ] != s [ r - i ]: return False ; return True #Ou usando fatiamento def isPalindrome ( s , l , r ): return s [ l : r + 1 ] == s [ l : r + 1 : - 1 ] Uma variante comum de problemas de pal\u00edndromos envolve contar o n\u00famero de substrings de uma string \\(s\\) que s\u00e3o pal\u00edndromos. Uma solu\u00e7\u00e3o ing\u00eanua (mostrada abaixo) faz uma busca completa com complexidade \\(O(n^3)\\) . C++ Python 1 2 3 4 5 6 7 8 int countPalindrome ( string & s ) { ll n = s . size (), resp = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( isPalindrome ( s , i , j )) ++ resp return resp ; } 1 2 3 4 5 6 7 8 def countPalindrome ( s ): n = len ( s ) resp = 0 for i in range ( n ): for j in range ( i + 1 , n ): if isPalindrome ( s , i , j ): resp += 1 return resp Perceba que muitos subproblemas (substrings) ser\u00e3o sobrepostos. Assim, pode-se criar uma matriz para armazenar o substring \\(s[l..r]\\) de forma que este substring s\u00f3 seja computado uma vez. Desta forma, teremos uma solu\u00e7\u00e3o que usa programa\u00e7\u00e3o din\u00e2mica com complexidade \\(O(n^2)\\) . Os c\u00f3digos abaixo (extraido daqui ) ilustram esta estrat\u00e9gia. C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int dp [ 1001 ][ 1001 ]; bool isPalindrome ( string & s , ll i , ll j ) { if ( i > j ) return 1 ; if ( dp [ i ][ j ] != -1 ) return dp [ i ][ j ]; if ( s [ i ] != s [ j ]) return dp [ i ][ j ] = 0 ; return dp [ i ][ j ] = isPalindrome ( s , i + 1 , j - 1 ); } int countPalindromes ( string & s ) { ll n = s . size (), resp = 0 ; memset ( dp , -1 , sizeof ( dp )); for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( isPalindrome ( s , i , j )) ++ resp return resp ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dp = [[ - 1 for i in range ( 1001 )] for j in range ( 1001 )] def isPalindrome ( s , i , j ): if i > j : return 1 if dp [ i ][ j ] != - 1 : return dp [ i ][ j ] dp [ i ][ j ] = 0 if s [ i ] == s [ j ]: dp [ i ][ j ] = isPalindrome ( s , i + 1 , j - 1 ) return dp [ i ][ j ] def countPalindromes ( s ): n = len ( s ) resp = 0 for i in range ( n ): for j in range ( i + 1 , n ): if isPalindrome ( s , i , j ): resp += 1 return resp Outro problema comum \u00e9 encontrar o maior palindromo que pode ser gerado deletando zero ou mais caracteres de uma string. Por exemplo: \"ADAM\" -> \"ADA\" (tamanho 3, deletando \"M\" ), \"RACEF1CARFAST\" -> \"RACECAR\" (tamanho 7, deletando \"F1\" e \"FAST\" ). Novamente, a solu\u00e7\u00e3o desse problema pode ser obtida usando programa\u00e7\u00e3o din\u00e2mica: Seja \\(len(l, r)\\) o tamanho do maior palindromo da string \\(S[l..r]\\) . Casos bases: Se \\(l = r\\) , ent\u00e3o \\(len(l, r) = 1\\) ; Se \\(l + 1 = r\\) , ent\u00e3o \\(len(l, r) = 2\\) se \\(S[l] = S[r]\\) ou 1, caso contr\u00e1rio. Recorrencia: Se \\(S[l] = S[r]\\) , ent\u00e3o \\(len(l, r) = 2 + len(l + 1, r - 1)\\) ; Sen\u00e3o, \\(len(l, r) = \\max(len(l, r - 1), len(l + 1, r))\\) Material Complementar: Manacher's Algorithm Manacher's Algorithm - Finding all sub-palindromes in \\(O(n)\\) Manacher's algorithm and code readability Palindromic tree: behind the scenes Palindromic tree","title":"Palindromo"},{"location":"teorianumeros/","text":"Teoria dos N\u00fameros 1 Teoria dos N\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda os n\u00fameros inteiros. Dominar o maior n\u00famero poss\u00edvel de t\u00f3picos da teoria dos n\u00fameros \u00e9 importante, pois alguns problemas matem\u00e1ticos se tornam f\u00e1ceis (ou mais f\u00e1ceis) se voc\u00ea conhecer a teoria por tr\u00e1s do problema. Divisibilidade Um inteiro \\(n\\) \u00e9 divis\u00edvel por um inteiro \\(d\\) (denotado por \\(d | n\\) .) se houver outro inteiro \\(q\\) tal que \\(n = d \\times q\\) . Tamb\u00e9m \u00e9 dito que \\(d\\) \u00e9 um divisor de \\(n\\) . Dividindo os dois lados da igualdade \\(n = dq\\) por \\(d\\) tem-se uma defini\u00e7\u00e3o quase equivalente, ou seja, que \\(\\frac{n}{d}\\) \u00e9 um inteiro. Exemplo O n\u00famero 12 possui 6 divisores: \\(1~(1 \\times 12 = 12), 2~(2 \\times 6 = 12), 3~(3 \\times 4 = 12), 4~(4 \\times 3 = 12), 6~(6 \\times 6 = 12)\\) e \\(12~(12 \\times 1 = 12)\\) . O conceito de divisibilidade traz muitas quest\u00f5es. A primeira \u00e9 como verificar se um n\u00famero \u00e9 divis\u00edvel por outro. Para n\u00famero pequenos, que podem ser armazenados em vari\u00e1veis, por exemplo, do tipo long long , pode-se usar o operador m\u00f3dulo ou resto da divis\u00e3o ( % ): \\(n\\) \u00e9 divis\u00edvel por \\(d\\) se e somente se \u01f9 % d == 0 . Entretanto, para n\u00fameros inteiros grandes a solu\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples. Na Se\u00e7\u00e3o Aritm\u00e9tica Modular ser\u00e1 discutido como implementar o operador m\u00f3dulo para n\u00famero inteiros grandes. Outra quest\u00e3o \u00e9 como calcular os divisores de um n\u00famero. Todo inteiro \\(n\\) tem pelo menos dois divisores ( \\(1\\) e \\(n\\) ). Para encontrar os outros divisores, pode-se usar o fato que qualquer divisor \\(d\\) de \\(n\\) deve satisfazer \\(|d| \\leq |n|\\) . Assim, pode-se testar se os inteiros entre \\(1\\) e \\(n\\) s\u00e3o divisores de \\(n\\) , ou seja, um algoritmo \\(O(n)\\) . Entretanto, sempre que tem-se um divisor \\(d\\) , tem-se outro divisor \\(q\\) (veja o exemplo anterior). Por exemplo, ao afirmar que \\(3\\) \u00e9 um divisor de \\(12\\) , pois \\(3 \\times 4 = 12\\) , tem-se outro divisor, \\(4\\) . Ou seja, os divisores v\u00eam em pares. Veja outros exemplo: Exemplo O n\u00famero 16 possui 5 divisores: \\(1~(1 \\times 16 = 16), 2~(2 \\times 8 = 16), 4~(4 \\times 4 = 16), 8~(8 \\times 2 = 16)\\) e \\(16~(16 \\times 6 = 16)\\) . Dessa forma, pode-se limitar a encontrar cada elemento desses pares. Al\u00e9m disso, um dos valores de cada par deve ser limitado por \\(\\sqrt n\\) . Por qu\u00ea? Esse limite ajuda a reduzir a complexidade do algoritmo que encontra todos os divisores de um n\u00famero em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo retorna um vector com todos os divisores de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > divisores ( long long n ) { vector < long long > ans ; for ( long long a = 1 ; a * a <= n ; a ++ ) { // (1) if ( n % a == 0 ) { long long b = n / a ; ans . push_back ( a ); if ( a != b ) ans . push_back ( b ); } } return ans ; // (2) } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Em alguns casos, \u00e9 interessante ou necess\u00e1rio retornar os divisores ordenados Complemente sua leitura e seu conhecimento: Number of divisors / sum of divisors Divisibility Counting Divisors of a Number in \\(O(n^{\\frac{1}{3}})\\) How many divisors does a number have? N\u00fameros Primos Um n\u00famero inteiro \\(n > 1\\) \u00e9 chamado de n\u00famero primo se e somente se possui dois divisores: \\(1\\) e \\(n\\) . Um n\u00famero que n\u00e3o \u00e9 primo \u00e9 chamado de n\u00famero composto (veja a figura abaixo). O primeiro e \u00fanico n\u00famero primo par \u00e9 \\(2\\) . Os pr\u00f3ximos n\u00fameros primos s\u00e3o: \\(3, 5, 7, 11, 13, \\dots\\) . Como voc\u00ea deve imaginar, existe um n\u00famero infinito de primos (Veja a prova aqui ). N\u00fameros primos s\u00e3o os n\u00fameros naturais maiores que um que n\u00e3o s\u00e3o produtos de dois n\u00fameros naturais menores.(Fonte: Wikip\u00e9dia ) N\u00famero primo \u00e9 um t\u00f3pico importante da teoria dos n\u00fameros e a fonte de muitos problemas em programa\u00e7\u00f5es competitivas. Por isso \u00e9 de extrema import\u00e2ncia conhecer e dominar alguns algoritmos que envolvam n\u00fameros primos. Testes de Primalidade Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ent\u00e3o ele pode ser representado pelo produto de dois inteiros \\(a \\times b\\) , onde \\(a \\leq \\sqrt n\\) ou \\(b \\leq \\sqrt n\\) . Com isso, pode-se testar se um n\u00famero \u00e9 primo ou n\u00e3o e encontrar uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo verifica se um dado n\u00famero \\(n\\) \u00e9 primo ou n\u00e3o. 1 2 3 4 5 6 7 8 9 bool ehPrimo ( long long n ) { if ( n < 2 ) return false ; for ( long long x = 2 ; x * x <= n ; x ++ ) { // (1) if ( n % x == 0 ) return false ; } return true ; } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Ou, alternativamente: 1 2 3 4 5 6 7 8 9 10 bool isPrimeFast ( long long n ) { // (1) if ( n < 5 || n % 2 == 0 || n % 3 == 0 ) return ( n == 2 || n == 3 ); long long maxP = sqrt ( n ) + 2 ; for ( long long p = 5 ; p < maxP ; p += 6 ) { if ( p < n && n % p == 0 ) return false ; if ( p + 2 < n && n % ( p + 2 ) == 0 ) return false ; } return true ; } Fonte: primes.cpp Complemente sua leitura e seu conhecimento: Primality tests Decomposi\u00e7\u00e3o em fatores primos Todo n\u00famero positivo \\(n\\) possui uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos \u00fanica: uma forma de decompor \\(n\\) em um produto de n\u00fameros primos, ou seja: \\[ n = p_1^{a_1} \\times p_2^{a_2} \\times \\dots \\times p_k^{a_k}, \\] onde \\(p_i\\) s\u00e3o n\u00fameros primos distintos e \\(a_i\\) inteiros positivos. A fun\u00e7\u00e3o abaixo retorna um vector com a decomposi\u00e7\u00e3o em fatores primos de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > factor ( long long n ) { vector < long long > ans ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ans . push_back ( i ); n /= i ; } } if ( n > 1 ) ans . push_back ( n ); return ans ; } Note que cada fator primo aparece no vetor o n\u00famero de vezes que ele divide \\(n\\) . Por exemplo, \\(24 = 2^3 \\times 3\\) , ent\u00e3o o resultado da fun\u00e7\u00e3o \u00e9 \\([2,2,2,3]\\) . Complemente sua leitura e seu conhecimento: Integer factorization Primalidade e fatora\u00e7\u00e3o Crivo de Erat\u00f3stenes O Crivo de Erat\u00f3stenes \u00e9 um algoritmo para encontrar todos os n\u00fameros primos at\u00e9 um certo limite usando \\(O(n \\log \\log n)\\) opera\u00e7\u00f5es. A ideia do algoritmo \u00e9 a seguinte: inicialmente, escreve-se todos os n\u00fameros entre \\(2\\) e \\(n\\) . Ent\u00e3o, marca-se todos os m\u00faltiplos de \\(2\\) (j\u00e1 que \\(2\\) \u00e9 o menor n\u00famero primo). Em seguida, pega-se o pr\u00f3ximo valor que n\u00e3o foi marcado como composto, neste caso, \u00e9 o \\(3\\) . Isso significa que 3 \u00e9 primo. Ent\u00e3o, marca-se todos os m\u00faltiplos de 3 como compostos. O pr\u00f3ximo n\u00famero n\u00e3o marcado \u00e9 o \\(5\\) (pr\u00f3ximo n\u00famero primo). Marca-se todos os m\u00faltiplos de \\(5\\) . Este processo \u00e9 repetido at\u00e9 \\(n\\) . A anima\u00e7\u00e3o abaixo exemplifica a execu\u00e7\u00e3o do algoritmo para \\(n = 120\\) . Crivo de Erat\u00f3stenes: passos do algoritmo para primos abaixo de 121. (Fonte: Wikip\u00e9dia ) O c\u00f3digo abaixo exemplifica uma poss\u00edvel implementa\u00e7\u00e3o do algoritmo. Esse algoritmo possui complexidade \\(O(n \\log \\log n)\\) (veja a prova aqui ). 1 2 3 4 5 6 7 8 9 10 11 vector < bool > crivo ( long long n ) { vector < bool > primo ( n + 1 , true ); // (1) primo [ 0 ] = primo [ 1 ] = false ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( primo [ i ] && i * i <= n ) { for ( long long j = i * i ; j <= n ; j += i ) // (2) primo [ j ] = false ; } } return primo ; } Cria um array ( vector ) booleano de tamanho \\(n + 1\\) , onde todas as posi\u00e7\u00f5es s\u00e3o inicializadas com true . Iteramos por todos os n\u00fameros divis\u00edveis pelo primo i Complemente sua leitura e seu conhecimento: Sieve of Eratosthenes Linear Sieve Math note - linear sieve Primo de Mersenne N\u00famero de Mersenne \u00e9 todo n\u00famero natural da forma \\(M_{n}=2^{n}-1\\) , onde \\(n\\) \u00e9 um n\u00famero natural. Os primeiros n\u00fameros Mersenne s\u00e3o: \\(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\dots\\) . Um subconjunto particularmente interessante \u00e9 o constitu\u00eddo pelos n\u00fameros de Mersenne que s\u00e3o tamb\u00e9m primos: os primos de Mersenne . Note que nem todo n\u00famero de Mersenne \u00e9 primo, assim como nem todo n\u00famero primo \u00e9 de Mersenne. Os primeiros primos de Mersenne s\u00e3o: \\(M_2 = 3, M_3 = 7, M_5 = 31, M_7 = 127, M_13 = 8191, M_17 = 131071, M_19 = 524287, \\dots\\) Um resultado elementar sobre os n\u00fameros de Mersenne afirma que se \\(2^{n}-1\\) \u00e9 um n\u00famero primo, ent\u00e3o \\(n\\) tamb\u00e9m \u00e9 um n\u00famero primo. Algoritmo de Euclides (MDC/MMC) O m\u00e1ximo divisor comum (GCD, do ingl\u00eas greatest common divisor ) dos n\u00fameros \\(a\\) e \\(b\\) , gcd(a,b) , \u00e9 o maior n\u00famero que divide \\(a\\) e \\(b\\) , e o m\u00ednimo m\u00faltiplo comum (LCM, do ingl\u00eas least common multiple ) de \\(a\\) e \\(b\\) , lcm(a,b) , \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e \\(b\\) . O algoritmo de Euclides fornece uma maneira eficiente de encontrar o m\u00e1ximo divisor comum de dois n\u00fameros. O algoritmo \u00e9 baseado na seguinte defini\u00e7\u00e3o: \\[ \\gcd(a, b) = \\begin{cases}a,&\\text{se }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{caso contr\u00e1rio.}\\end{cases} \\] Usando essa defini\u00e7\u00e3o, o algoritmo \u00e9 facilmente implementado usando recurs\u00e3o: 1 2 3 4 5 6 long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Dica Voc\u00ea pode usar a fun\u00e7\u00e3o integrada __gcd(a, b) do C++. Pode-se mostrar que o algoritmo de Euclides possui complexidade \\(O(\\log n)\\) , onde \\(n = min(a,b)\\) . O m\u00ednimo m\u00faltiplo comum (LCM) pode ser calculado da seguinte forma: \\[ lcm(a, b) = \\frac{a \\times b}{gcd(a,b)} \\] Para calcular o GCD ou LCM de mais de dois valores, pode-se calcular o valor de dois em dois (em qualquer ordem). Por exemplo: \\[ gcd(a, b, c, d) = gcd(a, gcd(b, gcd(c, d))) \\] Fun\u00e7\u00e3o totiente de Euler A fun\u00e7\u00e3o totiente de Euler, tamb\u00e9m conhecida como fun\u00e7\u00e3o \\(\\phi (n)\\) , conta o n\u00famero de inteiros entre \\(1\\) e \\(n\\) , no qual s\u00e3o coprimos de \\(n\\) . Dois n\u00fameros s\u00e3o coprimos se o m\u00e1ximo divisor comum entre eles for 1 (1 \u00e9 considerado ser coprimo para qualquer n\u00famero). Por exemplo, \\(\\phi (12) = 4\\) , pois 1, 5, 7 e 11 s\u00e3o coprimos de 12. Abaixo est\u00e3o valores de \\(\\phi (n)\\) para os primeiros n\u00fameros inteiros positivos: \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\ \\hline \\end{array}\\] A fun\u00e7\u00e3o abaixo calcula o valor de \\(\\phi (n)\\) em \\(O(\\sqrt n)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 long long phi ( long long n ) { long long result = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Complemente sua leitura e seu conhecimento: Euclidean algorithm for computing the greatest common divisor Euler's totient function Aritm\u00e9tica Modular Na aritm\u00e9tica modular , o conjunto de n\u00fameros \u00e9 limitado de forma que apenas os n\u00fameros \\(0,1,2,\\dots,m\u22121\\) s\u00e3o usados, onde \\(m\\) \u00e9 uma constante. Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(x \\bmod m\\) : o resto da divis\u00e3o de \\(x\\) por \\(m\\) . Por exemplo, se \\(m = 23\\) , em vez \\(x = 247\\) , considera-se \\(x \\bmod 23 = 17\\) . Normalmente, \\(m\\) ser\u00e1 um primo grande, dado no problema, normalmente, \\(10^9 + 7\\) . A aritm\u00e9tica modular \u00e9 usada para evitar integer overflow . As seguintes propriedades valem no c\u00e1lculo do m\u00f3dulo: \\[(a+b) \\bmod m = (a \\bmod m + b \\bmod m) \\bmod m\\] \\[(a-b) \\bmod m = (a \\bmod m - b \\bmod m) \\bmod m\\] \\[(a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\] \\[a^b \\bmod {m} = (a \\bmod m)^b \\bmod m\\] O que significa que se a resposta est\u00e1 sendo computada por meio de adi\u00e7\u00f5es, subtra\u00e7\u00f5es e multiplica\u00e7\u00f5es, e no final voc\u00ea precisa tirar o m\u00f3dulo dela, voc\u00ea pode tirar o m\u00f3dulo em todas as opera\u00e7\u00f5es intermedi\u00e1rias que isso n\u00e3o afetar\u00e1 a resposta. Exponencia\u00e7\u00e3o Bin\u00e1ria A exponencia\u00e7\u00e3o bin\u00e1ria \u00e9 um truque que permite calcular \\(x^n\\) usando apenas multiplica\u00e7\u00f5es \\(O(\\log\u2061 n)\\) (em vez das multiplica\u00e7\u00f5es \\(O(n)\\) exigidas pela abordagem ing\u00eanua). Sabe-se que \\(x^a \\cdot x^b = x^{a+b}\\) . Em particular, \\(x^{2b} = x^b \\cdot x^b\\) . Logo, se o expoente \\(n\\) de \\(x^n\\) for par, pode-se dizer que \\(x^n = x^{\\frac{n}{2}} \\cdot x^{\\frac{n}{2}}\\) . No entanto, se \\(n\\) for \u00edmpar, tem-se algo similar: \\(x^n = x^{\\frac{n-1}{2}} \\cdot x^{\\frac{n-1}{2}} \\cdot x\\) . Dessa forma, pode-se montar a seguinte recorr\u00eancia: \\[ x^n = \\begin{cases} 1 &\\text{se } n = 0 \\\\ \\left(x^{\\frac{n}{2}}\\right)^2 &\\text{se } n \\text{ par}\\\\ \\left(x^{\\frac{n - 1}{2}}\\right)^2 \\cdot x &\\text{se } n \\text{ impar}\\\\ \\end{cases} \\] Note que se \\(n\\) for par, o valor \\(x^{n/2}\\) deve ser calculado apenas uma vez. Isso garante que a complexidade do algoritmo seja \\(O(\\log n)\\) . A fun\u00e7\u00e3o abaixo calcula do valor de \\(x^n\\) : 1 2 3 4 5 6 7 8 9 long long binpow ( long long x , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( x , n / 2 ); if ( n % 2 ) return res * res * x ; else return res * res ; } Alternativamente, sem usar recurs\u00e3o e usando manipula\u00e7\u00e3o de bits : 1 2 3 4 5 6 7 8 9 10 long long binpow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x ; x = x * x ; n >>= 1 ; } return res ; } Em alguns casos, \u00e9 necess\u00e1rio calcular o valor de \\(x^n \\bmod m\\) . Sabendo que \\((a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\) , pode-se usar diretamente c\u00f3digo anterior e apenas substituir cada multiplica\u00e7\u00e3o por uma multiplica\u00e7\u00e3o modular: 1 2 3 4 5 6 7 8 9 10 11 long long binpow ( long long x , long long n , long long m = 1 ) { // (1) x %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % m ; x = x * x % m ; n >>= 1 ; } return res ; } Deixando o valor padr\u00e3o de m como 1, pode-se usar essa fun\u00e7\u00e3o sem passar o valor de m como par\u00e2metro. Dica Se \\(m\\) \u00e9 um n\u00famero primo, pode-se acelerar um pouco este algoritmo calculando \\(x^{n \\bmod(m\u22121)}\\) em vez de \\(x^n\\) . Complemente sua leitura e seu conhecimento: Binary Exponentiation O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 e 5 \u21a9","title":"Teoria dos N\u00fameros"},{"location":"teorianumeros/#teoria-dos-numeros1","text":"Teoria dos N\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda os n\u00fameros inteiros. Dominar o maior n\u00famero poss\u00edvel de t\u00f3picos da teoria dos n\u00fameros \u00e9 importante, pois alguns problemas matem\u00e1ticos se tornam f\u00e1ceis (ou mais f\u00e1ceis) se voc\u00ea conhecer a teoria por tr\u00e1s do problema.","title":"Teoria dos N\u00fameros1"},{"location":"teorianumeros/#divisibilidade","text":"Um inteiro \\(n\\) \u00e9 divis\u00edvel por um inteiro \\(d\\) (denotado por \\(d | n\\) .) se houver outro inteiro \\(q\\) tal que \\(n = d \\times q\\) . Tamb\u00e9m \u00e9 dito que \\(d\\) \u00e9 um divisor de \\(n\\) . Dividindo os dois lados da igualdade \\(n = dq\\) por \\(d\\) tem-se uma defini\u00e7\u00e3o quase equivalente, ou seja, que \\(\\frac{n}{d}\\) \u00e9 um inteiro. Exemplo O n\u00famero 12 possui 6 divisores: \\(1~(1 \\times 12 = 12), 2~(2 \\times 6 = 12), 3~(3 \\times 4 = 12), 4~(4 \\times 3 = 12), 6~(6 \\times 6 = 12)\\) e \\(12~(12 \\times 1 = 12)\\) . O conceito de divisibilidade traz muitas quest\u00f5es. A primeira \u00e9 como verificar se um n\u00famero \u00e9 divis\u00edvel por outro. Para n\u00famero pequenos, que podem ser armazenados em vari\u00e1veis, por exemplo, do tipo long long , pode-se usar o operador m\u00f3dulo ou resto da divis\u00e3o ( % ): \\(n\\) \u00e9 divis\u00edvel por \\(d\\) se e somente se \u01f9 % d == 0 . Entretanto, para n\u00fameros inteiros grandes a solu\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples. Na Se\u00e7\u00e3o Aritm\u00e9tica Modular ser\u00e1 discutido como implementar o operador m\u00f3dulo para n\u00famero inteiros grandes. Outra quest\u00e3o \u00e9 como calcular os divisores de um n\u00famero. Todo inteiro \\(n\\) tem pelo menos dois divisores ( \\(1\\) e \\(n\\) ). Para encontrar os outros divisores, pode-se usar o fato que qualquer divisor \\(d\\) de \\(n\\) deve satisfazer \\(|d| \\leq |n|\\) . Assim, pode-se testar se os inteiros entre \\(1\\) e \\(n\\) s\u00e3o divisores de \\(n\\) , ou seja, um algoritmo \\(O(n)\\) . Entretanto, sempre que tem-se um divisor \\(d\\) , tem-se outro divisor \\(q\\) (veja o exemplo anterior). Por exemplo, ao afirmar que \\(3\\) \u00e9 um divisor de \\(12\\) , pois \\(3 \\times 4 = 12\\) , tem-se outro divisor, \\(4\\) . Ou seja, os divisores v\u00eam em pares. Veja outros exemplo: Exemplo O n\u00famero 16 possui 5 divisores: \\(1~(1 \\times 16 = 16), 2~(2 \\times 8 = 16), 4~(4 \\times 4 = 16), 8~(8 \\times 2 = 16)\\) e \\(16~(16 \\times 6 = 16)\\) . Dessa forma, pode-se limitar a encontrar cada elemento desses pares. Al\u00e9m disso, um dos valores de cada par deve ser limitado por \\(\\sqrt n\\) . Por qu\u00ea? Esse limite ajuda a reduzir a complexidade do algoritmo que encontra todos os divisores de um n\u00famero em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo retorna um vector com todos os divisores de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > divisores ( long long n ) { vector < long long > ans ; for ( long long a = 1 ; a * a <= n ; a ++ ) { // (1) if ( n % a == 0 ) { long long b = n / a ; ans . push_back ( a ); if ( a != b ) ans . push_back ( b ); } } return ans ; // (2) } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Em alguns casos, \u00e9 interessante ou necess\u00e1rio retornar os divisores ordenados Complemente sua leitura e seu conhecimento: Number of divisors / sum of divisors Divisibility Counting Divisors of a Number in \\(O(n^{\\frac{1}{3}})\\) How many divisors does a number have?","title":"Divisibilidade"},{"location":"teorianumeros/#numeros-primos","text":"Um n\u00famero inteiro \\(n > 1\\) \u00e9 chamado de n\u00famero primo se e somente se possui dois divisores: \\(1\\) e \\(n\\) . Um n\u00famero que n\u00e3o \u00e9 primo \u00e9 chamado de n\u00famero composto (veja a figura abaixo). O primeiro e \u00fanico n\u00famero primo par \u00e9 \\(2\\) . Os pr\u00f3ximos n\u00fameros primos s\u00e3o: \\(3, 5, 7, 11, 13, \\dots\\) . Como voc\u00ea deve imaginar, existe um n\u00famero infinito de primos (Veja a prova aqui ). N\u00fameros primos s\u00e3o os n\u00fameros naturais maiores que um que n\u00e3o s\u00e3o produtos de dois n\u00fameros naturais menores.(Fonte: Wikip\u00e9dia ) N\u00famero primo \u00e9 um t\u00f3pico importante da teoria dos n\u00fameros e a fonte de muitos problemas em programa\u00e7\u00f5es competitivas. Por isso \u00e9 de extrema import\u00e2ncia conhecer e dominar alguns algoritmos que envolvam n\u00fameros primos.","title":"N\u00fameros Primos"},{"location":"teorianumeros/#testes-de-primalidade","text":"Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ent\u00e3o ele pode ser representado pelo produto de dois inteiros \\(a \\times b\\) , onde \\(a \\leq \\sqrt n\\) ou \\(b \\leq \\sqrt n\\) . Com isso, pode-se testar se um n\u00famero \u00e9 primo ou n\u00e3o e encontrar uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo verifica se um dado n\u00famero \\(n\\) \u00e9 primo ou n\u00e3o. 1 2 3 4 5 6 7 8 9 bool ehPrimo ( long long n ) { if ( n < 2 ) return false ; for ( long long x = 2 ; x * x <= n ; x ++ ) { // (1) if ( n % x == 0 ) return false ; } return true ; } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Ou, alternativamente: 1 2 3 4 5 6 7 8 9 10 bool isPrimeFast ( long long n ) { // (1) if ( n < 5 || n % 2 == 0 || n % 3 == 0 ) return ( n == 2 || n == 3 ); long long maxP = sqrt ( n ) + 2 ; for ( long long p = 5 ; p < maxP ; p += 6 ) { if ( p < n && n % p == 0 ) return false ; if ( p + 2 < n && n % ( p + 2 ) == 0 ) return false ; } return true ; } Fonte: primes.cpp Complemente sua leitura e seu conhecimento: Primality tests","title":"Testes de Primalidade"},{"location":"teorianumeros/#decomposicao-em-fatores-primos","text":"Todo n\u00famero positivo \\(n\\) possui uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos \u00fanica: uma forma de decompor \\(n\\) em um produto de n\u00fameros primos, ou seja: \\[ n = p_1^{a_1} \\times p_2^{a_2} \\times \\dots \\times p_k^{a_k}, \\] onde \\(p_i\\) s\u00e3o n\u00fameros primos distintos e \\(a_i\\) inteiros positivos. A fun\u00e7\u00e3o abaixo retorna um vector com a decomposi\u00e7\u00e3o em fatores primos de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > factor ( long long n ) { vector < long long > ans ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ans . push_back ( i ); n /= i ; } } if ( n > 1 ) ans . push_back ( n ); return ans ; } Note que cada fator primo aparece no vetor o n\u00famero de vezes que ele divide \\(n\\) . Por exemplo, \\(24 = 2^3 \\times 3\\) , ent\u00e3o o resultado da fun\u00e7\u00e3o \u00e9 \\([2,2,2,3]\\) . Complemente sua leitura e seu conhecimento: Integer factorization Primalidade e fatora\u00e7\u00e3o","title":"Decomposi\u00e7\u00e3o em fatores primos"},{"location":"teorianumeros/#crivo-de-eratostenes","text":"O Crivo de Erat\u00f3stenes \u00e9 um algoritmo para encontrar todos os n\u00fameros primos at\u00e9 um certo limite usando \\(O(n \\log \\log n)\\) opera\u00e7\u00f5es. A ideia do algoritmo \u00e9 a seguinte: inicialmente, escreve-se todos os n\u00fameros entre \\(2\\) e \\(n\\) . Ent\u00e3o, marca-se todos os m\u00faltiplos de \\(2\\) (j\u00e1 que \\(2\\) \u00e9 o menor n\u00famero primo). Em seguida, pega-se o pr\u00f3ximo valor que n\u00e3o foi marcado como composto, neste caso, \u00e9 o \\(3\\) . Isso significa que 3 \u00e9 primo. Ent\u00e3o, marca-se todos os m\u00faltiplos de 3 como compostos. O pr\u00f3ximo n\u00famero n\u00e3o marcado \u00e9 o \\(5\\) (pr\u00f3ximo n\u00famero primo). Marca-se todos os m\u00faltiplos de \\(5\\) . Este processo \u00e9 repetido at\u00e9 \\(n\\) . A anima\u00e7\u00e3o abaixo exemplifica a execu\u00e7\u00e3o do algoritmo para \\(n = 120\\) . Crivo de Erat\u00f3stenes: passos do algoritmo para primos abaixo de 121. (Fonte: Wikip\u00e9dia ) O c\u00f3digo abaixo exemplifica uma poss\u00edvel implementa\u00e7\u00e3o do algoritmo. Esse algoritmo possui complexidade \\(O(n \\log \\log n)\\) (veja a prova aqui ). 1 2 3 4 5 6 7 8 9 10 11 vector < bool > crivo ( long long n ) { vector < bool > primo ( n + 1 , true ); // (1) primo [ 0 ] = primo [ 1 ] = false ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( primo [ i ] && i * i <= n ) { for ( long long j = i * i ; j <= n ; j += i ) // (2) primo [ j ] = false ; } } return primo ; } Cria um array ( vector ) booleano de tamanho \\(n + 1\\) , onde todas as posi\u00e7\u00f5es s\u00e3o inicializadas com true . Iteramos por todos os n\u00fameros divis\u00edveis pelo primo i Complemente sua leitura e seu conhecimento: Sieve of Eratosthenes Linear Sieve Math note - linear sieve","title":"Crivo de Erat\u00f3stenes"},{"location":"teorianumeros/#primo-de-mersenne","text":"N\u00famero de Mersenne \u00e9 todo n\u00famero natural da forma \\(M_{n}=2^{n}-1\\) , onde \\(n\\) \u00e9 um n\u00famero natural. Os primeiros n\u00fameros Mersenne s\u00e3o: \\(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\dots\\) . Um subconjunto particularmente interessante \u00e9 o constitu\u00eddo pelos n\u00fameros de Mersenne que s\u00e3o tamb\u00e9m primos: os primos de Mersenne . Note que nem todo n\u00famero de Mersenne \u00e9 primo, assim como nem todo n\u00famero primo \u00e9 de Mersenne. Os primeiros primos de Mersenne s\u00e3o: \\(M_2 = 3, M_3 = 7, M_5 = 31, M_7 = 127, M_13 = 8191, M_17 = 131071, M_19 = 524287, \\dots\\) Um resultado elementar sobre os n\u00fameros de Mersenne afirma que se \\(2^{n}-1\\) \u00e9 um n\u00famero primo, ent\u00e3o \\(n\\) tamb\u00e9m \u00e9 um n\u00famero primo.","title":"Primo de Mersenne"},{"location":"teorianumeros/#algoritmo-de-euclides-mdcmmc","text":"O m\u00e1ximo divisor comum (GCD, do ingl\u00eas greatest common divisor ) dos n\u00fameros \\(a\\) e \\(b\\) , gcd(a,b) , \u00e9 o maior n\u00famero que divide \\(a\\) e \\(b\\) , e o m\u00ednimo m\u00faltiplo comum (LCM, do ingl\u00eas least common multiple ) de \\(a\\) e \\(b\\) , lcm(a,b) , \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e \\(b\\) . O algoritmo de Euclides fornece uma maneira eficiente de encontrar o m\u00e1ximo divisor comum de dois n\u00fameros. O algoritmo \u00e9 baseado na seguinte defini\u00e7\u00e3o: \\[ \\gcd(a, b) = \\begin{cases}a,&\\text{se }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{caso contr\u00e1rio.}\\end{cases} \\] Usando essa defini\u00e7\u00e3o, o algoritmo \u00e9 facilmente implementado usando recurs\u00e3o: 1 2 3 4 5 6 long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Dica Voc\u00ea pode usar a fun\u00e7\u00e3o integrada __gcd(a, b) do C++. Pode-se mostrar que o algoritmo de Euclides possui complexidade \\(O(\\log n)\\) , onde \\(n = min(a,b)\\) . O m\u00ednimo m\u00faltiplo comum (LCM) pode ser calculado da seguinte forma: \\[ lcm(a, b) = \\frac{a \\times b}{gcd(a,b)} \\] Para calcular o GCD ou LCM de mais de dois valores, pode-se calcular o valor de dois em dois (em qualquer ordem). Por exemplo: \\[ gcd(a, b, c, d) = gcd(a, gcd(b, gcd(c, d))) \\]","title":"Algoritmo de Euclides (MDC/MMC)"},{"location":"teorianumeros/#funcao-totiente-de-euler","text":"A fun\u00e7\u00e3o totiente de Euler, tamb\u00e9m conhecida como fun\u00e7\u00e3o \\(\\phi (n)\\) , conta o n\u00famero de inteiros entre \\(1\\) e \\(n\\) , no qual s\u00e3o coprimos de \\(n\\) . Dois n\u00fameros s\u00e3o coprimos se o m\u00e1ximo divisor comum entre eles for 1 (1 \u00e9 considerado ser coprimo para qualquer n\u00famero). Por exemplo, \\(\\phi (12) = 4\\) , pois 1, 5, 7 e 11 s\u00e3o coprimos de 12. Abaixo est\u00e3o valores de \\(\\phi (n)\\) para os primeiros n\u00fameros inteiros positivos: \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\ \\hline \\end{array}\\] A fun\u00e7\u00e3o abaixo calcula o valor de \\(\\phi (n)\\) em \\(O(\\sqrt n)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 long long phi ( long long n ) { long long result = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Complemente sua leitura e seu conhecimento: Euclidean algorithm for computing the greatest common divisor Euler's totient function","title":"Fun\u00e7\u00e3o totiente de Euler"},{"location":"teorianumeros/#aritmetica-modular","text":"Na aritm\u00e9tica modular , o conjunto de n\u00fameros \u00e9 limitado de forma que apenas os n\u00fameros \\(0,1,2,\\dots,m\u22121\\) s\u00e3o usados, onde \\(m\\) \u00e9 uma constante. Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(x \\bmod m\\) : o resto da divis\u00e3o de \\(x\\) por \\(m\\) . Por exemplo, se \\(m = 23\\) , em vez \\(x = 247\\) , considera-se \\(x \\bmod 23 = 17\\) . Normalmente, \\(m\\) ser\u00e1 um primo grande, dado no problema, normalmente, \\(10^9 + 7\\) . A aritm\u00e9tica modular \u00e9 usada para evitar integer overflow . As seguintes propriedades valem no c\u00e1lculo do m\u00f3dulo: \\[(a+b) \\bmod m = (a \\bmod m + b \\bmod m) \\bmod m\\] \\[(a-b) \\bmod m = (a \\bmod m - b \\bmod m) \\bmod m\\] \\[(a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\] \\[a^b \\bmod {m} = (a \\bmod m)^b \\bmod m\\] O que significa que se a resposta est\u00e1 sendo computada por meio de adi\u00e7\u00f5es, subtra\u00e7\u00f5es e multiplica\u00e7\u00f5es, e no final voc\u00ea precisa tirar o m\u00f3dulo dela, voc\u00ea pode tirar o m\u00f3dulo em todas as opera\u00e7\u00f5es intermedi\u00e1rias que isso n\u00e3o afetar\u00e1 a resposta.","title":"Aritm\u00e9tica Modular"},{"location":"teorianumeros/#exponenciacao-binaria","text":"A exponencia\u00e7\u00e3o bin\u00e1ria \u00e9 um truque que permite calcular \\(x^n\\) usando apenas multiplica\u00e7\u00f5es \\(O(\\log\u2061 n)\\) (em vez das multiplica\u00e7\u00f5es \\(O(n)\\) exigidas pela abordagem ing\u00eanua). Sabe-se que \\(x^a \\cdot x^b = x^{a+b}\\) . Em particular, \\(x^{2b} = x^b \\cdot x^b\\) . Logo, se o expoente \\(n\\) de \\(x^n\\) for par, pode-se dizer que \\(x^n = x^{\\frac{n}{2}} \\cdot x^{\\frac{n}{2}}\\) . No entanto, se \\(n\\) for \u00edmpar, tem-se algo similar: \\(x^n = x^{\\frac{n-1}{2}} \\cdot x^{\\frac{n-1}{2}} \\cdot x\\) . Dessa forma, pode-se montar a seguinte recorr\u00eancia: \\[ x^n = \\begin{cases} 1 &\\text{se } n = 0 \\\\ \\left(x^{\\frac{n}{2}}\\right)^2 &\\text{se } n \\text{ par}\\\\ \\left(x^{\\frac{n - 1}{2}}\\right)^2 \\cdot x &\\text{se } n \\text{ impar}\\\\ \\end{cases} \\] Note que se \\(n\\) for par, o valor \\(x^{n/2}\\) deve ser calculado apenas uma vez. Isso garante que a complexidade do algoritmo seja \\(O(\\log n)\\) . A fun\u00e7\u00e3o abaixo calcula do valor de \\(x^n\\) : 1 2 3 4 5 6 7 8 9 long long binpow ( long long x , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( x , n / 2 ); if ( n % 2 ) return res * res * x ; else return res * res ; } Alternativamente, sem usar recurs\u00e3o e usando manipula\u00e7\u00e3o de bits : 1 2 3 4 5 6 7 8 9 10 long long binpow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x ; x = x * x ; n >>= 1 ; } return res ; } Em alguns casos, \u00e9 necess\u00e1rio calcular o valor de \\(x^n \\bmod m\\) . Sabendo que \\((a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\) , pode-se usar diretamente c\u00f3digo anterior e apenas substituir cada multiplica\u00e7\u00e3o por uma multiplica\u00e7\u00e3o modular: 1 2 3 4 5 6 7 8 9 10 11 long long binpow ( long long x , long long n , long long m = 1 ) { // (1) x %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % m ; x = x * x % m ; n >>= 1 ; } return res ; } Deixando o valor padr\u00e3o de m como 1, pode-se usar essa fun\u00e7\u00e3o sem passar o valor de m como par\u00e2metro. Dica Se \\(m\\) \u00e9 um n\u00famero primo, pode-se acelerar um pouco este algoritmo calculando \\(x^{n \\bmod(m\u22121)}\\) em vez de \\(x^n\\) . Complemente sua leitura e seu conhecimento: Binary Exponentiation O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 e 5 \u21a9","title":"Exponencia\u00e7\u00e3o Bin\u00e1ria"}]}