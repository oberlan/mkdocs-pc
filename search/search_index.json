{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programa\u00e7\u00e3o Competitiva Ementa Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional. Objetivos Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas. Programas e Sites Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona Bibliografia Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++ Notebooks Stanford University Royal Institute of Technology","title":"Disciplina"},{"location":"#programacao-competitiva","text":"","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"#ementa","text":"Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional.","title":"Ementa"},{"location":"#objetivos","text":"Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas.","title":"Objetivos"},{"location":"#programas-e-sites","text":"Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona","title":"Programas e Sites"},{"location":"#bibliografia","text":"Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++","title":"Bibliografia"},{"location":"#notebooks","text":"Stanford University Royal Institute of Technology","title":"Notebooks"},{"location":"buscaexaustiva/","text":"Busca Exaustiva (Recurs\u00e3o + Backtracking) Em constru\u00e7\u00e3o...","title":"Busca Exaustiva"},{"location":"buscaexaustiva/#busca-exaustiva-recursao-backtracking","text":"Em constru\u00e7\u00e3o...","title":"Busca Exaustiva (Recurs\u00e3o + Backtracking)"},{"location":"combinatoria/","text":"Combinat\u00f3ria Sugere-se a leitura dos seguintes conte\u00fados: Basics of Combinatorics (HackerEarth) Basics of Combinatorics (TopCoder) Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving","title":"Combinat\u00f3ria"},{"location":"combinatoria/#combinatoria","text":"Sugere-se a leitura dos seguintes conte\u00fados: Basics of Combinatorics (HackerEarth) Basics of Combinatorics (TopCoder) Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving","title":"Combinat\u00f3ria"},{"location":"complexidade/","text":"Complexidade de Algoritmos Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, pode-se descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"complexidade/#complexidade-de-algoritmos","text":"Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, pode-se descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"ed1/","text":"Estrutura de Dados e STL 1 Estrutura de dados (ED) \u00e9 a forma como os dados s\u00e3o armazenados na mem\u00f3ria do computador com o objetivo de tornar o processamento mais f\u00e1cil e eficiente. Cada uma possui suas pr\u00f3prias vantagens e desvantagens, por isso, \u00e9 crucial conhecer diferentes estruturas de dados (b\u00e1sicas e avan\u00e7adas) para conseguir definir qual as mais apropriada para um determinado problema. Em programa\u00e7\u00e3o competitiva, com o objetivo de economizar uma grande quantidade de tempo ao implementar um algoritmo, tamb\u00e9m \u00e9 muito importante saber quais EDs est\u00e3o dispon\u00edveis na biblioteca padr\u00e3o, como us\u00e1-las e qual a complexidade de cada opera\u00e7\u00e3o da ED. A seguir s\u00e3o apresentados as estruturas de dados presentes na biblioteca padr\u00e3o do C++ comumente usadas em competi\u00e7\u00f5es. Leitura recomendada: C++ Standard Library Containers More Operations on Sorted Sets C++ Sets with Custom Comparators C++ Containers library vector Um vector \u00e9 um array din\u00e2mico que permite adicionar e remover elementos de forma eficiente no final da estrutura. Por exemplo, o c\u00f3digo a seguir cria um vetor vazio e adiciona tr\u00eas elementos a ele: 1 2 3 4 vector < int > v ; v . push_back ( 3 ); // [3] v . push_back ( 2 ); // [3,2] v . push_back ( 5 ); // [3,2,5] Observe que os elementos s\u00e3o inseridos no fim. Ent\u00e3o, os elementos podem ser acessados como em um array comum: 1 2 3 cout << v [ 0 ] << \" \\n \" ; // 3 cout << v [ 1 ] << \" \\n \" ; // 2 cout << v [ 2 ] << \" \\n \" ; // 5 Outra maneira de criar um vetor \u00e9 fornecer uma lista de seus elementos: 1 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; Tamb\u00e9m pode-se fornecer o n\u00famero de elementos e seus valores iniciais: 1 2 vector < int > a ( 8 ); // tamanho 8, valor inicial: 0 vector < int > b ( 8 , 2 ); // tamanho 8, valor inicial: 2 A fun\u00e7\u00e3o size() retorna o n\u00famero de elementos no vector . Por exemplo: 1 2 3 for ( int i = 0 ; i < v . size (); i ++ ) { cout << v [ i ] << \" \\n \" ; } Uma alternativa mais simples \u00e9 a seguinte: 1 2 3 for ( auto x : v ) { cout << x << \" \\n \" ; } A fun\u00e7\u00e3o back retorna o \u00faltimo elemento de um vetor e a fun\u00e7\u00e3o pop_back remove o \u00faltimo elemento: 1 2 3 4 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; cout << v . back () << \" \\n \" ; // 1 v . pop_back (); cout << v . back () << \" \\n \" ; // 5 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do vector . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::vector std::vector deque Um deque \u00e9 um array din\u00e2mico que pode ser manipulado eficientemente em ambas as extremidades da estrutura. Como um vector , um deque fornece as fun\u00e7\u00f5es push_back e pop_back , mas tamb\u00e9m fornece as fun\u00e7\u00f5es push_front e pop_front que n\u00e3o est\u00e3o dispon\u00edveis em um vector . veja uma exemplo: As principais fun\u00e7\u00f5es da deque s\u00e3o: push_front(x) : adiciona o elemento x no in\u00edcio da estrutura; push_back(x) : adiciona o elemento x no fim da estrutura; pop_front() : remove o primeiro elemento da estrutura; pop_back() : remove o \u00faltimo elemento da estrutura; front() : retorna o primeiro elemento da estrutura; back() : retorna o \u00faltimo elemento da estrutura; size() : retorna o n\u00famero de elementos da estrutura. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 deque < int > d ; d . push_back ( 5 ); // [5] d . push_back ( 2 ); // [5,2] d . push_front ( 3 ); // [3,5,2] d . pop_back (); // [3,5] d . pop_front (); // [5] As opera\u00e7\u00f5es de um deque funcionam em tempo m\u00e9dio \\(O(1)\\) . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do deque . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::deque std::deque queue A estrutura da queue (fila) corresponde a uma fila simples da vida real e segue a regra First In First Out (FIFO). Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no fim da fila, acessar e remover o primeiro elemento da fila. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da queue s\u00e3o: push(x) : adiciona o elemento x no fim da fila; pop() : remove o primeiro elemento da fila; front() : retorna o primeiro elemento da fila; size() : retorna o n\u00famero de elementos da fila. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 queue < int > q ; q . push ( 2 ); // [2] q . push ( 5 ); // [2,5] cout << q . size () << \" \\n \" ; // 2 cout << q . front () << \" \\n \" ; // 2 q . pop (); // [5] cout << q . back () << \" \\n \" ; // 5 Complemente sua leitura e seu conhecimento: std::queue Queue Data Structure (GeeksforGeeks) stack Uma stack (pilha) \u00e9 uma estrutura muito semelhante a uma fila, mas que segue a regra Last In First Out (LIFO). Ou seja, ao inserir um elemento na pilha, ele \u00e9 adicionado no topo e esse \u00e9 o elemento que se tem acesso. Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no topo da pilha, acessar e remover o elemento do topo da pilha. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da stack s\u00e3o: push(x) : adiciona o elemento x no topo da pilha; pop() : remove o elemento do topo da pilha; top() : retorna o elemento do topo da pilha; size() : retorna o n\u00famero de elementos da pilha. Veja um exemplo de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 stack < int > s ; s . push ( 2 ); // [2] s . push ( 5 ); // [2,5] cout << s . size () << \" \\n \" ; // 2 cout << s . top () << \" \\n \" ; // 5 s . pop (); // [2] cout << s . top () << \" \\n \" ; // 2 Complemente sua leitura e seu conhecimento: std::stack Stack Data Structure (GeeksforGeeks) Stacks priority_queue Uma fila de prioridade ( priority_queue ) \u00e9 uma estrutura semelhante a uma fila ou pilha, mas ao inv\u00e9s de inser\u00e7\u00f5es e remo\u00e7\u00f5es acontecerem em uma das extremidades da estrutura, o maior (ou menor ) elemento \u00e9 sempre retornado durante o acesso/remo\u00e7\u00e3o. Inser\u00e7\u00f5es e remo\u00e7\u00f5es possuem complexidade \\(O(\\log n)\\) e o acesso ao elemento de maior prioridade \u00e9 \\(O(1)\\) . Uma fila de prioridade geralmente \u00e9 implementada usando uma estrutura chamada heap que \u00e9 muito mais simples do que uma \u00e1rvore bin\u00e1ria balanceada usado em um set . As principais fun\u00e7\u00f5es da priority_queue s\u00e3o: push(x) : adiciona o elemento x na fila de prioridade; pop() : remove o elemento de maior prioridade; top() : retorna o elemento de maior prioridade; size() : retorna o n\u00famero de elementos da fila de prioridade. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 priority_queue < int > q ; q . push ( 3 ); q . push ( 5 ); q . push ( 7 ); q . push ( 2 ); cout << q . top () << \" \\n \" ; // 7 q . pop (); cout << q . top () << \" \\n \" ; // 5 q . pop (); q . push ( 6 ); cout << q . top () << \" \\n \" ; // 6 q . pop (); Se for necess\u00e1rio criar uma fila de prioridade que suporte encontrar e remover o menor elemento, pode-se fazer da seguinte forma: 1 2 3 4 bool cmp ( const int & a , const int & b ) { return a > b ; } priority_queue < int , vector < int > , cmp > pq ; // (1) Note o uso da fun\u00e7\u00e3o de compara\u00e7\u00e3o cmp . Essa fun\u00e7\u00e3o deve receber dois argumentos do tipo armazenado na fila de prioridade e retorna true se o primeiro for considerado menor que o segundo. Para o exemplo anterior, outra alternativa \u00e9 usar a fun\u00e7\u00e3o greater : 1 priority_queue < int , vector < int > , greater < int >> pq ; Complemente sua leitura e seu conhecimento: Priority Queue in C++ Standard Template Library (STL) std::priority_queue set e multiset Semelhante a um conjunto matem\u00e1tico, um set \u00e9 uma cole\u00e7\u00e3o de elementos \u00fanicos , ou seja, todos os seus elementos s\u00e3o distintos. A estrutura \u00e9 baseada em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . Consequentemente, n\u00e3o \u00e9 poss\u00edvel acessar os elementos do set usando o operador [] , como acontece em um vector . Al\u00e9m disso, os elementos s\u00e3o mantidos ordenados . As principais fun\u00e7\u00f5es do set (e multiset ) s\u00e3o: insert(x) : adiciona o elemento x no conjunto. Se ele j\u00e1 estiver no conjunto, nada \u00e9 feito; erase(x) : remove o elemento x ; count(x) : retorna o n\u00famero de elemento cuja chave seja x ; find(x) : retorna um iterador para o elemento com chave x ; size() : retorna o n\u00famero de elementos do conjunto. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura set : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 set < int > s ; s . insert ( 3 ); s . insert ( 2 ); s . insert ( 5 ); cout << s . count ( 3 ) << \" \\n \" ; // 1 cout << s . count ( 4 ) << \" \\n \" ; // 0 s . erase ( 3 ); s . insert ( 4 ); cout << s . count ( 3 ) << \" \\n \" ; // 0 cout << s . count ( 4 ) << \" \\n \" ; // 1 if ( s . find ( 7 ) == s . end ()){ cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; } auto menor = s . begin (); auto maior = s . end (); maior -- ; // (1) cout << \"O menor elemento do conjunto \u00e9: \" << * menor << \" \\n \" ; cout << \"O maior elemento do conjunto \u00e9: \" << * maior << \" \\n \" ; set < int > c1 = { 2 , 5 , 6 , 8 }; cout << c1 . size () << \" \\n \" ; // 4 for ( auto x : c1 ) cout << x << \" \\n \" ; set < int > c2 ; c2 . insert ( 5 ); c2 . insert ( 5 ); c2 . insert ( 5 ); cout << c2 . count ( 5 ) << \" \\n \" ; // 1 (2) Como end() aponta para um elemento ap\u00f3s o \u00faltimo elemento, deve-se diminuir o iterador em uma unidade. Lembre-se que em um set todos seus elementos s\u00e3o distintos. Assim, a fun\u00e7\u00e3o count sempre retornar ou 0 (elemento n\u00e3o est\u00e1 no set ) ou 1 (o elemento est\u00e1 no set ). A estrutura set tamb\u00e9m fornece as fun\u00e7\u00f5es lower_bound(x) e upper_bound(x) que retornam um iterador para o menor elemento em um set cujo valor \u00e9 pelo menos ou maior que x , respectivamente. Em ambas as fun\u00e7\u00f5es, se o elemento solicitado n\u00e3o existir, o valor de retorno \u00e9 end() . Um multiset \u00e9 um conjunto que pode conter v\u00e1rias c\u00f3pias do mesmo elemento. Por exemplo, o c\u00f3digo abaixo adiciona tr\u00eas c\u00f3pias do valor 5 ao multiset : 1 2 3 4 5 multiset < int > s ; s . insert ( 5 ); s . insert ( 5 ); s . insert ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 3 A fun\u00e7\u00e3o erase remove todas as c\u00f3pias de um valor do multiset : 1 2 s . erase ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 0 Caso seja necess\u00e1rio remover apenas uma c\u00f3pia, pode-se fazer da seguinte forma: 1 2 s . erase ( s . find ( 5 )); cout << s . count ( 5 ) << \" \\n \" ; // 2 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do set e multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Set in C++ Standard Template Library (STL) Multiset in C++ Standard Template Library (STL) std::set std::multiset map e multimap Um map \u00e9 um conjunto que consiste em pares de valores-chave. Um map tamb\u00e9m pode ser visto como um array comum. Enquanto as chaves em um array s\u00e3o sempre inteiros consecutivos \\(0, 1, \\dots , n \u2212 1\\) , onde \\(n\\) \u00e9 o tamanho do array , as chaves em um map podem ser de qualquer tipo de dados e n\u00e3o precisam ser valores consecutivos. Como no set , o map \u00e9 baseado em em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . O c\u00f3digo a seguir cria um map cujas chaves s\u00e3o strings e os valores s\u00e3o int : 1 2 3 4 5 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; cout << m [ \"Daniel\" ] << \" \\n \" ; // 38 Se o valor de uma chave for solicitado, mas que n\u00e3o existe no map , a chave ser\u00e1 adicionada automaticamente ao map com um valor padr\u00e3o do tipo (se for uma classe o construtor padr\u00e3o \u00e9 chamado). Por exemplo, no c\u00f3digo a seguir, a chave \"Ana\" com valor 0 \u00e9 adicionada ao map . 1 2 map < string , int > m ; cout << m [ \"Ana\" ] << \" \\n \" ; Veja mais alguns exemplos de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; if ( m . find ( \"Ana\" ) == m . end ()) cout << \"N\u00e3o temos a idade da Ana registrada\" << \" \\n \" ; cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; cout << \"Bia tem \" << m [ \"Bia\" ] << \" anos \\n \" ; for ( auto x : m ) cout << x . first << \" \" << x . second << \" \\n \" ; m . erase ( \"Paulo\" ); cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; auto ultimo = -- m . end (); cout << ultimo -> first << \" tem \" << ultimo -> second << \" anos \\n \" ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do map e multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Map in C++ Standard Template Library (STL) Multimap in C++ Standard Template Library (STL) std::map std::multimap unordered_set e unordered_multiset Um unordered_set \u00e9 um cont\u00eainer associativo que cont\u00e9m um conjunto de objetos exclusivos. J\u00e1 um unordered_multiset permite c\u00f3pia dos elementos. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 unordered_set < int > s = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; s . erase ( 10 ); s . insert ( 4 ); cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; if ( s . find ( 7 ) == s . end ()) cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; for ( auto x : s ) cout << x << \" \" ; cout << endl ; unordered_multiset < int > ms = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; for ( auto x : ms ) cout << x << \" \" ; cout << endl ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_set e unordered_multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_set std::unordered_multiset unordered_map e unordered_multimap \u00e9 um conjunto que consiste em pares de valores-chave Um unordered_map \u00e9 um cont\u00eainer associativo que cont\u00e9m pares de valores-chave com chaves exclusivas. J\u00e1 um unordered_multimap permite m\u00faltiplas c\u00f3pias das chaves. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 unordered_map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; m [ \"Bia\" ] = 28 ; // Atualiza o valor da chave \"Bia\" for ( auto [ chave , valor ] : m ) cout << chave << \" -> \" << valor << \" \\n \" ; cout << endl ; unordered_multimap < string , int > mm ; mm . insert ( make_pair ( \"Paulo\" , 22 )); // (1) mm . insert ( make_pair ( \"Paulo\" , 43 )); mm . insert ( make_pair ( \"Bia\" , 19 )); mm . insert ( make_pair ( \"Bia\" , 22 )); for ( auto [ chave , valor ] : mm ) cout << chave << \" -> \" << valor << \" \\n \" ; N\u00e3o \u00e9 poss\u00edvel usar o operator[] como no map e unordered_map . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_map e unordered_multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_map std::unordered_multimap O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 \u21a9","title":"Estrutura de Dados (Parte 1)"},{"location":"ed1/#estrutura-de-dados-e-stl1","text":"Estrutura de dados (ED) \u00e9 a forma como os dados s\u00e3o armazenados na mem\u00f3ria do computador com o objetivo de tornar o processamento mais f\u00e1cil e eficiente. Cada uma possui suas pr\u00f3prias vantagens e desvantagens, por isso, \u00e9 crucial conhecer diferentes estruturas de dados (b\u00e1sicas e avan\u00e7adas) para conseguir definir qual as mais apropriada para um determinado problema. Em programa\u00e7\u00e3o competitiva, com o objetivo de economizar uma grande quantidade de tempo ao implementar um algoritmo, tamb\u00e9m \u00e9 muito importante saber quais EDs est\u00e3o dispon\u00edveis na biblioteca padr\u00e3o, como us\u00e1-las e qual a complexidade de cada opera\u00e7\u00e3o da ED. A seguir s\u00e3o apresentados as estruturas de dados presentes na biblioteca padr\u00e3o do C++ comumente usadas em competi\u00e7\u00f5es. Leitura recomendada: C++ Standard Library Containers More Operations on Sorted Sets C++ Sets with Custom Comparators C++ Containers library","title":"Estrutura de Dados e STL1"},{"location":"ed1/#vector","text":"Um vector \u00e9 um array din\u00e2mico que permite adicionar e remover elementos de forma eficiente no final da estrutura. Por exemplo, o c\u00f3digo a seguir cria um vetor vazio e adiciona tr\u00eas elementos a ele: 1 2 3 4 vector < int > v ; v . push_back ( 3 ); // [3] v . push_back ( 2 ); // [3,2] v . push_back ( 5 ); // [3,2,5] Observe que os elementos s\u00e3o inseridos no fim. Ent\u00e3o, os elementos podem ser acessados como em um array comum: 1 2 3 cout << v [ 0 ] << \" \\n \" ; // 3 cout << v [ 1 ] << \" \\n \" ; // 2 cout << v [ 2 ] << \" \\n \" ; // 5 Outra maneira de criar um vetor \u00e9 fornecer uma lista de seus elementos: 1 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; Tamb\u00e9m pode-se fornecer o n\u00famero de elementos e seus valores iniciais: 1 2 vector < int > a ( 8 ); // tamanho 8, valor inicial: 0 vector < int > b ( 8 , 2 ); // tamanho 8, valor inicial: 2 A fun\u00e7\u00e3o size() retorna o n\u00famero de elementos no vector . Por exemplo: 1 2 3 for ( int i = 0 ; i < v . size (); i ++ ) { cout << v [ i ] << \" \\n \" ; } Uma alternativa mais simples \u00e9 a seguinte: 1 2 3 for ( auto x : v ) { cout << x << \" \\n \" ; } A fun\u00e7\u00e3o back retorna o \u00faltimo elemento de um vetor e a fun\u00e7\u00e3o pop_back remove o \u00faltimo elemento: 1 2 3 4 vector < int > v = { 2 , 4 , 2 , 5 , 1 }; cout << v . back () << \" \\n \" ; // 1 v . pop_back (); cout << v . back () << \" \\n \" ; // 5 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do vector . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::vector std::vector","title":"vector"},{"location":"ed1/#deque","text":"Um deque \u00e9 um array din\u00e2mico que pode ser manipulado eficientemente em ambas as extremidades da estrutura. Como um vector , um deque fornece as fun\u00e7\u00f5es push_back e pop_back , mas tamb\u00e9m fornece as fun\u00e7\u00f5es push_front e pop_front que n\u00e3o est\u00e3o dispon\u00edveis em um vector . veja uma exemplo: As principais fun\u00e7\u00f5es da deque s\u00e3o: push_front(x) : adiciona o elemento x no in\u00edcio da estrutura; push_back(x) : adiciona o elemento x no fim da estrutura; pop_front() : remove o primeiro elemento da estrutura; pop_back() : remove o \u00faltimo elemento da estrutura; front() : retorna o primeiro elemento da estrutura; back() : retorna o \u00faltimo elemento da estrutura; size() : retorna o n\u00famero de elementos da estrutura. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 deque < int > d ; d . push_back ( 5 ); // [5] d . push_back ( 2 ); // [5,2] d . push_front ( 3 ); // [3,5,2] d . pop_back (); // [3,5] d . pop_front (); // [5] As opera\u00e7\u00f5es de um deque funcionam em tempo m\u00e9dio \\(O(1)\\) . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do deque . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: std::deque std::deque","title":"deque"},{"location":"ed1/#queue","text":"A estrutura da queue (fila) corresponde a uma fila simples da vida real e segue a regra First In First Out (FIFO). Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no fim da fila, acessar e remover o primeiro elemento da fila. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da queue s\u00e3o: push(x) : adiciona o elemento x no fim da fila; pop() : remove o primeiro elemento da fila; front() : retorna o primeiro elemento da fila; size() : retorna o n\u00famero de elementos da fila. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 queue < int > q ; q . push ( 2 ); // [2] q . push ( 5 ); // [2,5] cout << q . size () << \" \\n \" ; // 2 cout << q . front () << \" \\n \" ; // 2 q . pop (); // [5] cout << q . back () << \" \\n \" ; // 5 Complemente sua leitura e seu conhecimento: std::queue Queue Data Structure (GeeksforGeeks)","title":"queue"},{"location":"ed1/#stack","text":"Uma stack (pilha) \u00e9 uma estrutura muito semelhante a uma fila, mas que segue a regra Last In First Out (LIFO). Ou seja, ao inserir um elemento na pilha, ele \u00e9 adicionado no topo e esse \u00e9 o elemento que se tem acesso. Suas principais opera\u00e7\u00f5es s\u00e3o: inserir um elemento no topo da pilha, acessar e remover o elemento do topo da pilha. Essas opera\u00e7\u00f5es possuem complexidade em \\(O(1)\\) . As principais fun\u00e7\u00f5es da stack s\u00e3o: push(x) : adiciona o elemento x no topo da pilha; pop() : remove o elemento do topo da pilha; top() : retorna o elemento do topo da pilha; size() : retorna o n\u00famero de elementos da pilha. Veja um exemplo de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 stack < int > s ; s . push ( 2 ); // [2] s . push ( 5 ); // [2,5] cout << s . size () << \" \\n \" ; // 2 cout << s . top () << \" \\n \" ; // 5 s . pop (); // [2] cout << s . top () << \" \\n \" ; // 2 Complemente sua leitura e seu conhecimento: std::stack Stack Data Structure (GeeksforGeeks) Stacks","title":"stack"},{"location":"ed1/#priority_queue","text":"Uma fila de prioridade ( priority_queue ) \u00e9 uma estrutura semelhante a uma fila ou pilha, mas ao inv\u00e9s de inser\u00e7\u00f5es e remo\u00e7\u00f5es acontecerem em uma das extremidades da estrutura, o maior (ou menor ) elemento \u00e9 sempre retornado durante o acesso/remo\u00e7\u00e3o. Inser\u00e7\u00f5es e remo\u00e7\u00f5es possuem complexidade \\(O(\\log n)\\) e o acesso ao elemento de maior prioridade \u00e9 \\(O(1)\\) . Uma fila de prioridade geralmente \u00e9 implementada usando uma estrutura chamada heap que \u00e9 muito mais simples do que uma \u00e1rvore bin\u00e1ria balanceada usado em um set . As principais fun\u00e7\u00f5es da priority_queue s\u00e3o: push(x) : adiciona o elemento x na fila de prioridade; pop() : remove o elemento de maior prioridade; top() : retorna o elemento de maior prioridade; size() : retorna o n\u00famero de elementos da fila de prioridade. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 priority_queue < int > q ; q . push ( 3 ); q . push ( 5 ); q . push ( 7 ); q . push ( 2 ); cout << q . top () << \" \\n \" ; // 7 q . pop (); cout << q . top () << \" \\n \" ; // 5 q . pop (); q . push ( 6 ); cout << q . top () << \" \\n \" ; // 6 q . pop (); Se for necess\u00e1rio criar uma fila de prioridade que suporte encontrar e remover o menor elemento, pode-se fazer da seguinte forma: 1 2 3 4 bool cmp ( const int & a , const int & b ) { return a > b ; } priority_queue < int , vector < int > , cmp > pq ; // (1) Note o uso da fun\u00e7\u00e3o de compara\u00e7\u00e3o cmp . Essa fun\u00e7\u00e3o deve receber dois argumentos do tipo armazenado na fila de prioridade e retorna true se o primeiro for considerado menor que o segundo. Para o exemplo anterior, outra alternativa \u00e9 usar a fun\u00e7\u00e3o greater : 1 priority_queue < int , vector < int > , greater < int >> pq ; Complemente sua leitura e seu conhecimento: Priority Queue in C++ Standard Template Library (STL) std::priority_queue","title":"priority_queue"},{"location":"ed1/#set-e-multiset","text":"Semelhante a um conjunto matem\u00e1tico, um set \u00e9 uma cole\u00e7\u00e3o de elementos \u00fanicos , ou seja, todos os seus elementos s\u00e3o distintos. A estrutura \u00e9 baseada em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . Consequentemente, n\u00e3o \u00e9 poss\u00edvel acessar os elementos do set usando o operador [] , como acontece em um vector . Al\u00e9m disso, os elementos s\u00e3o mantidos ordenados . As principais fun\u00e7\u00f5es do set (e multiset ) s\u00e3o: insert(x) : adiciona o elemento x no conjunto. Se ele j\u00e1 estiver no conjunto, nada \u00e9 feito; erase(x) : remove o elemento x ; count(x) : retorna o n\u00famero de elemento cuja chave seja x ; find(x) : retorna um iterador para o elemento com chave x ; size() : retorna o n\u00famero de elementos do conjunto. O c\u00f3digo a seguir ilustra a utiliza\u00e7\u00e3o da estrutura set : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 set < int > s ; s . insert ( 3 ); s . insert ( 2 ); s . insert ( 5 ); cout << s . count ( 3 ) << \" \\n \" ; // 1 cout << s . count ( 4 ) << \" \\n \" ; // 0 s . erase ( 3 ); s . insert ( 4 ); cout << s . count ( 3 ) << \" \\n \" ; // 0 cout << s . count ( 4 ) << \" \\n \" ; // 1 if ( s . find ( 7 ) == s . end ()){ cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; } auto menor = s . begin (); auto maior = s . end (); maior -- ; // (1) cout << \"O menor elemento do conjunto \u00e9: \" << * menor << \" \\n \" ; cout << \"O maior elemento do conjunto \u00e9: \" << * maior << \" \\n \" ; set < int > c1 = { 2 , 5 , 6 , 8 }; cout << c1 . size () << \" \\n \" ; // 4 for ( auto x : c1 ) cout << x << \" \\n \" ; set < int > c2 ; c2 . insert ( 5 ); c2 . insert ( 5 ); c2 . insert ( 5 ); cout << c2 . count ( 5 ) << \" \\n \" ; // 1 (2) Como end() aponta para um elemento ap\u00f3s o \u00faltimo elemento, deve-se diminuir o iterador em uma unidade. Lembre-se que em um set todos seus elementos s\u00e3o distintos. Assim, a fun\u00e7\u00e3o count sempre retornar ou 0 (elemento n\u00e3o est\u00e1 no set ) ou 1 (o elemento est\u00e1 no set ). A estrutura set tamb\u00e9m fornece as fun\u00e7\u00f5es lower_bound(x) e upper_bound(x) que retornam um iterador para o menor elemento em um set cujo valor \u00e9 pelo menos ou maior que x , respectivamente. Em ambas as fun\u00e7\u00f5es, se o elemento solicitado n\u00e3o existir, o valor de retorno \u00e9 end() . Um multiset \u00e9 um conjunto que pode conter v\u00e1rias c\u00f3pias do mesmo elemento. Por exemplo, o c\u00f3digo abaixo adiciona tr\u00eas c\u00f3pias do valor 5 ao multiset : 1 2 3 4 5 multiset < int > s ; s . insert ( 5 ); s . insert ( 5 ); s . insert ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 3 A fun\u00e7\u00e3o erase remove todas as c\u00f3pias de um valor do multiset : 1 2 s . erase ( 5 ); cout << s . count ( 5 ) << \" \\n \" ; // 0 Caso seja necess\u00e1rio remover apenas uma c\u00f3pia, pode-se fazer da seguinte forma: 1 2 s . erase ( s . find ( 5 )); cout << s . count ( 5 ) << \" \\n \" ; // 2 A figura abaixo mostra mais opera\u00e7\u00f5es e uso do set e multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Set in C++ Standard Template Library (STL) Multiset in C++ Standard Template Library (STL) std::set std::multiset","title":"set e multiset"},{"location":"ed1/#map-e-multimap","text":"Um map \u00e9 um conjunto que consiste em pares de valores-chave. Um map tamb\u00e9m pode ser visto como um array comum. Enquanto as chaves em um array s\u00e3o sempre inteiros consecutivos \\(0, 1, \\dots , n \u2212 1\\) , onde \\(n\\) \u00e9 o tamanho do array , as chaves em um map podem ser de qualquer tipo de dados e n\u00e3o precisam ser valores consecutivos. Como no set , o map \u00e9 baseado em em uma \u00e1rvore bin\u00e1ria balanceada ( red-black tree ) e acessar seus elementos \u00e9 \\(O(\\log n)\\) . O c\u00f3digo a seguir cria um map cujas chaves s\u00e3o strings e os valores s\u00e3o int : 1 2 3 4 5 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; cout << m [ \"Daniel\" ] << \" \\n \" ; // 38 Se o valor de uma chave for solicitado, mas que n\u00e3o existe no map , a chave ser\u00e1 adicionada automaticamente ao map com um valor padr\u00e3o do tipo (se for uma classe o construtor padr\u00e3o \u00e9 chamado). Por exemplo, no c\u00f3digo a seguir, a chave \"Ana\" com valor 0 \u00e9 adicionada ao map . 1 2 map < string , int > m ; cout << m [ \"Ana\" ] << \" \\n \" ; Veja mais alguns exemplos de utiliza\u00e7\u00e3o da estrutura: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; if ( m . find ( \"Ana\" ) == m . end ()) cout << \"N\u00e3o temos a idade da Ana registrada\" << \" \\n \" ; cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; cout << \"Bia tem \" << m [ \"Bia\" ] << \" anos \\n \" ; for ( auto x : m ) cout << x . first << \" \" << x . second << \" \\n \" ; m . erase ( \"Paulo\" ); cout << \"Paulo tem \" << m [ \"Paulo\" ] << \" anos \\n \" ; auto ultimo = -- m . end (); cout << ultimo -> first << \" tem \" << ultimo -> second << \" anos \\n \" ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do map e multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers Map in C++ Standard Template Library (STL) Multimap in C++ Standard Template Library (STL) std::map std::multimap","title":"map e multimap"},{"location":"ed1/#unordered_set-e-unordered_multiset","text":"Um unordered_set \u00e9 um cont\u00eainer associativo que cont\u00e9m um conjunto de objetos exclusivos. J\u00e1 um unordered_multiset permite c\u00f3pia dos elementos. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 unordered_set < int > s = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; s . erase ( 10 ); s . insert ( 4 ); cout << s . count ( 10 ) << \" \\n \" ; cout << s . count ( 4 ) << \" \\n \" ; if ( s . find ( 7 ) == s . end ()) cout << \"7 n\u00e3o est\u00e1 no set\" << \" \\n \" ; for ( auto x : s ) cout << x << \" \" ; cout << endl ; unordered_multiset < int > ms = { 10 , 5 , -1 , 20 , 15 , 5 , 19 }; for ( auto x : ms ) cout << x << \" \" ; cout << endl ; A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_set e unordered_multiset . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_set std::unordered_multiset","title":"unordered_set e unordered_multiset"},{"location":"ed1/#unordered_map-e-unordered_multimap","text":"\u00e9 um conjunto que consiste em pares de valores-chave Um unordered_map \u00e9 um cont\u00eainer associativo que cont\u00e9m pares de valores-chave com chaves exclusivas. J\u00e1 um unordered_multimap permite m\u00faltiplas c\u00f3pias das chaves. Ambas as estruturas s\u00e3o baseadas em tabela hash e suas opera\u00e7\u00f5es possuem complexidade, em m\u00e9dia, em tempo \\(O(1)\\) . Internamente, os elementos n\u00e3o seguem nenhuma ordem. Veja um exemplo de uso das estruturas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 unordered_map < string , int > m ; m [ \"Paulo\" ] = 22 ; m [ \"Daniel\" ] = 38 ; m [ \"Bia\" ] = 19 ; m [ \"Bia\" ] = 28 ; // Atualiza o valor da chave \"Bia\" for ( auto [ chave , valor ] : m ) cout << chave << \" -> \" << valor << \" \\n \" ; cout << endl ; unordered_multimap < string , int > mm ; mm . insert ( make_pair ( \"Paulo\" , 22 )); // (1) mm . insert ( make_pair ( \"Paulo\" , 43 )); mm . insert ( make_pair ( \"Bia\" , 19 )); mm . insert ( make_pair ( \"Bia\" , 22 )); for ( auto [ chave , valor ] : mm ) cout << chave << \" -> \" << valor << \" \\n \" ; N\u00e3o \u00e9 poss\u00edvel usar o operator[] como no map e unordered_map . A figura abaixo mostra mais opera\u00e7\u00f5es e uso do unordered_map e unordered_multimap . Fonte: Hacking C++ Complemente sua leitura e seu conhecimento: Standard Associative Containers std::unordered_map std::unordered_multimap O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 \u21a9","title":"unordered_map e unordered_multimap"},{"location":"ed2/","text":"Estrutura de Dados Nesta parte, ser\u00e3o apresentados duas estruturas baseadas em \u00e1rvores e uma implementa\u00e7\u00e3o de set do GNU C++. GNU C++ Policy-Based Sets O compilador GNU g++ tamb\u00e9m suporta algumas estruturas de dados que n\u00e3o fazem parte da biblioteca padr\u00e3o do C++. Essas estruturas s\u00e3o chamadas de estruturas de dados baseadas em pol\u00edticas ( Policy-Based Data Structures - PBDS ). Para usar essas estruturas \u00e9 necess\u00e1rio incluir o seguinte c\u00f3digo: 1 2 3 #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds ; Alternativamente, pode-se simplificar o c\u00f3digo anterior da seguinte forma: 1 2 #include <bits/extc++.h> using namespace __gnu_pbds ; Ap\u00f3s isso, \u00e9 poss\u00edvel definir um conjunto ordenado indexado (entre as dispon\u00edveis, essa \u00e9 a principal estrutura usada em competi\u00e7\u00f5es de programa\u00e7\u00e3o). Esta estrutura \u00e9 como o set , mas com a possibilidade de acessar os elementos de acordo com a sua posi\u00e7\u00e3o (\u00edndice), como em um array . O c\u00f3digo abaixo, define um conjunto ordenado indexado usando template . 1 2 template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; Veja alguns exemplos de uso da defini\u00e7\u00e3o anterior: 1 2 3 4 indexed_set < int > setInt ; // Conjunto ordenado indexado de inteiros indexed_set < double > setDouble ; // Conjunto ordenado indexado de doubles indexed_set < pair < int , int >> setPairInt ; // Conjunto ordenado indexado de pares de inteiros indexed_set < Pessoa > setPessoa ; // Conjunto ordenado indexado de Pessoas (precisa do operator<) Al\u00e9m das opera\u00e7\u00f5es comuns do set ( insert , erase , size , clear , find , begin , end ), ainda existem duas fun\u00e7\u00f5es muito \u00fateis e que justificam o uso do PBDS: find_by_order(k) : retorna um iterador para o \\(k\\) -\u00e9simo menor elemento (contando a partir de zero) do conjunto em tempo \\(O(\\log n)\\) ; order_of_key(x) : retorna ao n\u00famero de itens estritamente menores que o x em tempo \\(O(\\log n)\\) . Veja um exemplo completo de utiliza\u00e7\u00e3o do PBDS (Fonte: pbds.cpp ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <bits/stdc++.h> #include <bits/extc++.h> // pbds using namespace std ; using namespace __gnu_pbds ; template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; int main () { int n = 9 ; vector < int > A = { 71 , 10 , 2 , 4 , 23 , 7 , 10 , 15 , 23 , 50 , 65 , 71 }; indexed_set < int > iset ; for ( int i = 0 ; i < A . size (); ++ i ) // O(n log n) iset . insert ( A [ i ]); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 9 for ( auto x : iset ) cout << x << \" \" ; cout << \" \\n \" ; // O(log n) select cout << * iset . find_by_order ( 0 ) << \" \\n \" ; // 1-smallest = 2 cout << * iset . find_by_order ( n -1 ) << \" \\n \" ; // 9-smallest/largest = 71 cout << * iset . find_by_order ( 4 ) << \" \\n \" ; // 5-smallest = 15 // O(log n) rank cout << iset . order_of_key ( 2 ) << \" \\n \" ; // index 0 (rank 1) cout << iset . order_of_key ( 71 ) << \" \\n \" ; // index 8 (rank 9) cout << iset . order_of_key ( 15 ) << \" \\n \" ; // index 4 (rank 5) iset . erase ( 2 ); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 8 return 0 ; } Complemente sua leitura e seu conhecimento: Ordered Set and GNU C++ PBDS (GeeksforGeeks) C++ STL: Policy based data structures PBDS Examples Fenwick (Binary Indexed) Tree Em constru\u00e7\u00e3o... Segment Tree Em constru\u00e7\u00e3o...","title":"Estrutura de Dados (Parte 2)"},{"location":"ed2/#estrutura-de-dados","text":"Nesta parte, ser\u00e3o apresentados duas estruturas baseadas em \u00e1rvores e uma implementa\u00e7\u00e3o de set do GNU C++.","title":"Estrutura de Dados"},{"location":"ed2/#gnu-c-policy-based-sets","text":"O compilador GNU g++ tamb\u00e9m suporta algumas estruturas de dados que n\u00e3o fazem parte da biblioteca padr\u00e3o do C++. Essas estruturas s\u00e3o chamadas de estruturas de dados baseadas em pol\u00edticas ( Policy-Based Data Structures - PBDS ). Para usar essas estruturas \u00e9 necess\u00e1rio incluir o seguinte c\u00f3digo: 1 2 3 #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp> using namespace __gnu_pbds ; Alternativamente, pode-se simplificar o c\u00f3digo anterior da seguinte forma: 1 2 #include <bits/extc++.h> using namespace __gnu_pbds ; Ap\u00f3s isso, \u00e9 poss\u00edvel definir um conjunto ordenado indexado (entre as dispon\u00edveis, essa \u00e9 a principal estrutura usada em competi\u00e7\u00f5es de programa\u00e7\u00e3o). Esta estrutura \u00e9 como o set , mas com a possibilidade de acessar os elementos de acordo com a sua posi\u00e7\u00e3o (\u00edndice), como em um array . O c\u00f3digo abaixo, define um conjunto ordenado indexado usando template . 1 2 template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; Veja alguns exemplos de uso da defini\u00e7\u00e3o anterior: 1 2 3 4 indexed_set < int > setInt ; // Conjunto ordenado indexado de inteiros indexed_set < double > setDouble ; // Conjunto ordenado indexado de doubles indexed_set < pair < int , int >> setPairInt ; // Conjunto ordenado indexado de pares de inteiros indexed_set < Pessoa > setPessoa ; // Conjunto ordenado indexado de Pessoas (precisa do operator<) Al\u00e9m das opera\u00e7\u00f5es comuns do set ( insert , erase , size , clear , find , begin , end ), ainda existem duas fun\u00e7\u00f5es muito \u00fateis e que justificam o uso do PBDS: find_by_order(k) : retorna um iterador para o \\(k\\) -\u00e9simo menor elemento (contando a partir de zero) do conjunto em tempo \\(O(\\log n)\\) ; order_of_key(x) : retorna ao n\u00famero de itens estritamente menores que o x em tempo \\(O(\\log n)\\) . Veja um exemplo completo de utiliza\u00e7\u00e3o do PBDS (Fonte: pbds.cpp ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <bits/stdc++.h> #include <bits/extc++.h> // pbds using namespace std ; using namespace __gnu_pbds ; template < class T > using indexed_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; int main () { int n = 9 ; vector < int > A = { 71 , 10 , 2 , 4 , 23 , 7 , 10 , 15 , 23 , 50 , 65 , 71 }; indexed_set < int > iset ; for ( int i = 0 ; i < A . size (); ++ i ) // O(n log n) iset . insert ( A [ i ]); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 9 for ( auto x : iset ) cout << x << \" \" ; cout << \" \\n \" ; // O(log n) select cout << * iset . find_by_order ( 0 ) << \" \\n \" ; // 1-smallest = 2 cout << * iset . find_by_order ( n -1 ) << \" \\n \" ; // 9-smallest/largest = 71 cout << * iset . find_by_order ( 4 ) << \" \\n \" ; // 5-smallest = 15 // O(log n) rank cout << iset . order_of_key ( 2 ) << \" \\n \" ; // index 0 (rank 1) cout << iset . order_of_key ( 71 ) << \" \\n \" ; // index 8 (rank 9) cout << iset . order_of_key ( 15 ) << \" \\n \" ; // index 4 (rank 5) iset . erase ( 2 ); cout << \"Set size: \" << iset . size () << \" \\n \" ; // 8 return 0 ; } Complemente sua leitura e seu conhecimento: Ordered Set and GNU C++ PBDS (GeeksforGeeks) C++ STL: Policy based data structures PBDS Examples","title":"GNU C++ Policy-Based Sets"},{"location":"ed2/#fenwick-binary-indexed-tree","text":"Em constru\u00e7\u00e3o...","title":"Fenwick (Binary Indexed) Tree"},{"location":"ed2/#segment-tree","text":"Em constru\u00e7\u00e3o...","title":"Segment Tree"},{"location":"gc/","text":"Geometria Computacional Em constru\u00e7\u00e3o...","title":"Geometria Computacional"},{"location":"gc/#geometria-computacional","text":"Em constru\u00e7\u00e3o...","title":"Geometria Computacional"},{"location":"grafos/","text":"Grafos Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"grafos/#grafos","text":"Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"guloso/","text":"Algoritmos Gulosos Em constru\u00e7\u00e3o...","title":"Algoritmos Gulosos"},{"location":"guloso/#algoritmos-gulosos","text":"Em constru\u00e7\u00e3o...","title":"Algoritmos Gulosos"},{"location":"inicio/","text":"Programa\u00e7\u00e3o Competitiva Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 . Caracter\u00edsticas da linguagem 1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada. Entrada e Sa\u00edda Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output Trabalhando com n\u00fameros Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types Simplificando o c\u00f3digo Nomes de tipos Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ; Macros Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) . Dicas e truques de C++ A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Inicio"},{"location":"inicio/#programacao-competitiva","text":"Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 .","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"inicio/#caracteristicas-da-linguagem","text":"1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada.","title":"Caracter\u00edsticas da linguagem"},{"location":"inicio/#entrada-e-saida","text":"Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output","title":"Entrada e Sa\u00edda"},{"location":"inicio/#trabalhando-com-numeros","text":"Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types","title":"Trabalhando com n\u00fameros"},{"location":"inicio/#simplificando-o-codigo","text":"","title":"Simplificando o c\u00f3digo"},{"location":"inicio/#nomes-de-tipos","text":"Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ;","title":"Nomes de tipos"},{"location":"inicio/#macros","text":"Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) .","title":"Macros"},{"location":"inicio/#dicas-e-truques-de-c","text":"A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Dicas e truques de C++"},{"location":"manipulacaobits/","text":"Manipula\u00e7\u00e3o de Bits Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequ\u00eancia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequ\u00eancia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valores inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorrer\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois). Operadores sobre Bits Operador AND ( & e &= ) Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) . Operador OR inclusivo ( | e |= ) Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110 Operador OR exclusivo ( ^ e ^= ) Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110 Operador NOT ( ~ e ~= ) Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A f\u00f3rmula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 . Operador de deslocamento \u00e0 esquerda ( << e <<= ) Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56 Operador de deslocamento \u00e0 direita ( >> e >>= ) Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010000 -> 16 a = a >> 1 // 00001000 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7 Fun\u00e7\u00f5es adicionais O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x) Alguns truques e aplica\u00e7\u00f5es Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois. std::bitset Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o . Links adicionais Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#manipulacao-de-bits","text":"Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequ\u00eancia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequ\u00eancia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valores inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorrer\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois).","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#operadores-sobre-bits","text":"","title":"Operadores sobre Bits"},{"location":"manipulacaobits/#operador-and-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) .","title":"Operador AND (&amp; e &amp;=)"},{"location":"manipulacaobits/#operador-or-inclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110","title":"Operador OR inclusivo (| e |=)"},{"location":"manipulacaobits/#operador-or-exclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110","title":"Operador OR exclusivo (^ e ^=)"},{"location":"manipulacaobits/#operador-not-e","text":"Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A f\u00f3rmula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 .","title":"Operador NOT (~ e ~=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-esquerda-e","text":"Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56","title":"Operador de deslocamento \u00e0 esquerda (&lt;&lt; e &lt;&lt;=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-direita-e","text":"Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010000 -> 16 a = a >> 1 // 00001000 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7","title":"Operador de deslocamento \u00e0 direita (&gt;&gt; e &gt;&gt;=)"},{"location":"manipulacaobits/#funcoes-adicionais","text":"O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x)","title":"Fun\u00e7\u00f5es adicionais"},{"location":"manipulacaobits/#alguns-truques-e-aplicacoes","text":"Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois.","title":"Alguns truques e aplica\u00e7\u00f5es"},{"location":"manipulacaobits/#stdbitset","text":"Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o .","title":"std::bitset"},{"location":"manipulacaobits/#links-adicionais","text":"Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Links adicionais"},{"location":"ordenacao/","text":"Ordena\u00e7\u00e3o e Busca 1 Ordena\u00e7\u00e3o A maioria das linguagens de programa\u00e7\u00e3o modernas implementa uma fun\u00e7\u00e3o de ordena\u00e7\u00e3o eficiente. Em C++, tem-se a fun\u00e7\u00e3o sort da biblioteca <algorithm> . Veja alguns exemplos de uso desta fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 int n = 7 ; int a [] = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( a , a + n ); // (1) vector < int > v = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( v . begin (), v . end ()); // (2) vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . begin (), alunos . end ()); // (3) for ( auto a : alunos ) cout << a . first << \" \" << a . second << endl ; // (4) [2, 3, 3, 4, 5, 5, 8] [2, 3, 3, 4, 5, 5, 8] Por padr\u00e3o, um pair sempre \u00e9 ordenado pelo campo first . {123, Paulo} {456, Ana} {789, Paulo} A ordena\u00e7\u00e3o padr\u00e3o \u00e9 a n\u00e3o-decrescente, mas pode-se obter a ordem inversa da seguinte forma: 1 2 3 4 vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . rbegin (), alunos . rend ()); for ( auto a : alunos ) // (1) cout << a . first << \" \" << a . second << endl ; {789, Paulo} {456, Ana} {123, Paulo} Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Agora suponha que seja necess\u00e1rio ordenar objetos do tipo Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ // (1) this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; Construtor padr\u00e3o usado quando n\u00e3o passamos nenhum argumento para a classe. Sempre fa\u00e7a o construtor padr\u00e3o. Caso contr\u00e1rio, n\u00e3o ser\u00e1 possivel fazer, por exemplo: Pessoa p ; //Chama o construtor padr\u00e3o . Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Usando uma fun\u00e7\u00e3o de compara\u00e7\u00e3o A primeira alternativa \u00e9 definir uma fun\u00e7\u00e3o que compara dois objetos e retorna true caso o primeiro seja considerado menor que o segundo e false , caso contr\u00e1rio. Por exemplo, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool compara ( const Pessoa & p1 , const Pessoa & p2 ) { // (1) if ( p1 . nome < p2 . nome ) return true ; else if ( p1 . nome == p2 . nome ) { if ( p1 . sobrenome < p2 . sobrenome ) return true ; else if ( p1 . sobrenome == p2 . sobrenome ) return p1 . idade > p2 . idade ; else return false ; } else return false ; } O const diz ao compilador que os objetos passados para a fun\u00e7\u00e3o n\u00e3o ser\u00e3o alterados internamento. J\u00e1 o & representa passagem por refer\u00eancia , uma alternativa a passagem por ponteiro . Dessa forma, n\u00e3o passamos uma c\u00f3pia dos objetos e sim refer\u00eancias (endere\u00e7os) dos mesmos, o que torna o c\u00f3digo mais eficiente. Por qu\u00ea? Com a fun\u00e7\u00e3o de compara\u00e7\u00e3o definida, basta pass\u00e1-la como argumento na fun\u00e7\u00e3o sort : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); // (1) lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end (), compara ); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Inclui o elemento no fim do vector . Leia mais sobre vector aqui . Usa a fun\u00e7\u00e3o compara para fazer a ordena\u00e7\u00e3o. Tamb\u00e9m \u00e9 possivel usar uma fun\u00e7\u00e3o lambda como fun\u00e7\u00e3o de compara\u00e7\u00e3o. Por exemplo, para ordenar um pair pelo campo second (ou usando-o como crit\u00e9rio de desempate), pode-se fazer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool compara ( const pair < int , int > & p1 , const pair < int , int > & p2 ) { if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; } int main () { vector < pair < int , int >> pontos = {{ 0 , 2 }, { 0 , 1 }, { 0 , 0 }, { 0 , -5 }, { 1 , 2 }, { -1 , 10 }}; sort ( pontos . begin (), pontos . end (), compara ); // (1) for ( auto a : pontos ) // (2) cout << \"(\" << a . first << \", \" << a . second << \") \" ; sort ( pontos . begin (), pontos . end (), []( const pair < int , int > & p1 , const pair < int , int > & p2 ) { // (3) if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; }); for ( auto a : pontos ) cout << \"(\" << a . first << \", \" << a . second << \") \" ; return 0 ; } Usando a fun\u00e7\u00e3o compara (-1, 10) (0, -5) (0, 0) (0, 1) (0, 2) (1, 2) Usando fun\u00e7\u00e3o lambda Fazando a sobrecarga do operador < Ao inv\u00e9s de ser difinidas fun\u00e7\u00f5es de compara\u00e7\u00f5es, pode-se fazer a sobrecarga do operador < ( operator < ). Isso \u00e9 comum ao se usar class ou struct . Veja como ficaria ao ser considerado a classe Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } bool operator < ( const Pessoa & p ){ // (1) if ( nome < p . nome ) return true ; else if ( nome == p . nome ) { if ( sobrenome < p . sobrenome ) return true ; else if ( sobrenome == p . sobrenome ) return idade > p . idade ; else return false ; } else return false ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end ()); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Sobrecarga/defini\u00e7\u00e3o do operador < para a classe Pessoa . Dessa forma, \u00e9 possivel fazer a compara\u00e7\u00e3o p1 < p2 , considerando que p1 e p2 s\u00e3o objetos do tipo Pessoa . Usa o operador < para fazer a ordena\u00e7\u00e3o. Complemente sua leitura e seu conhecimento Competitive Programmer\u2019s Handbook Sorting (CS Academy) std::sort std::partial_sort std::stable_sort std::nth_element Busca Busca sequencial A forma mais intuitiva para procurar um elemento em um array \u00e9 usar um loop que percorre todos os elementos do array e parando assim que o elemento buscado \u00e9 encontrado. No pior caso, \u00e9 necess\u00e1rio percorrer todos os elementos, logo a complexidade ser\u00e1 \\(O(n)\\) . O c\u00f3digo abaixo verifica se x est\u00e1 no array : 1 2 3 4 5 for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] == x ) { // x encontrado na posi\u00e7\u00e3o i } } Em C++, pode-se usar a fun\u00e7\u00e3o search . Busca bin\u00e1ria Se os elementos do array estiverem ordenados, pode-se usar uma estrat\u00e9gia diferente e mais eficiente para realizar a busca: verifique se o elemento do meio do array \u00e9 o elementos buscado, se for, a busca termina. Caso n\u00e3o seja, verique se o elemento do meio \u00e9 menor que elemento buscaso, se for, repita o processo considerando apenas a segunda metade do array . Sen\u00e3o, considere a primeira metade do array . Assim, a cada passo da busca, o tamanho do array \u00e9 reduzido a metade, logo, a complexidade do algoritmo \u00e9 \\(O(\\log n)\\) . 1 2 3 4 5 6 7 8 9 10 int buscaBinaria ( vector < int > v , int x ) { int ini = 0 , fim = v . size () -1 ; while ( ini <= fim ) { int meio = ini + ( fim - ini ) / 2 ; // (1) if ( v [ meio ] == x ) return meio ; else if ( v [ meio ] < x ) ini = meio + 1 ; else fim = meio - 1 ; } return -1 ; // (2) } Evite usar meio = (ini + fim) / 2; , j\u00e1 que ini + fim pode gerar integer overflow . x n\u00e3o est\u00e1 no vetor v . Em C++, pode-se usar a fun\u00e7\u00e3o std::binary_search . As fun\u00e7\u00f5es abaixo tamb\u00e9m s\u00e3o \u00fateis e baseadas na busca bin\u00e1ria: std::lower_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 pelo menos x ; std::upper_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 maior que x ; As fun\u00e7\u00f5es assumem que o array est\u00e1 ordenado. Se o valor procurado n\u00e3o for encontrado, \u00e9 retornado um ponteiro para o elemento ap\u00f3s o \u00faltimo elemento do array . Por exemplo, o c\u00f3digo a seguir verifica se o array cont\u00e9m um elemento com valor x : 1 2 3 4 5 6 7 vector < int > v = { 1 , 2 , 3 , 5 , 8 , 10 , 20 }; int x = 10 ; auto k = lower_bound ( v . begin (), v . end (), x ); if ( k != v . end () && * k == x ) { // x encontrado no indice k cout << \"Valor encontrado na posi\u00e7\u00e3o: \" << k - v . begin () << endl ; // (1) } Pode-se usar a fun\u00e7\u00e3o std::distance ao inv\u00e9s de k - v.begin() , ou seja, distance(v.begin(), k) . Complemente sua leitura e seu conhecimento: Binary Search tutorial (C++ and Python) Busca Bin\u00e1ria Binary Search Binary Search (ITMO Academy) \ud83e\udd2f Binary Search (CS Academy) Busca bin\u00e1ria em fun\u00e7\u00f5es monot\u00f4nicas 2 Considere uma fun\u00e7\u00e3o booleana \\(f(x)\\) e se deseja encontrar o valor m\u00e1ximo (ou m\u00ednimo) de \\(x\\) tal que \\(f(x)\\) seja true . Da mesma forma que a busca bin\u00e1ria s\u00f3 funciona se o array estiver ordenado, s\u00f3 \u00e9 possivel aplicar a busca bin\u00e1ria em uma fun\u00e7\u00e3o mon\u00f3tona , ou seja, \u00e9 sempre n\u00e3o-decrescente ou sempre n\u00e3o-crescente. Seja check(x) uma fun\u00e7\u00e3o que verifica uma propriedade de x . Se para todo x , check ( x ) = true implica check ( x + 1 ) = true , ou para todo x , check ( x ) = false implica check ( x + 1 ) = false , ent\u00e3o a fun\u00e7\u00e3o check \u00e9 mon\u00f3tona. Suponha a fun\u00e7\u00e3o check abaixo que verifica se um elemento \u00e9 maior ou igual a x .. Se x = 11 e o vetor v = [1,2,3,5, 8, 11, 12, 14, 16] , ent\u00e3o teremos o seguinte vetor de sa\u00edda ao aplicarmos check em v : [0,0,0,0,0,1,1,1,1,1] . 1 2 3 bool check ( int val ) { return val >= x ; } Dessa forma, a fun\u00e7\u00e3o check para essa situa\u00e7\u00e3o \u00e9 mon\u00f3tona e isso \u00e9 relevante porque se um valor do vetor satisfizer a condi\u00e7\u00e3o, todos os valores a direita tamb\u00e9m v\u00e3o satisfaz\u00ea-la, e de forma an\u00e1loga, todos os valores a esquerda de um \u00edndice que n\u00e3o satisfaz a condi\u00e7\u00e3o, tamb\u00e9m n\u00e3o v\u00e3o satisfazer, e \u00e9 isso que nos permite aplicar busca bin\u00e1ria. Al\u00e9m disso, a fun\u00e7\u00e3o check s\u00f3 se torna mon\u00f3tona nesse exemplo quando o vetor est\u00e1 ordenado, por isso a busca bin\u00e1ria s\u00f3 \u00e9 feita em vetores ordenados. Como encontrar o menor valor que torna check verdadeiro? R. inicia-se o processo \"chutanto\" um intervalo onde a resposta com certeza estar\u00e1. Para cada intevalo, checa-se o meio e, dependendo da resposta, descarta-se os elementos a direita ou a esquerda, mas sempre divide-se o tamanho do intervalo por 2, at\u00e9 que o intervalo tenha tamanho 1. Veja uma solu\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int l = a ; // sei que a resposta n\u00e3o \u00e9 menos que a int r = b ; // sei que a resposta n\u00e3o \u00e9 mais que b while ( r > l + 1 ){ // repita enquanto o intervalo tiver tamanho > 2 int mid = l + ( r - l ) / 2 ; if ( check ( mid )){ // mid \u00e9 v\u00e1lido r = mid ; // como queremos minimizar a resposta, e mid \u00e9 uma resposta v\u00e1lida //descartamos tudo a direita de mid (mas n\u00e3o mid) } else { l = mid + 1 ; // Se mid n\u00e3o \u00e9 v\u00e1lido, descartamos ele e tudo abaixo. } } // Ao final desse la\u00e7o, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent\u00e3o se l for v\u00e1lido, // ficaremos com l, e caso contr\u00e1rio, com r int ans = r ; if ( check ( l )) ans = l ; Exemplo: Encontrar o maior valor de \\(x \\in [0, 10]\\) tal que \\(x^2 \\leq 30\\) . 1 2 3 4 5 6 7 8 9 10 11 12 bool check ( int val ) { return val * val <= 30 ; } int lastTrue ( int ini , int fim ) { ini -- ; // Se nenhum valor no intervalor for true, retorna ini - 1 while ( ini < fim ) { int m = ini + ( fim - ini ) / 2 ; if ( check ( m )) ini = m ; // (1) else fim = m - 1 ; // (2) } return ini ; } Se check ( m ) \u00e9 true , ent\u00e3o todos os n\u00fameros menores que m tamb\u00e9m ser\u00e3o true . Se check ( m ) \u00e9 false , ent\u00e3o todos os n\u00fameros maiores que m tamb\u00e9m ser\u00e3o false . Two-Pointers Na t\u00e9cnica chamada Two-Pointers dois \"aponstadores\" caminham pelo vetor. Normalmente, esses apontadores s\u00e3o ``colocados'' nas extremidades opostas do vetor e caminham um em dire\u00e7\u00e3o ao outro, como mostra a figura abaixo. Fonte: AfterAcademy Voc\u00ea consegue pensar em como usar esse t\u00e9cnica para resolver o problema de inverter os elementos de um vetor sem usar um vetor auxiliar? A ideia \u00e9 simples: coloque cada apontador (digamos i e j ) em uma extremidade do vetor, ou seja, i = 0 e j = n - 1 , e, a cada itera\u00e7\u00e3o, troque os elementos que est\u00e3o nas posi\u00e7\u00f5es i e j (ou seja, v[i] <-> v[j] ). Ap\u00f3s a troca, incremente o apontador i e decremente o apontador j . Repita esse processo enquanto i < j . A figura abaixo ilustra parte desse processo. Fonte: AfterAcademy O c\u00f3digo abaixo ilustra essa estrat\u00e9gia (note a simplicidade): 1 2 3 4 5 6 7 8 9 void inverte ( vector < int > & v ) { // (1) int i = 0 ; int j = v . size () - 1 ; while ( i < j ) { swap ( v [ i ], v [ j ]); // (2) i ++ ; j -- ; } } A std::reverse tamb\u00e9m pode ser usada com o mesmo objetivo. O intuito \u00e9 mostrar com a t\u00e9cnica Two-Pointers funciona. std::swap Complemente sua leitura e seu conhecimento: Two Pointers Method (ITMO Academy) \ud83e\udd2f Two Pointers Technique What is the Two pointer technique? O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9 Conte\u00fado extra\u00eddo de Busca Bin\u00e1ria \u21a9","title":"Ordena\u00e7\u00e3o e Busca"},{"location":"ordenacao/#ordenacao-e-busca1","text":"","title":"Ordena\u00e7\u00e3o e Busca1"},{"location":"ordenacao/#ordenacao","text":"A maioria das linguagens de programa\u00e7\u00e3o modernas implementa uma fun\u00e7\u00e3o de ordena\u00e7\u00e3o eficiente. Em C++, tem-se a fun\u00e7\u00e3o sort da biblioteca <algorithm> . Veja alguns exemplos de uso desta fun\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 int n = 7 ; int a [] = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( a , a + n ); // (1) vector < int > v = { 4 , 2 , 5 , 3 , 5 , 8 , 3 }; sort ( v . begin (), v . end ()); // (2) vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . begin (), alunos . end ()); // (3) for ( auto a : alunos ) cout << a . first << \" \" << a . second << endl ; // (4) [2, 3, 3, 4, 5, 5, 8] [2, 3, 3, 4, 5, 5, 8] Por padr\u00e3o, um pair sempre \u00e9 ordenado pelo campo first . {123, Paulo} {456, Ana} {789, Paulo} A ordena\u00e7\u00e3o padr\u00e3o \u00e9 a n\u00e3o-decrescente, mas pode-se obter a ordem inversa da seguinte forma: 1 2 3 4 vector < pair < int , string >> alunos = {{ 789 , \"Paulo\" }, { 456 , \"Ana\" }, { 123 , \"Paulo\" }}; sort ( alunos . rbegin (), alunos . rend ()); for ( auto a : alunos ) // (1) cout << a . first << \" \" << a . second << endl ; {789, Paulo} {456, Ana} {123, Paulo} Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < . Agora suponha que seja necess\u00e1rio ordenar objetos do tipo Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ // (1) this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; Construtor padr\u00e3o usado quando n\u00e3o passamos nenhum argumento para a classe. Sempre fa\u00e7a o construtor padr\u00e3o. Caso contr\u00e1rio, n\u00e3o ser\u00e1 possivel fazer, por exemplo: Pessoa p ; //Chama o construtor padr\u00e3o . Para ordernarmos um struct ou class ou outra cole\u00e7\u00e3o de objetos (por exemplo, um pair pelo campo second ), tem-se duas alternativas: ( \\(i\\) ) definir uma fun\u00e7\u00e3o de compara\u00e7\u00e3o ou ( \\(ii\\) ) fazer a sobrecarga do operador < .","title":"Ordena\u00e7\u00e3o"},{"location":"ordenacao/#usando-uma-funcao-de-comparacao","text":"A primeira alternativa \u00e9 definir uma fun\u00e7\u00e3o que compara dois objetos e retorna true caso o primeiro seja considerado menor que o segundo e false , caso contr\u00e1rio. Por exemplo, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool compara ( const Pessoa & p1 , const Pessoa & p2 ) { // (1) if ( p1 . nome < p2 . nome ) return true ; else if ( p1 . nome == p2 . nome ) { if ( p1 . sobrenome < p2 . sobrenome ) return true ; else if ( p1 . sobrenome == p2 . sobrenome ) return p1 . idade > p2 . idade ; else return false ; } else return false ; } O const diz ao compilador que os objetos passados para a fun\u00e7\u00e3o n\u00e3o ser\u00e3o alterados internamento. J\u00e1 o & representa passagem por refer\u00eancia , uma alternativa a passagem por ponteiro . Dessa forma, n\u00e3o passamos uma c\u00f3pia dos objetos e sim refer\u00eancias (endere\u00e7os) dos mesmos, o que torna o c\u00f3digo mais eficiente. Por qu\u00ea? Com a fun\u00e7\u00e3o de compara\u00e7\u00e3o definida, basta pass\u00e1-la como argumento na fun\u00e7\u00e3o sort : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); // (1) lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end (), compara ); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Inclui o elemento no fim do vector . Leia mais sobre vector aqui . Usa a fun\u00e7\u00e3o compara para fazer a ordena\u00e7\u00e3o. Tamb\u00e9m \u00e9 possivel usar uma fun\u00e7\u00e3o lambda como fun\u00e7\u00e3o de compara\u00e7\u00e3o. Por exemplo, para ordenar um pair pelo campo second (ou usando-o como crit\u00e9rio de desempate), pode-se fazer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool compara ( const pair < int , int > & p1 , const pair < int , int > & p2 ) { if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; } int main () { vector < pair < int , int >> pontos = {{ 0 , 2 }, { 0 , 1 }, { 0 , 0 }, { 0 , -5 }, { 1 , 2 }, { -1 , 10 }}; sort ( pontos . begin (), pontos . end (), compara ); // (1) for ( auto a : pontos ) // (2) cout << \"(\" << a . first << \", \" << a . second << \") \" ; sort ( pontos . begin (), pontos . end (), []( const pair < int , int > & p1 , const pair < int , int > & p2 ) { // (3) if ( p1 . first < p2 . first ) return true ; else if ( p1 . first == p2 . first ) return p1 . second < p2 . second ; else return false ; }); for ( auto a : pontos ) cout << \"(\" << a . first << \", \" << a . second << \") \" ; return 0 ; } Usando a fun\u00e7\u00e3o compara (-1, 10) (0, -5) (0, 0) (0, 1) (0, 2) (1, 2) Usando fun\u00e7\u00e3o lambda","title":"Usando uma fun\u00e7\u00e3o de compara\u00e7\u00e3o"},{"location":"ordenacao/#fazando-a-sobrecarga-do-operador","text":"Ao inv\u00e9s de ser difinidas fun\u00e7\u00f5es de compara\u00e7\u00f5es, pode-se fazer a sobrecarga do operador < ( operator < ). Isso \u00e9 comum ao se usar class ou struct . Veja como ficaria ao ser considerado a classe Pessoa : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Pessoa { public : string nome , sobrenome ; int idade ; Pessoa (){ this -> nome = \"\" ; this -> sobrenome = \"\" ; this -> idade = 0 ; } Pessoa ( string _nome , string _sobrenome , int _idade ){ this -> nome = _nome ; this -> sobrenome = _sobrenome ; this -> idade = _idade ; } bool operator < ( const Pessoa & p ){ // (1) if ( nome < p . nome ) return true ; else if ( nome == p . nome ) { if ( sobrenome < p . sobrenome ) return true ; else if ( sobrenome == p . sobrenome ) return idade > p . idade ; else return false ; } else return false ; } void imprime () { cout << \"(\" << nome << \", \" << sobrenome << \", \" << idade << \") \\n \" ; } }; int main () { Pessoa p1 ( \"Paulo\" , \"Roberto\" , 35 ); Pessoa p2 ( \"Paulo\" , \"Alberto\" , 30 ); Pessoa p3 ( \"Paulo\" , \"Roberto\" , 40 ); vector < Pessoa > lista ; lista . push_back ( p1 ); lista . push_back ( p2 ); lista . push_back ( p3 ); for ( auto p : lista ) p . imprime (); cout << \" \\n \" ; sort ( lista . begin (), lista . end ()); // (2) for ( auto p : lista ) p . imprime (); return 0 ; } Sobrecarga/defini\u00e7\u00e3o do operador < para a classe Pessoa . Dessa forma, \u00e9 possivel fazer a compara\u00e7\u00e3o p1 < p2 , considerando que p1 e p2 s\u00e3o objetos do tipo Pessoa . Usa o operador < para fazer a ordena\u00e7\u00e3o.","title":"Fazando a sobrecarga do operador &lt;"},{"location":"ordenacao/#complemente-sua-leitura-e-seu-conhecimento","text":"Competitive Programmer\u2019s Handbook Sorting (CS Academy) std::sort std::partial_sort std::stable_sort std::nth_element","title":"Complemente sua leitura e seu conhecimento"},{"location":"ordenacao/#busca","text":"","title":"Busca"},{"location":"ordenacao/#busca-sequencial","text":"A forma mais intuitiva para procurar um elemento em um array \u00e9 usar um loop que percorre todos os elementos do array e parando assim que o elemento buscado \u00e9 encontrado. No pior caso, \u00e9 necess\u00e1rio percorrer todos os elementos, logo a complexidade ser\u00e1 \\(O(n)\\) . O c\u00f3digo abaixo verifica se x est\u00e1 no array : 1 2 3 4 5 for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] == x ) { // x encontrado na posi\u00e7\u00e3o i } } Em C++, pode-se usar a fun\u00e7\u00e3o search .","title":"Busca sequencial"},{"location":"ordenacao/#busca-binaria","text":"Se os elementos do array estiverem ordenados, pode-se usar uma estrat\u00e9gia diferente e mais eficiente para realizar a busca: verifique se o elemento do meio do array \u00e9 o elementos buscado, se for, a busca termina. Caso n\u00e3o seja, verique se o elemento do meio \u00e9 menor que elemento buscaso, se for, repita o processo considerando apenas a segunda metade do array . Sen\u00e3o, considere a primeira metade do array . Assim, a cada passo da busca, o tamanho do array \u00e9 reduzido a metade, logo, a complexidade do algoritmo \u00e9 \\(O(\\log n)\\) . 1 2 3 4 5 6 7 8 9 10 int buscaBinaria ( vector < int > v , int x ) { int ini = 0 , fim = v . size () -1 ; while ( ini <= fim ) { int meio = ini + ( fim - ini ) / 2 ; // (1) if ( v [ meio ] == x ) return meio ; else if ( v [ meio ] < x ) ini = meio + 1 ; else fim = meio - 1 ; } return -1 ; // (2) } Evite usar meio = (ini + fim) / 2; , j\u00e1 que ini + fim pode gerar integer overflow . x n\u00e3o est\u00e1 no vetor v . Em C++, pode-se usar a fun\u00e7\u00e3o std::binary_search . As fun\u00e7\u00f5es abaixo tamb\u00e9m s\u00e3o \u00fateis e baseadas na busca bin\u00e1ria: std::lower_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 pelo menos x ; std::upper_bound : retorna um ponteiro para o primeiro elemento do array cujo valor \u00e9 maior que x ; As fun\u00e7\u00f5es assumem que o array est\u00e1 ordenado. Se o valor procurado n\u00e3o for encontrado, \u00e9 retornado um ponteiro para o elemento ap\u00f3s o \u00faltimo elemento do array . Por exemplo, o c\u00f3digo a seguir verifica se o array cont\u00e9m um elemento com valor x : 1 2 3 4 5 6 7 vector < int > v = { 1 , 2 , 3 , 5 , 8 , 10 , 20 }; int x = 10 ; auto k = lower_bound ( v . begin (), v . end (), x ); if ( k != v . end () && * k == x ) { // x encontrado no indice k cout << \"Valor encontrado na posi\u00e7\u00e3o: \" << k - v . begin () << endl ; // (1) } Pode-se usar a fun\u00e7\u00e3o std::distance ao inv\u00e9s de k - v.begin() , ou seja, distance(v.begin(), k) . Complemente sua leitura e seu conhecimento: Binary Search tutorial (C++ and Python) Busca Bin\u00e1ria Binary Search Binary Search (ITMO Academy) \ud83e\udd2f Binary Search (CS Academy)","title":"Busca bin\u00e1ria"},{"location":"ordenacao/#busca-binaria-em-funcoes-monotonicas2","text":"Considere uma fun\u00e7\u00e3o booleana \\(f(x)\\) e se deseja encontrar o valor m\u00e1ximo (ou m\u00ednimo) de \\(x\\) tal que \\(f(x)\\) seja true . Da mesma forma que a busca bin\u00e1ria s\u00f3 funciona se o array estiver ordenado, s\u00f3 \u00e9 possivel aplicar a busca bin\u00e1ria em uma fun\u00e7\u00e3o mon\u00f3tona , ou seja, \u00e9 sempre n\u00e3o-decrescente ou sempre n\u00e3o-crescente. Seja check(x) uma fun\u00e7\u00e3o que verifica uma propriedade de x . Se para todo x , check ( x ) = true implica check ( x + 1 ) = true , ou para todo x , check ( x ) = false implica check ( x + 1 ) = false , ent\u00e3o a fun\u00e7\u00e3o check \u00e9 mon\u00f3tona. Suponha a fun\u00e7\u00e3o check abaixo que verifica se um elemento \u00e9 maior ou igual a x .. Se x = 11 e o vetor v = [1,2,3,5, 8, 11, 12, 14, 16] , ent\u00e3o teremos o seguinte vetor de sa\u00edda ao aplicarmos check em v : [0,0,0,0,0,1,1,1,1,1] . 1 2 3 bool check ( int val ) { return val >= x ; } Dessa forma, a fun\u00e7\u00e3o check para essa situa\u00e7\u00e3o \u00e9 mon\u00f3tona e isso \u00e9 relevante porque se um valor do vetor satisfizer a condi\u00e7\u00e3o, todos os valores a direita tamb\u00e9m v\u00e3o satisfaz\u00ea-la, e de forma an\u00e1loga, todos os valores a esquerda de um \u00edndice que n\u00e3o satisfaz a condi\u00e7\u00e3o, tamb\u00e9m n\u00e3o v\u00e3o satisfazer, e \u00e9 isso que nos permite aplicar busca bin\u00e1ria. Al\u00e9m disso, a fun\u00e7\u00e3o check s\u00f3 se torna mon\u00f3tona nesse exemplo quando o vetor est\u00e1 ordenado, por isso a busca bin\u00e1ria s\u00f3 \u00e9 feita em vetores ordenados. Como encontrar o menor valor que torna check verdadeiro? R. inicia-se o processo \"chutanto\" um intervalo onde a resposta com certeza estar\u00e1. Para cada intevalo, checa-se o meio e, dependendo da resposta, descarta-se os elementos a direita ou a esquerda, mas sempre divide-se o tamanho do intervalo por 2, at\u00e9 que o intervalo tenha tamanho 1. Veja uma solu\u00e7\u00e3o: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int l = a ; // sei que a resposta n\u00e3o \u00e9 menos que a int r = b ; // sei que a resposta n\u00e3o \u00e9 mais que b while ( r > l + 1 ){ // repita enquanto o intervalo tiver tamanho > 2 int mid = l + ( r - l ) / 2 ; if ( check ( mid )){ // mid \u00e9 v\u00e1lido r = mid ; // como queremos minimizar a resposta, e mid \u00e9 uma resposta v\u00e1lida //descartamos tudo a direita de mid (mas n\u00e3o mid) } else { l = mid + 1 ; // Se mid n\u00e3o \u00e9 v\u00e1lido, descartamos ele e tudo abaixo. } } // Ao final desse la\u00e7o, a resposta pode estar em l ou r. // Queremos minimizar a resposta, ent\u00e3o se l for v\u00e1lido, // ficaremos com l, e caso contr\u00e1rio, com r int ans = r ; if ( check ( l )) ans = l ; Exemplo: Encontrar o maior valor de \\(x \\in [0, 10]\\) tal que \\(x^2 \\leq 30\\) . 1 2 3 4 5 6 7 8 9 10 11 12 bool check ( int val ) { return val * val <= 30 ; } int lastTrue ( int ini , int fim ) { ini -- ; // Se nenhum valor no intervalor for true, retorna ini - 1 while ( ini < fim ) { int m = ini + ( fim - ini ) / 2 ; if ( check ( m )) ini = m ; // (1) else fim = m - 1 ; // (2) } return ini ; } Se check ( m ) \u00e9 true , ent\u00e3o todos os n\u00fameros menores que m tamb\u00e9m ser\u00e3o true . Se check ( m ) \u00e9 false , ent\u00e3o todos os n\u00fameros maiores que m tamb\u00e9m ser\u00e3o false .","title":"Busca bin\u00e1ria em fun\u00e7\u00f5es monot\u00f4nicas2"},{"location":"ordenacao/#two-pointers","text":"Na t\u00e9cnica chamada Two-Pointers dois \"aponstadores\" caminham pelo vetor. Normalmente, esses apontadores s\u00e3o ``colocados'' nas extremidades opostas do vetor e caminham um em dire\u00e7\u00e3o ao outro, como mostra a figura abaixo. Fonte: AfterAcademy Voc\u00ea consegue pensar em como usar esse t\u00e9cnica para resolver o problema de inverter os elementos de um vetor sem usar um vetor auxiliar? A ideia \u00e9 simples: coloque cada apontador (digamos i e j ) em uma extremidade do vetor, ou seja, i = 0 e j = n - 1 , e, a cada itera\u00e7\u00e3o, troque os elementos que est\u00e3o nas posi\u00e7\u00f5es i e j (ou seja, v[i] <-> v[j] ). Ap\u00f3s a troca, incremente o apontador i e decremente o apontador j . Repita esse processo enquanto i < j . A figura abaixo ilustra parte desse processo. Fonte: AfterAcademy O c\u00f3digo abaixo ilustra essa estrat\u00e9gia (note a simplicidade): 1 2 3 4 5 6 7 8 9 void inverte ( vector < int > & v ) { // (1) int i = 0 ; int j = v . size () - 1 ; while ( i < j ) { swap ( v [ i ], v [ j ]); // (2) i ++ ; j -- ; } } A std::reverse tamb\u00e9m pode ser usada com o mesmo objetivo. O intuito \u00e9 mostrar com a t\u00e9cnica Two-Pointers funciona. std::swap Complemente sua leitura e seu conhecimento: Two Pointers Method (ITMO Academy) \ud83e\udd2f Two Pointers Technique What is the Two pointer technique? O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 e 3 \u21a9 Conte\u00fado extra\u00eddo de Busca Bin\u00e1ria \u21a9","title":"Two-Pointers"},{"location":"pd/","text":"Programa\u00e7\u00e3o Din\u00e2mica Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o din\u00e2mica"},{"location":"pd/#programacao-dinamica","text":"Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o Din\u00e2mica"},{"location":"strings/","text":"Processamento de Strings Em constru\u00e7\u00e3o...","title":"Processamento de strings"},{"location":"strings/#processamento-de-strings","text":"Em constru\u00e7\u00e3o...","title":"Processamento de Strings"},{"location":"teorianumeros/","text":"Teoria dos N\u00fameros 1 Teoria dos N\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda os n\u00fameros inteiros. Dominar o maior n\u00famero poss\u00edvel de t\u00f3picos da teoria dos n\u00fameros \u00e9 importante, pois alguns problemas matem\u00e1ticos se tornam f\u00e1ceis (ou mais f\u00e1ceis) se voc\u00ea conhecer a teoria por tr\u00e1s do problema. Divisibilidade Um inteiro \\(n\\) \u00e9 divis\u00edvel por um inteiro \\(d\\) (denotado por \\(d | n\\) .) se houver outro inteiro \\(q\\) tal que \\(n = d \\times q\\) . Tamb\u00e9m \u00e9 dito que \\(d\\) \u00e9 um divisor de \\(n\\) . Dividindo os dois lados da igualdade \\(n = dq\\) por \\(d\\) tem-se uma defini\u00e7\u00e3o quase equivalente, ou seja, que \\(\\frac{n}{d}\\) \u00e9 um inteiro. Exemplo O n\u00famero 12 possui 6 divisores: \\(1~(1 \\times 12 = 12), 2~(2 \\times 6 = 12), 3~(3 \\times 4 = 12), 4~(4 \\times 3 = 12), 6~(6 \\times 6 = 12)\\) e \\(12~(12 \\times 1 = 12)\\) . O conceito de divisibilidade traz muitas quest\u00f5es. A primeira \u00e9 como verificar se um n\u00famero \u00e9 divis\u00edvel por outro. Para n\u00famero pequenos, que podem ser armazenados em vari\u00e1veis, por exemplo, do tipo long long , pode-se usar o operador m\u00f3dulo ou resto da divis\u00e3o ( % ): \\(n\\) \u00e9 divis\u00edvel por \\(d\\) se e somente se \u01f9 % d == 0 . Entretanto, para n\u00fameros inteiros grandes a solu\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples. Na Se\u00e7\u00e3o Aritm\u00e9tica Modular ser\u00e1 discutido como implementar o operador m\u00f3dulo para n\u00famero inteiros grandes. Outra quest\u00e3o \u00e9 como calcular os divisores de um n\u00famero. Todo inteiro \\(n\\) tem pelo menos dois divisores ( \\(1\\) e \\(n\\) ). Para encontrar os outros divisores, pode-se usar o fato que qualquer divisor \\(d\\) de \\(n\\) deve satisfazer \\(|d| \\leq |n|\\) . Assim, pode-se testar se os inteiros entre \\(1\\) e \\(n\\) s\u00e3o divisores de \\(n\\) , ou seja, um algoritmo \\(O(n)\\) . Entretanto, sempre que tem-se um divisor \\(d\\) , tem-se outro divisor \\(q\\) (veja o exemplo anterior). Por exemplo, ao afirmar que \\(3\\) \u00e9 um divisor de \\(12\\) , pois \\(3 \\times 4 = 12\\) , tem-se outro divisor, \\(4\\) . Ou seja, os divisores v\u00eam em pares. Veja outros exemplo: Exemplo O n\u00famero 16 possui 5 divisores: \\(1~(1 \\times 16 = 16), 2~(2 \\times 8 = 16), 4~(4 \\times 4 = 16), 8~(8 \\times 2 = 16)\\) e \\(16~(16 \\times 6 = 16)\\) . Dessa forma, pode-se limitar a encontrar cada elemento desses pares. Al\u00e9m disso, um dos valores de cada par deve ser limitado por \\(\\sqrt n\\) . Por qu\u00ea? Esse limite ajuda a reduzir a complexidade do algoritmo que encontra todos os divisores de um n\u00famero em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo retorna um vector com todos os divisores de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > divisores ( long long n ) { vector < long long > ans ; for ( long long a = 1 ; a * a <= n ; a ++ ) { // (1) if ( n % a == 0 ) { long long b = n / a ; ans . push_back ( a ); if ( a != b ) ans . push_back ( b ); } } return ans ; // (2) } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Em alguns casos, \u00e9 interessante ou necess\u00e1rio retornar os divisores ordenados Complemente sua leitura e seu conhecimento: Number of divisors / sum of divisors Divisibility Counting Divisors of a Number in \\(O(n^{\\frac{1}{3}})\\) How many divisors does a number have? N\u00fameros Primos Um n\u00famero inteiro \\(n > 1\\) \u00e9 chamado de n\u00famero primo se e somente se possui dois divisores: \\(1\\) e \\(n\\) . Um n\u00famero que n\u00e3o \u00e9 primo \u00e9 chamado de n\u00famero composto (veja a figura abaixo). O primeiro e \u00fanico n\u00famero primo par \u00e9 \\(2\\) . Os pr\u00f3ximos n\u00fameros primos s\u00e3o: \\(3, 5, 7, 11, 13, \\dots\\) . Como voc\u00ea deve imaginar, existe um n\u00famero infinito de primos (Veja a prova aqui ). N\u00fameros primos s\u00e3o os n\u00fameros naturais maiores que um que n\u00e3o s\u00e3o produtos de dois n\u00fameros naturais menores.(Fonte: Wikip\u00e9dia ) N\u00famero primo \u00e9 um t\u00f3pico importante da teoria dos n\u00fameros e a fonte de muitos problemas em programa\u00e7\u00f5es competitivas. Por isso \u00e9 de extrema import\u00e2ncia conhecer e dominar alguns algoritmos que envolvam n\u00fameros primos. Testes de Primalidade Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ent\u00e3o ele pode ser representado pelo produto de dois inteiros \\(a \\times b\\) , onde \\(a \\leq \\sqrt n\\) ou \\(b \\leq \\sqrt n\\) . Com isso, pode-se testar se um n\u00famero \u00e9 primo ou n\u00e3o e encontrar uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo verifica se um dado n\u00famero \\(n\\) \u00e9 primo ou n\u00e3o. 1 2 3 4 5 6 7 8 9 bool ehPrimo ( long long n ) { if ( n < 2 ) return false ; for ( long long x = 2 ; x * x <= n ; x ++ ) { // (1) if ( n % x == 0 ) return false ; } return true ; } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Ou, alternativamente: 1 2 3 4 5 6 7 8 9 10 bool isPrimeFast ( long long n ) { // (1) if ( n < 5 || n % 2 == 0 || n % 3 == 0 ) return ( n == 2 || n == 3 ); long long maxP = sqrt ( n ) + 2 ; for ( long long p = 5 ; p < maxP ; p += 6 ) { if ( p < n && n % p == 0 ) return false ; if ( p + 2 < n && n % ( p + 2 ) == 0 ) return false ; } return true ; } Fonte: primes.cpp Complemente sua leitura e seu conhecimento: Primality tests Decomposi\u00e7\u00e3o em fatores primos Todo n\u00famero positivo \\(n\\) possui uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos \u00fanica: uma forma de decompor \\(n\\) em um produto de n\u00fameros primos, ou seja: \\[ n = p_1^{a_1} \\times p_2^{a_2} \\times \\dots \\times p_k^{a_k}, \\] onde \\(p_i\\) s\u00e3o n\u00fameros primos distintos e \\(a_i\\) inteiros positivos. A fun\u00e7\u00e3o abaixo retorna um vector com a decomposi\u00e7\u00e3o em fatores primos de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > factor ( long long n ) { vector < long long > ans ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ans . push_back ( i ); n /= i ; } } if ( n > 1 ) ans . push_back ( n ); return ans ; } Note que cada fator primo aparece no vetor o n\u00famero de vezes que ele divide \\(n\\) . Por exemplo, \\(24 = 2^3 \\times 3\\) , ent\u00e3o o resultado da fun\u00e7\u00e3o \u00e9 \\([2,2,2,3]\\) . Complemente sua leitura e seu conhecimento: Integer factorization Primalidade e fatora\u00e7\u00e3o Crivo de Erat\u00f3stenes O Crivo de Erat\u00f3stenes \u00e9 um algoritmo para encontrar todos os n\u00fameros primos at\u00e9 um certo limite usando \\(O(n \\log \\log n)\\) opera\u00e7\u00f5es. A ideia do algoritmo \u00e9 a seguinte: inicialmente, escreve-se todos os n\u00fameros entre \\(2\\) e \\(n\\) . Ent\u00e3o, marca-se todos os m\u00faltiplos de \\(2\\) (j\u00e1 que \\(2\\) \u00e9 o menor n\u00famero primo). Em seguida, pega-se o pr\u00f3ximo valor que n\u00e3o foi marcado como composto, neste caso, \u00e9 o \\(3\\) . Isso significa que 3 \u00e9 primo. Ent\u00e3o, marca-se todos os m\u00faltiplos de 3 como compostos. O pr\u00f3ximo n\u00famero n\u00e3o marcado \u00e9 o \\(5\\) (pr\u00f3ximo n\u00famero primo). Marca-se todos os m\u00faltiplos de \\(5\\) . Este processo \u00e9 repetido at\u00e9 \\(n\\) . A anima\u00e7\u00e3o abaixo exemplifica a execu\u00e7\u00e3o do algoritmo para \\(n = 120\\) . Crivo de Erat\u00f3stenes: passos do algoritmo para primos abaixo de 121. (Fonte: Wikip\u00e9dia ) O c\u00f3digo abaixo exemplifica uma poss\u00edvel implementa\u00e7\u00e3o do algoritmo. Esse algoritmo possui complexidade \\(O(n \\log \\log n)\\) (veja a prova aqui ). 1 2 3 4 5 6 7 8 9 10 11 vector < bool > crivo ( long long n ) { vector < bool > primo ( n + 1 , true ); // (1) primo [ 0 ] = primo [ 1 ] = false ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( primo [ i ] && i * i <= n ) { for ( long long j = i * i ; j <= n ; j += i ) // (2) primo [ j ] = false ; } } return primo ; } Cria um array ( vector ) booleano de tamanho \\(n + 1\\) , onde todas as posi\u00e7\u00f5es s\u00e3o inicializadas com true . Iteramos por todos os n\u00fameros divis\u00edveis pelo primo i Complemente sua leitura e seu conhecimento: Sieve of Eratosthenes Linear Sieve Math note - linear sieve Primo de Mersenne N\u00famero de Mersenne \u00e9 todo n\u00famero natural da forma \\(M_{n}=2^{n}-1\\) , onde \\(n\\) \u00e9 um n\u00famero natural. Os primeiros n\u00fameros Mersenne s\u00e3o: \\(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\dots\\) . Um subconjunto particularmente interessante \u00e9 o constitu\u00eddo pelos n\u00fameros de Mersenne que s\u00e3o tamb\u00e9m primos: os primos de Mersenne . Note que nem todo n\u00famero de Mersenne \u00e9 primo, assim como nem todo n\u00famero primo \u00e9 de Mersenne. Os primeiros primos de Mersenne s\u00e3o: \\(M_2 = 3, M_3 = 7, M_5 = 31, M_7 = 127, M_13 = 8191, M_17 = 131071, M_19 = 524287, \\dots\\) Um resultado elementar sobre os n\u00fameros de Mersenne afirma que se \\(2^{n}-1\\) \u00e9 um n\u00famero primo, ent\u00e3o \\(n\\) tamb\u00e9m \u00e9 um n\u00famero primo. Algoritmo de Euclides (MDC/MMC) O m\u00e1ximo divisor comum (GCD, do ingl\u00eas greatest common divisor ) dos n\u00fameros \\(a\\) e \\(b\\) , gcd(a,b) , \u00e9 o maior n\u00famero que divide \\(a\\) e \\(b\\) , e o m\u00ednimo m\u00faltiplo comum (LCM, do ingl\u00eas least common multiple ) de \\(a\\) e \\(b\\) , lcm(a,b) , \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e \\(b\\) . O algoritmo de Euclides fornece uma maneira eficiente de encontrar o m\u00e1ximo divisor comum de dois n\u00fameros. O algoritmo \u00e9 baseado na seguinte defini\u00e7\u00e3o: \\[ \\gcd(a, b) = \\begin{cases}a,&\\text{se }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{caso contr\u00e1rio.}\\end{cases} \\] Usando essa defini\u00e7\u00e3o, o algoritmo \u00e9 facilmente implementado usando recurs\u00e3o: 1 2 3 4 5 6 long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Dica Voc\u00ea pode usar a fun\u00e7\u00e3o integrada __gcd(a, b) do C++. Pode-se mostrar que o algoritmo de Euclides possui complexidade \\(O(\\log n)\\) , onde \\(n = min(a,b)\\) . O m\u00ednimo m\u00faltiplo comum (LCM) pode ser calculado da seguinte forma: \\[ lcm(a, b) = \\frac{a \\times b}{gcd(a,b)} \\] Para calcular o GCD ou LCM de mais de dois valores, pode-se calcular o valor de dois em dois (em qualquer ordem). Por exemplo: \\[ gcd(a, b, c, d) = gcd(a, gcd(b, gcd(c, d))) \\] Fun\u00e7\u00e3o totiente de Euler A fun\u00e7\u00e3o totiente de Euler, tamb\u00e9m conhecida como fun\u00e7\u00e3o \\(\\phi (n)\\) , conta o n\u00famero de inteiros entre \\(1\\) e \\(n\\) , no qual s\u00e3o coprimos de \\(n\\) . Dois n\u00fameros s\u00e3o coprimos se o m\u00e1ximo divisor comum entre eles for 1 (1 \u00e9 considerado ser coprimo para qualquer n\u00famero). Por exemplo, \\(\\phi (12) = 4\\) , pois 1, 5, 7 e 11 s\u00e3o coprimos de 12. Abaixo est\u00e3o valores de \\(\\phi (n)\\) para os primeiros n\u00fameros inteiros positivos: \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\ \\hline \\end{array}\\] A fun\u00e7\u00e3o abaixo calcula o valor de \\(\\phi (n)\\) em \\(O(\\sqrt n)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 long long phi ( long long n ) { long long result = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Complemente sua leitura e seu conhecimento: Euclidean algorithm for computing the greatest common divisor Euler's totient function Aritm\u00e9tica Modular Na aritm\u00e9tica modular , o conjunto de n\u00fameros \u00e9 limitado de forma que apenas os n\u00fameros \\(0,1,2,\\dots,m\u22121\\) s\u00e3o usados, onde \\(m\\) \u00e9 uma constante. Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(x \\bmod m\\) : o resto da divis\u00e3o de \\(x\\) por \\(m\\) . Por exemplo, se \\(m = 23\\) , em vez \\(x = 247\\) , considera-se \\(x \\bmod 23 = 17\\) . Normalmente, \\(m\\) ser\u00e1 um primo grande, dado no problema, normalmente, \\(10^9 + 7\\) . A aritm\u00e9tica modular \u00e9 usada para evitar integer overflow . As seguintes propriedades valem no c\u00e1lculo do m\u00f3dulo: \\[(a+b) \\bmod m = (a \\bmod m + b \\bmod m) \\bmod m\\] \\[(a-b) \\bmod m = (a \\bmod m - b \\bmod m) \\bmod m\\] \\[(a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\] \\[a^b \\bmod {m} = (a \\bmod m)^b \\bmod m\\] O que significa que se a resposta est\u00e1 sendo computada por meio de adi\u00e7\u00f5es, subtra\u00e7\u00f5es e multiplica\u00e7\u00f5es, e no final voc\u00ea precisa tirar o m\u00f3dulo dela, voc\u00ea pode tirar o m\u00f3dulo em todas as opera\u00e7\u00f5es intermedi\u00e1rias que isso n\u00e3o afetar\u00e1 a resposta. Exponencia\u00e7\u00e3o Bin\u00e1ria A exponencia\u00e7\u00e3o bin\u00e1ria \u00e9 um truque que permite calcular \\(x^n\\) usando apenas multiplica\u00e7\u00f5es \\(O(\\log\u2061 n)\\) (em vez das multiplica\u00e7\u00f5es \\(O(n)\\) exigidas pela abordagem ing\u00eanua). Sabe-se que \\(x^a \\cdot x^b = x^{a+b}\\) . Em particular, \\(x^{2b} = x^b \\cdot x^b\\) . Logo, se o expoente \\(n\\) de \\(x^n\\) for par, pode-se dizer que \\(x^n = x^{\\frac{n}{2}} \\cdot x^{\\frac{n}{2}}\\) . No entanto, se \\(n\\) for \u00edmpar, tem-se algo similar: \\(x^n = x^{\\frac{n-1}{2}} \\cdot x^{\\frac{n-1}{2}} \\cdot x\\) . Dessa forma, pode-se montar a seguinte recorr\u00eancia: \\[ x^n = \\begin{cases} 1 &\\text{se } n = 0 \\\\ \\left(x^{\\frac{n}{2}}\\right)^2 &\\text{se } n \\text{ par}\\\\ \\left(x^{\\frac{n - 1}{2}}\\right)^2 \\cdot x &\\text{se } n \\text{ impar}\\\\ \\end{cases} \\] Note que se \\(n\\) for par, o valor \\(x^{n/2}\\) deve ser calculado apenas uma vez. Isso garante que a complexidade do algoritmo seja \\(O(\\log n)\\) . A fun\u00e7\u00e3o abaixo calcula do valor de \\(x^n\\) : 1 2 3 4 5 6 7 8 9 long long binpow ( long long x , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( x , n / 2 ); if ( n % 2 ) return res * res * x ; else return res * res ; } Alternativamente, sem usar recurs\u00e3o e usando manipula\u00e7\u00e3o de bits : 1 2 3 4 5 6 7 8 9 10 long long binpow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x ; x = x * x ; n >>= 1 ; } return res ; } Em alguns casos, \u00e9 necess\u00e1rio calcular o valor de \\(x^n \\bmod m\\) . Sabendo que \\((a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\) , pode-se usar diretamente c\u00f3digo anterior e apenas substituir cada multiplica\u00e7\u00e3o por uma multiplica\u00e7\u00e3o modular: 1 2 3 4 5 6 7 8 9 10 11 long long binpow ( long long x , long long n , long long m = 1 ) { // (1) x %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % m ; x = x * x % m ; n >>= 1 ; } return res ; } Deixando o valor padr\u00e3o de m como 1, pode-se usar essa fun\u00e7\u00e3o sem passar o valor de m como par\u00e2metro. Dica Se \\(m\\) \u00e9 um n\u00famero primo, pode-se acelerar um pouco este algoritmo calculando \\(x^{n \\bmod(m\u22121)}\\) em vez de \\(x^n\\) . Complemente sua leitura e seu conhecimento: Binary Exponentiation O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 e 5 \u21a9","title":"Teoria dos N\u00fameros"},{"location":"teorianumeros/#teoria-dos-numeros1","text":"Teoria dos N\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda os n\u00fameros inteiros. Dominar o maior n\u00famero poss\u00edvel de t\u00f3picos da teoria dos n\u00fameros \u00e9 importante, pois alguns problemas matem\u00e1ticos se tornam f\u00e1ceis (ou mais f\u00e1ceis) se voc\u00ea conhecer a teoria por tr\u00e1s do problema.","title":"Teoria dos N\u00fameros1"},{"location":"teorianumeros/#divisibilidade","text":"Um inteiro \\(n\\) \u00e9 divis\u00edvel por um inteiro \\(d\\) (denotado por \\(d | n\\) .) se houver outro inteiro \\(q\\) tal que \\(n = d \\times q\\) . Tamb\u00e9m \u00e9 dito que \\(d\\) \u00e9 um divisor de \\(n\\) . Dividindo os dois lados da igualdade \\(n = dq\\) por \\(d\\) tem-se uma defini\u00e7\u00e3o quase equivalente, ou seja, que \\(\\frac{n}{d}\\) \u00e9 um inteiro. Exemplo O n\u00famero 12 possui 6 divisores: \\(1~(1 \\times 12 = 12), 2~(2 \\times 6 = 12), 3~(3 \\times 4 = 12), 4~(4 \\times 3 = 12), 6~(6 \\times 6 = 12)\\) e \\(12~(12 \\times 1 = 12)\\) . O conceito de divisibilidade traz muitas quest\u00f5es. A primeira \u00e9 como verificar se um n\u00famero \u00e9 divis\u00edvel por outro. Para n\u00famero pequenos, que podem ser armazenados em vari\u00e1veis, por exemplo, do tipo long long , pode-se usar o operador m\u00f3dulo ou resto da divis\u00e3o ( % ): \\(n\\) \u00e9 divis\u00edvel por \\(d\\) se e somente se \u01f9 % d == 0 . Entretanto, para n\u00fameros inteiros grandes a solu\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples. Na Se\u00e7\u00e3o Aritm\u00e9tica Modular ser\u00e1 discutido como implementar o operador m\u00f3dulo para n\u00famero inteiros grandes. Outra quest\u00e3o \u00e9 como calcular os divisores de um n\u00famero. Todo inteiro \\(n\\) tem pelo menos dois divisores ( \\(1\\) e \\(n\\) ). Para encontrar os outros divisores, pode-se usar o fato que qualquer divisor \\(d\\) de \\(n\\) deve satisfazer \\(|d| \\leq |n|\\) . Assim, pode-se testar se os inteiros entre \\(1\\) e \\(n\\) s\u00e3o divisores de \\(n\\) , ou seja, um algoritmo \\(O(n)\\) . Entretanto, sempre que tem-se um divisor \\(d\\) , tem-se outro divisor \\(q\\) (veja o exemplo anterior). Por exemplo, ao afirmar que \\(3\\) \u00e9 um divisor de \\(12\\) , pois \\(3 \\times 4 = 12\\) , tem-se outro divisor, \\(4\\) . Ou seja, os divisores v\u00eam em pares. Veja outros exemplo: Exemplo O n\u00famero 16 possui 5 divisores: \\(1~(1 \\times 16 = 16), 2~(2 \\times 8 = 16), 4~(4 \\times 4 = 16), 8~(8 \\times 2 = 16)\\) e \\(16~(16 \\times 6 = 16)\\) . Dessa forma, pode-se limitar a encontrar cada elemento desses pares. Al\u00e9m disso, um dos valores de cada par deve ser limitado por \\(\\sqrt n\\) . Por qu\u00ea? Esse limite ajuda a reduzir a complexidade do algoritmo que encontra todos os divisores de um n\u00famero em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo retorna um vector com todos os divisores de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > divisores ( long long n ) { vector < long long > ans ; for ( long long a = 1 ; a * a <= n ; a ++ ) { // (1) if ( n % a == 0 ) { long long b = n / a ; ans . push_back ( a ); if ( a != b ) ans . push_back ( b ); } } return ans ; // (2) } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Em alguns casos, \u00e9 interessante ou necess\u00e1rio retornar os divisores ordenados Complemente sua leitura e seu conhecimento: Number of divisors / sum of divisors Divisibility Counting Divisors of a Number in \\(O(n^{\\frac{1}{3}})\\) How many divisors does a number have?","title":"Divisibilidade"},{"location":"teorianumeros/#numeros-primos","text":"Um n\u00famero inteiro \\(n > 1\\) \u00e9 chamado de n\u00famero primo se e somente se possui dois divisores: \\(1\\) e \\(n\\) . Um n\u00famero que n\u00e3o \u00e9 primo \u00e9 chamado de n\u00famero composto (veja a figura abaixo). O primeiro e \u00fanico n\u00famero primo par \u00e9 \\(2\\) . Os pr\u00f3ximos n\u00fameros primos s\u00e3o: \\(3, 5, 7, 11, 13, \\dots\\) . Como voc\u00ea deve imaginar, existe um n\u00famero infinito de primos (Veja a prova aqui ). N\u00fameros primos s\u00e3o os n\u00fameros naturais maiores que um que n\u00e3o s\u00e3o produtos de dois n\u00fameros naturais menores.(Fonte: Wikip\u00e9dia ) N\u00famero primo \u00e9 um t\u00f3pico importante da teoria dos n\u00fameros e a fonte de muitos problemas em programa\u00e7\u00f5es competitivas. Por isso \u00e9 de extrema import\u00e2ncia conhecer e dominar alguns algoritmos que envolvam n\u00fameros primos.","title":"N\u00fameros Primos"},{"location":"teorianumeros/#testes-de-primalidade","text":"Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ent\u00e3o ele pode ser representado pelo produto de dois inteiros \\(a \\times b\\) , onde \\(a \\leq \\sqrt n\\) ou \\(b \\leq \\sqrt n\\) . Com isso, pode-se testar se um n\u00famero \u00e9 primo ou n\u00e3o e encontrar uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo verifica se um dado n\u00famero \\(n\\) \u00e9 primo ou n\u00e3o. 1 2 3 4 5 6 7 8 9 bool ehPrimo ( long long n ) { if ( n < 2 ) return false ; for ( long long x = 2 ; x * x <= n ; x ++ ) { // (1) if ( n % x == 0 ) return false ; } return true ; } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Ou, alternativamente: 1 2 3 4 5 6 7 8 9 10 bool isPrimeFast ( long long n ) { // (1) if ( n < 5 || n % 2 == 0 || n % 3 == 0 ) return ( n == 2 || n == 3 ); long long maxP = sqrt ( n ) + 2 ; for ( long long p = 5 ; p < maxP ; p += 6 ) { if ( p < n && n % p == 0 ) return false ; if ( p + 2 < n && n % ( p + 2 ) == 0 ) return false ; } return true ; } Fonte: primes.cpp Complemente sua leitura e seu conhecimento: Primality tests","title":"Testes de Primalidade"},{"location":"teorianumeros/#decomposicao-em-fatores-primos","text":"Todo n\u00famero positivo \\(n\\) possui uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos \u00fanica: uma forma de decompor \\(n\\) em um produto de n\u00fameros primos, ou seja: \\[ n = p_1^{a_1} \\times p_2^{a_2} \\times \\dots \\times p_k^{a_k}, \\] onde \\(p_i\\) s\u00e3o n\u00fameros primos distintos e \\(a_i\\) inteiros positivos. A fun\u00e7\u00e3o abaixo retorna um vector com a decomposi\u00e7\u00e3o em fatores primos de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > factor ( long long n ) { vector < long long > ans ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ans . push_back ( i ); n /= i ; } } if ( n > 1 ) ans . push_back ( n ); return ans ; } Note que cada fator primo aparece no vetor o n\u00famero de vezes que ele divide \\(n\\) . Por exemplo, \\(24 = 2^3 \\times 3\\) , ent\u00e3o o resultado da fun\u00e7\u00e3o \u00e9 \\([2,2,2,3]\\) . Complemente sua leitura e seu conhecimento: Integer factorization Primalidade e fatora\u00e7\u00e3o","title":"Decomposi\u00e7\u00e3o em fatores primos"},{"location":"teorianumeros/#crivo-de-eratostenes","text":"O Crivo de Erat\u00f3stenes \u00e9 um algoritmo para encontrar todos os n\u00fameros primos at\u00e9 um certo limite usando \\(O(n \\log \\log n)\\) opera\u00e7\u00f5es. A ideia do algoritmo \u00e9 a seguinte: inicialmente, escreve-se todos os n\u00fameros entre \\(2\\) e \\(n\\) . Ent\u00e3o, marca-se todos os m\u00faltiplos de \\(2\\) (j\u00e1 que \\(2\\) \u00e9 o menor n\u00famero primo). Em seguida, pega-se o pr\u00f3ximo valor que n\u00e3o foi marcado como composto, neste caso, \u00e9 o \\(3\\) . Isso significa que 3 \u00e9 primo. Ent\u00e3o, marca-se todos os m\u00faltiplos de 3 como compostos. O pr\u00f3ximo n\u00famero n\u00e3o marcado \u00e9 o \\(5\\) (pr\u00f3ximo n\u00famero primo). Marca-se todos os m\u00faltiplos de \\(5\\) . Este processo \u00e9 repetido at\u00e9 \\(n\\) . A anima\u00e7\u00e3o abaixo exemplifica a execu\u00e7\u00e3o do algoritmo para \\(n = 120\\) . Crivo de Erat\u00f3stenes: passos do algoritmo para primos abaixo de 121. (Fonte: Wikip\u00e9dia ) O c\u00f3digo abaixo exemplifica uma poss\u00edvel implementa\u00e7\u00e3o do algoritmo. Esse algoritmo possui complexidade \\(O(n \\log \\log n)\\) (veja a prova aqui ). 1 2 3 4 5 6 7 8 9 10 11 vector < bool > crivo ( long long n ) { vector < bool > primo ( n + 1 , true ); // (1) primo [ 0 ] = primo [ 1 ] = false ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( primo [ i ] && i * i <= n ) { for ( long long j = i * i ; j <= n ; j += i ) // (2) primo [ j ] = false ; } } return primo ; } Cria um array ( vector ) booleano de tamanho \\(n + 1\\) , onde todas as posi\u00e7\u00f5es s\u00e3o inicializadas com true . Iteramos por todos os n\u00fameros divis\u00edveis pelo primo i Complemente sua leitura e seu conhecimento: Sieve of Eratosthenes Linear Sieve Math note - linear sieve","title":"Crivo de Erat\u00f3stenes"},{"location":"teorianumeros/#primo-de-mersenne","text":"N\u00famero de Mersenne \u00e9 todo n\u00famero natural da forma \\(M_{n}=2^{n}-1\\) , onde \\(n\\) \u00e9 um n\u00famero natural. Os primeiros n\u00fameros Mersenne s\u00e3o: \\(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\dots\\) . Um subconjunto particularmente interessante \u00e9 o constitu\u00eddo pelos n\u00fameros de Mersenne que s\u00e3o tamb\u00e9m primos: os primos de Mersenne . Note que nem todo n\u00famero de Mersenne \u00e9 primo, assim como nem todo n\u00famero primo \u00e9 de Mersenne. Os primeiros primos de Mersenne s\u00e3o: \\(M_2 = 3, M_3 = 7, M_5 = 31, M_7 = 127, M_13 = 8191, M_17 = 131071, M_19 = 524287, \\dots\\) Um resultado elementar sobre os n\u00fameros de Mersenne afirma que se \\(2^{n}-1\\) \u00e9 um n\u00famero primo, ent\u00e3o \\(n\\) tamb\u00e9m \u00e9 um n\u00famero primo.","title":"Primo de Mersenne"},{"location":"teorianumeros/#algoritmo-de-euclides-mdcmmc","text":"O m\u00e1ximo divisor comum (GCD, do ingl\u00eas greatest common divisor ) dos n\u00fameros \\(a\\) e \\(b\\) , gcd(a,b) , \u00e9 o maior n\u00famero que divide \\(a\\) e \\(b\\) , e o m\u00ednimo m\u00faltiplo comum (LCM, do ingl\u00eas least common multiple ) de \\(a\\) e \\(b\\) , lcm(a,b) , \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e \\(b\\) . O algoritmo de Euclides fornece uma maneira eficiente de encontrar o m\u00e1ximo divisor comum de dois n\u00fameros. O algoritmo \u00e9 baseado na seguinte defini\u00e7\u00e3o: \\[ \\gcd(a, b) = \\begin{cases}a,&\\text{se }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{caso contr\u00e1rio.}\\end{cases} \\] Usando essa defini\u00e7\u00e3o, o algoritmo \u00e9 facilmente implementado usando recurs\u00e3o: 1 2 3 4 5 6 long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Dica Voc\u00ea pode usar a fun\u00e7\u00e3o integrada __gcd(a, b) do C++. Pode-se mostrar que o algoritmo de Euclides possui complexidade \\(O(\\log n)\\) , onde \\(n = min(a,b)\\) . O m\u00ednimo m\u00faltiplo comum (LCM) pode ser calculado da seguinte forma: \\[ lcm(a, b) = \\frac{a \\times b}{gcd(a,b)} \\] Para calcular o GCD ou LCM de mais de dois valores, pode-se calcular o valor de dois em dois (em qualquer ordem). Por exemplo: \\[ gcd(a, b, c, d) = gcd(a, gcd(b, gcd(c, d))) \\]","title":"Algoritmo de Euclides (MDC/MMC)"},{"location":"teorianumeros/#funcao-totiente-de-euler","text":"A fun\u00e7\u00e3o totiente de Euler, tamb\u00e9m conhecida como fun\u00e7\u00e3o \\(\\phi (n)\\) , conta o n\u00famero de inteiros entre \\(1\\) e \\(n\\) , no qual s\u00e3o coprimos de \\(n\\) . Dois n\u00fameros s\u00e3o coprimos se o m\u00e1ximo divisor comum entre eles for 1 (1 \u00e9 considerado ser coprimo para qualquer n\u00famero). Por exemplo, \\(\\phi (12) = 4\\) , pois 1, 5, 7 e 11 s\u00e3o coprimos de 12. Abaixo est\u00e3o valores de \\(\\phi (n)\\) para os primeiros n\u00fameros inteiros positivos: \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\ \\hline \\end{array}\\] A fun\u00e7\u00e3o abaixo calcula o valor de \\(\\phi (n)\\) em \\(O(\\sqrt n)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 long long phi ( long long n ) { long long result = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Complemente sua leitura e seu conhecimento: Euclidean algorithm for computing the greatest common divisor Euler's totient function","title":"Fun\u00e7\u00e3o totiente de Euler"},{"location":"teorianumeros/#aritmetica-modular","text":"Na aritm\u00e9tica modular , o conjunto de n\u00fameros \u00e9 limitado de forma que apenas os n\u00fameros \\(0,1,2,\\dots,m\u22121\\) s\u00e3o usados, onde \\(m\\) \u00e9 uma constante. Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(x \\bmod m\\) : o resto da divis\u00e3o de \\(x\\) por \\(m\\) . Por exemplo, se \\(m = 23\\) , em vez \\(x = 247\\) , considera-se \\(x \\bmod 23 = 17\\) . Normalmente, \\(m\\) ser\u00e1 um primo grande, dado no problema, normalmente, \\(10^9 + 7\\) . A aritm\u00e9tica modular \u00e9 usada para evitar integer overflow . As seguintes propriedades valem no c\u00e1lculo do m\u00f3dulo: \\[(a+b) \\bmod m = (a \\bmod m + b \\bmod m) \\bmod m\\] \\[(a-b) \\bmod m = (a \\bmod m - b \\bmod m) \\bmod m\\] \\[(a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\] \\[a^b \\bmod {m} = (a \\bmod m)^b \\bmod m\\] O que significa que se a resposta est\u00e1 sendo computada por meio de adi\u00e7\u00f5es, subtra\u00e7\u00f5es e multiplica\u00e7\u00f5es, e no final voc\u00ea precisa tirar o m\u00f3dulo dela, voc\u00ea pode tirar o m\u00f3dulo em todas as opera\u00e7\u00f5es intermedi\u00e1rias que isso n\u00e3o afetar\u00e1 a resposta.","title":"Aritm\u00e9tica Modular"},{"location":"teorianumeros/#exponenciacao-binaria","text":"A exponencia\u00e7\u00e3o bin\u00e1ria \u00e9 um truque que permite calcular \\(x^n\\) usando apenas multiplica\u00e7\u00f5es \\(O(\\log\u2061 n)\\) (em vez das multiplica\u00e7\u00f5es \\(O(n)\\) exigidas pela abordagem ing\u00eanua). Sabe-se que \\(x^a \\cdot x^b = x^{a+b}\\) . Em particular, \\(x^{2b} = x^b \\cdot x^b\\) . Logo, se o expoente \\(n\\) de \\(x^n\\) for par, pode-se dizer que \\(x^n = x^{\\frac{n}{2}} \\cdot x^{\\frac{n}{2}}\\) . No entanto, se \\(n\\) for \u00edmpar, tem-se algo similar: \\(x^n = x^{\\frac{n-1}{2}} \\cdot x^{\\frac{n-1}{2}} \\cdot x\\) . Dessa forma, pode-se montar a seguinte recorr\u00eancia: \\[ x^n = \\begin{cases} 1 &\\text{se } n = 0 \\\\ \\left(x^{\\frac{n}{2}}\\right)^2 &\\text{se } n \\text{ par}\\\\ \\left(x^{\\frac{n - 1}{2}}\\right)^2 \\cdot x &\\text{se } n \\text{ impar}\\\\ \\end{cases} \\] Note que se \\(n\\) for par, o valor \\(x^{n/2}\\) deve ser calculado apenas uma vez. Isso garante que a complexidade do algoritmo seja \\(O(\\log n)\\) . A fun\u00e7\u00e3o abaixo calcula do valor de \\(x^n\\) : 1 2 3 4 5 6 7 8 9 long long binpow ( long long x , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( x , n / 2 ); if ( n % 2 ) return res * res * x ; else return res * res ; } Alternativamente, sem usar recurs\u00e3o e usando manipula\u00e7\u00e3o de bits : 1 2 3 4 5 6 7 8 9 10 long long binpow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x ; x = x * x ; n >>= 1 ; } return res ; } Em alguns casos, \u00e9 necess\u00e1rio calcular o valor de \\(x^n \\bmod m\\) . Sabendo que \\((a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\) , pode-se usar diretamente c\u00f3digo anterior e apenas substituir cada multiplica\u00e7\u00e3o por uma multiplica\u00e7\u00e3o modular: 1 2 3 4 5 6 7 8 9 10 11 long long binpow ( long long x , long long n , long long m = 1 ) { // (1) x %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % m ; x = x * x % m ; n >>= 1 ; } return res ; } Deixando o valor padr\u00e3o de m como 1, pode-se usar essa fun\u00e7\u00e3o sem passar o valor de m como par\u00e2metro. Dica Se \\(m\\) \u00e9 um n\u00famero primo, pode-se acelerar um pouco este algoritmo calculando \\(x^{n \\bmod(m\u22121)}\\) em vez de \\(x^n\\) . Complemente sua leitura e seu conhecimento: Binary Exponentiation O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 e 5 \u21a9","title":"Exponencia\u00e7\u00e3o Bin\u00e1ria"}]}