{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programa\u00e7\u00e3o Competitiva Ementa Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional. Objetivos Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas. Programas e Sites Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona Bibliografia Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++ Notebooks Stanford University Royal Institute of Technology","title":"Disciplina"},{"location":"#programacao-competitiva","text":"","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"#ementa","text":"Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional.","title":"Ementa"},{"location":"#objetivos","text":"Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas.","title":"Objetivos"},{"location":"#programas-e-sites","text":"Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona","title":"Programas e Sites"},{"location":"#bibliografia","text":"Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++","title":"Bibliografia"},{"location":"#notebooks","text":"Stanford University Royal Institute of Technology","title":"Notebooks"},{"location":"buscaexaustiva/","text":"Busca Exaustiva (Recurs\u00e3o + Backtracking) Em constru\u00e7\u00e3o...","title":"Busca Exaustiva"},{"location":"buscaexaustiva/#busca-exaustiva-recursao-backtracking","text":"Em constru\u00e7\u00e3o...","title":"Busca Exaustiva (Recurs\u00e3o + Backtracking)"},{"location":"combinatoria/","text":"Combinat\u00f3ria Em constru\u00e7\u00e3o...","title":"Combinat\u00f3ria"},{"location":"combinatoria/#combinatoria","text":"Em constru\u00e7\u00e3o...","title":"Combinat\u00f3ria"},{"location":"complexidade/","text":"Complexidade de Algoritmos Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, pode-se descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"complexidade/#complexidade-de-algoritmos","text":"Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, pode-se descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"ed/","text":"Estrutura de Dados Em constru\u00e7\u00e3o...","title":"Estrutura de Dados"},{"location":"ed/#estrutura-de-dados","text":"Em constru\u00e7\u00e3o...","title":"Estrutura de Dados"},{"location":"gc/","text":"Geometria Computacional Em constru\u00e7\u00e3o...","title":"Geometria Computacional"},{"location":"gc/#geometria-computacional","text":"Em constru\u00e7\u00e3o...","title":"Geometria Computacional"},{"location":"grafos/","text":"Grafos Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"grafos/#grafos","text":"Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"guloso/","text":"Algoritmos Gulosos Em constru\u00e7\u00e3o...","title":"Algoritmos Gulosos"},{"location":"guloso/#algoritmos-gulosos","text":"Em constru\u00e7\u00e3o...","title":"Algoritmos Gulosos"},{"location":"inicio/","text":"Programa\u00e7\u00e3o Competitiva Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 . Caracteristicas da linguagem 1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada. Entrada e Sa\u00edda Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output Trabalhando com n\u00fameros Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types Simplificando o c\u00f3digo Nomes de tipos Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pi ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ; Macros Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) . Dicas e truques de C++ A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Inicio"},{"location":"inicio/#programacao-competitiva","text":"Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 .","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"inicio/#caracteristicas-da-linguagem","text":"1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada.","title":"Caracteristicas da linguagem"},{"location":"inicio/#entrada-e-saida","text":"Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output","title":"Entrada e Sa\u00edda"},{"location":"inicio/#trabalhando-com-numeros","text":"Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types","title":"Trabalhando com n\u00fameros"},{"location":"inicio/#simplificando-o-codigo","text":"","title":"Simplificando o c\u00f3digo"},{"location":"inicio/#nomes-de-tipos","text":"Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pi ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ;","title":"Nomes de tipos"},{"location":"inicio/#macros","text":"Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) .","title":"Macros"},{"location":"inicio/#dicas-e-truques-de-c","text":"A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Dicas e truques de C++"},{"location":"manipulacaobits/","text":"Manipula\u00e7\u00e3o de Bits Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequencia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequencia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valroes inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorerr\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois). Operadores sobre Bits Operador AND ( & e &= ) Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) . Operador OR inclusivo ( | e |= ) Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110 Operador OR exclusivo ( ^ e ^= ) Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110 Operador NOT ( ~ e ~= ) Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A formula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 . Operador de deslocamento \u00e0 esquerda ( << e <<= ) Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56 Operador de deslocamento \u00e0 direita ( >> e >>= ) Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010000 -> 16 a = a >> 1 // 00001000 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7 Fun\u00e7\u00f5es adicionais O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x) Alguns truques e aplica\u00e7\u00f5es Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois. std::bitset Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o . Links adicionais Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#manipulacao-de-bits","text":"Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequencia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequencia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valroes inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorerr\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois).","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#operadores-sobre-bits","text":"","title":"Operadores sobre Bits"},{"location":"manipulacaobits/#operador-and-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) .","title":"Operador AND (&amp; e &amp;=)"},{"location":"manipulacaobits/#operador-or-inclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110","title":"Operador OR inclusivo (| e |=)"},{"location":"manipulacaobits/#operador-or-exclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110","title":"Operador OR exclusivo (^ e ^=)"},{"location":"manipulacaobits/#operador-not-e","text":"Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A formula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 .","title":"Operador NOT (~ e ~=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-esquerda-e","text":"Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56","title":"Operador de deslocamento \u00e0 esquerda (&lt;&lt; e &lt;&lt;=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-direita-e","text":"Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010000 -> 16 a = a >> 1 // 00001000 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7","title":"Operador de deslocamento \u00e0 direita (&gt;&gt; e &gt;&gt;=)"},{"location":"manipulacaobits/#funcoes-adicionais","text":"O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x)","title":"Fun\u00e7\u00f5es adicionais"},{"location":"manipulacaobits/#alguns-truques-e-aplicacoes","text":"Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois.","title":"Alguns truques e aplica\u00e7\u00f5es"},{"location":"manipulacaobits/#stdbitset","text":"Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o .","title":"std::bitset"},{"location":"manipulacaobits/#links-adicionais","text":"Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Links adicionais"},{"location":"ordenacao/","text":"Ordena\u00e7\u00e3o e Busca Em constru\u00e7\u00e3o...","title":"Ordena\u00e7\u00e3o e Busca"},{"location":"ordenacao/#ordenacao-e-busca","text":"Em constru\u00e7\u00e3o...","title":"Ordena\u00e7\u00e3o e Busca"},{"location":"pd/","text":"Programa\u00e7\u00e3o Din\u00e2mica Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o din\u00e2mica"},{"location":"pd/#programacao-dinamica","text":"Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o Din\u00e2mica"},{"location":"strings/","text":"Processamento de Strings Em constru\u00e7\u00e3o...","title":"Processamento de strings"},{"location":"strings/#processamento-de-strings","text":"Em constru\u00e7\u00e3o...","title":"Processamento de Strings"},{"location":"teorianumeros/","text":"Teoria dos N\u00fameros 1 Teoria dos N\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda os n\u00fameros inteiros. Dominar o maior n\u00famero poss\u00edvel de t\u00f3picos da teoria dos n\u00fameros \u00e9 importante, pois alguns problemas matem\u00e1ticos se tornam f\u00e1ceis (ou mais f\u00e1ceis) se voc\u00ea conhecer a teoria por tr\u00e1s do problema. Divisibilidade Um inteiro \\(n\\) \u00e9 divis\u00edvel por um inteiro \\(d\\) (denotado por \\(d | n\\) .) se houver outro inteiro \\(q\\) tal que \\(n = d \\times q\\) . Tamb\u00e9m \u00e9 dito que \\(d\\) \u00e9 um divisor de \\(n\\) . Dividindo os dois lados da igualdade \\(n = dq\\) por \\(d\\) tem-se uma defini\u00e7\u00e3o quase equivalente, ou seja, que \\(\\frac{n}{d}\\) \u00e9 um inteiro. Exemplo O n\u00famero 12 possui 6 divisores: \\(1~(1 \\times 12 = 12), 2~(2 \\times 6 = 12), 3~(3 \\times 4 = 12), 4~(4 \\times 3 = 12), 6~(6 \\times 6 = 12)\\) e \\(12~(12 \\times 1 = 12)\\) . O conceito de divisibilidade traz muitas quest\u00f5es. A primeira \u00e9 como verificar se um n\u00famro \u00e9 divis\u00edvel por outro. Para n\u00famero pequenos, que podem ser armazenados em vari\u00e1veis, por exemplo, do tipo long long , pode-se usar o operador m\u00f3dulo ou resto da divis\u00e3o ( % ): \\(n\\) \u00e9 divis\u00edvel por \\(d\\) se e somente se \u01f9 % d == 0 . Entretanto, para n\u00fameros inteiros grandes a solu\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples. Na Se\u00e7\u00e3o Aritm\u00e9tica Modular ser\u00e1 discutido como implementar o operador m\u00f3dulo para n\u00famero inteiros grandes. Outra quest\u00e3o \u00e9 como calcular os divisores de um n\u00famero. Todo inteiro \\(n\\) tem pelo menos dois divisores ( \\(1\\) e \\(n\\) ). Para encontrar os outros divisores, pode-se usar o fato que qualquer divisor \\(d\\) de \\(n\\) deve satisfazer \\(|d| \\leq |n|\\) . Assim, pode-se testar se os inteiros entre \\(1\\) e \\(n\\) s\u00e3o divisores de \\(n\\) , ou seja, um algoritmo \\(O(n)\\) . Entretanto, sempre que tem-se um divisor \\(d\\) , tem-se outro divisor \\(q\\) (veja o exemplo anterior). Por exemplo, ao afirmar que \\(3\\) \u00e9 um divisor de \\(12\\) , pois \\(3 \\times 4 = 12\\) , tem-se outro divisor, \\(4\\) . Ou seja, os divisores v\u00eam em pares. Veja outros exemplo: Exemplo O n\u00famero 16 possui 5 divisores: \\(1~(1 \\times 16 = 16), 2~(2 \\times 8 = 16), 4~(4 \\times 4 = 16), 8~(8 \\times 2 = 16)\\) e \\(16~(16 \\times 6 = 16)\\) . Dessa forma, pode-se limitar a encontrar cada elemento desses pares. Al\u00e9m disso, um dos valores de cada par deve ser limitado por \\(\\sqrt n\\) . Por qu\u00ea? Esse limite, ajuda a reduzir a complexidade do algoritmo que encontra todos os dividos de um n\u00famero para \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo retorna um vector com todos os divisores de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > divisores ( long long n ) { vector < long long > ans ; for ( long long a = 1 ; a * a <= n ; a ++ ) { // (1) if ( n % a == 0 ) { long long b = n / a ; ans . push_back ( a ); if ( a != b ) ans . push_back ( b ); } } return ans ; // (2) } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Em alguns casos, \u00e9 interessante ou necess\u00e1rio retornar os divisores ordenados Complemente sua leitura e seu conhecimento: Number of divisors / sum of divisors Divisibility Counting Divisors of a Number in \\(O(n^{\\frac{1}{3}})\\) How many divisors does a number have? N\u00fameros Primos Um n\u00famero inteiro \\(n > 1\\) \u00e9 chamado de n\u00famero primo se e somente se possui dois divisores: \\(1\\) e \\(n\\) . Um n\u00famero que n\u00e3o \u00e9 primo \u00e9 chamado de n\u00famero composto (veja a figura abaixo). O primeiro e \u00fanico n\u00famero primo par \u00e9 \\(2\\) . Os pr\u00f3ximos n\u00fameros primos s\u00e3o: \\(3, 5, 7, 11, 13, \\dots\\) . Como voc\u00ea deve imaginar, existe um n\u00famero infinito de primos (Veja a prova aqui ). N\u00fameros primos s\u00e3o os n\u00fameros naturais maiores que um que n\u00e3o s\u00e3o produtos de dois n\u00fameros naturais menores.(Fonte: Wikip\u00e9dia ) N\u00famero primo \u00e9 um t\u00f3pico importante do teoria dos n\u00fameros e a fonte de muitos problemas em programa\u00e7\u00f5es competitivas. Por isso \u00e9 de extrema importancia conhecer e dominar alguns algoritmos que envolvam n\u00fameros primos. Testes de Primalidade Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ent\u00e3o ele pode ser representado pelo produto de dois inteiros \\(a \\times b\\) , onde \\(a \\leq \\sqrt n\\) ou \\(b \\leq \\sqrt n\\) . Com isso, pode-se testar se um n\u00famero \u00e9 primo ou n\u00e3o e encontrar uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo verifica se um dado n\u00famero \\(n\\) \u00e9 primo ou n\u00e3o. 1 2 3 4 5 6 7 8 9 bool ehPrimo ( long long n ) { if ( n < 2 ) return false ; for ( long long x = 2 ; x * x <= n ; x ++ ) { // (1) if ( n % x == 0 ) return false ; } return true ; } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Ou, alternativamente: 1 2 3 4 5 6 7 8 9 10 bool isPrimeFast ( long long n ) { // (1) if ( n < 5 || n % 2 == 0 || n % 3 == 0 ) return ( n == 2 || n == 3 ); long long maxP = sqrt ( n ) + 2 ; for ( long long p = 5 ; p < maxP ; p += 6 ) { if ( p < n && n % p == 0 ) return false ; if ( p + 2 < n && n % ( p + 2 ) == 0 ) return false ; } return true ; } Fonte: primes.cpp Complemente sua leitura e seu conhecimento: Primality tests Decomposi\u00e7\u00e3o em fatores primos Todo n\u00famero positivo \\(n\\) possui uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos \u00fanica: uma forma de decompor \\(n\\) em um produto de n\u00fameros primos, ou seja: \\[ n = p_1^{a_1} \\times p_2^{a_2} \\times \\dots \\times p_k^{a_k}, \\] onde \\(p_i\\) s\u00e3o n\u00fameros primos distintos e \\(a_i\\) inteiros positivos. A fun\u00e7\u00e3o abaixo retorna um vector com a decomposi\u00e7\u00e3o em fatores primos de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > factor ( long long n ) { vector < long long > ans ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ans . push_back ( i ); n /= i ; } } if ( n > 1 ) ans . push_back ( n ); return ans ; } Note que cada fator primo aparece no vetor o n\u00famero de vezes que ele divide \\(n\\) . Por exemplo, \\(24 = 2^3 \\times 3\\) , ent\u00e3o o resultado da fun\u00e7\u00e3o \u00e9 \\([2,2,2,3]\\) . Complemente sua leitura e seu conhecimento: Integer factorization Primalidade e fatora\u00e7\u00e3o Crivo de Erat\u00f3stenes O Crivo de Erat\u00f3stenes \u00e9 um algoritmo para encontrar todos os n\u00fameros primos at\u00e9 um certo limite usando \\(O(n \\log \\log n)\\) opera\u00e7\u00f5es. A ideia do algoritmo \u00e9 a seguinte: inicialmente, escreve-se todos os n\u00fameros entre \\(2\\) e \\(n\\) . Ent\u00e3o, marca-se todos os m\u00faltiplos de \\(2\\) (j\u00e1 que \\(2\\) \u00e9 o menor n\u00famero primo). Em seguida, pega-se o pr\u00f3ximo valor que n\u00e3o foi marcado como composto, neste caso, \u00e9 o \\(3\\) . Isso significa que 3 \u00e9 primo. Ent\u00e3o, marca-se todos os m\u00faltiplos de 3 como compostos. O pr\u00f3ximo n\u00famero n\u00e3o marcado \u00e9 o \\(5\\) (pr\u00f3ximo n\u00famero primo). Marca-se todos os m\u00faltiplos de \\(5\\) . Este processo \u00e9 repetido at\u00e9 \\(n\\) . A anima\u00e7\u00e3o abaixo exemplifica a execu\u00e7\u00e3o do algoritmo para \\(n = 120\\) . Crivo de Erat\u00f3stenes: passos do algoritmo para primos abaixo de 121.(Fonte: Wikip\u00e9dia ) O c\u00f3digo abaixo exemplifica uma poss\u00edvel implementa\u00e7\u00e3o do algoritmo. Esse algoritmo possui complexidade \\(O(n \\log \\log n)\\) (veja a prova aqui ). 1 2 3 4 5 6 7 8 9 10 11 vector < bool > crivo ( long long n ) { vector < bool > primo ( n + 1 , true ); // (1) primo [ 0 ] = primo [ 1 ] = false ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( primo [ i ] && i * i <= n ) { for ( long long j = i * i ; j <= n ; j += i ) // (2) primo [ j ] = false ; } } return primo ; } Cria um array ( vector ) booleano de tamanho \\(n + 1\\) , onde todas as posi\u00e7\u00f5es s\u00e3o inicializadas com true . Iteramos por todos os n\u00fameros divis\u00edveis pelo primo i Complemente sua leitura e seu conhecimento: Sieve of Eratosthenes Linear Sieve Math note - linear sieve Primo de Mersenne N\u00famero de Mersenne \u00e9 todo n\u00famero natural da forma \\(M_{n}=2^{n}-1\\) , onde \\(n\\) \u00e9 um n\u00famero natural. Os primeiros n\u00fameros Mersenne s\u00e3o: \\(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\dots\\) . Um subconjunto particularmente interessante \u00e9 o constitu\u00eddo pelos n\u00fameros de Mersenne que s\u00e3o tamb\u00e9m primos: os primos de Mersenne . Note que nem todo n\u00famero de Mersenne \u00e9 primo, assim como nem todo n\u00famero primo \u00e9 de Mersenne. Os primeiros primos de Mersenne s\u00e3o: \\(M_2 = 3, M_3 = 7, M_5 = 31, M_7 = 127, M_13 = 8191, M_17 = 131071, M_19 = 524287, \\dots\\) Um resultado elementar sobre os n\u00fameros de Mersenne afirma que se \\(2^{n}-1\\) \u00e9 um n\u00famero primo, ent\u00e3o \\(n\\) tamb\u00e9m \u00e9 um n\u00famero primo. Algoritmo de Euclides (MDC/MMC) O m\u00e1ximo divisor comum (GCD, do ingl\u00eas greatest common divisor ) dos n\u00fameros \\(a\\) e \\(b\\) , gcd(a,b) , \u00e9 o maior n\u00famero que divide \\(a\\) e \\(b\\) , e o m\u00ednimo m\u00faltiplo comum (LCM, do ingl\u00eas least common multiple ) de \\(a\\) e \\(b\\) , lcm(a,b) , \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e \\(b\\) . O algoritmo de Euclides fornece uma maneira eficiente de encontrar o m\u00e1ximo divisor comum de dois n\u00fameros. O algoritmo \u00e9 baseado na seguinte defini\u00e7\u00e3o: \\[ \\gcd(a, b) = \\begin{cases}a,&\\text{se }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{caso contr\u00e1rio.}\\end{cases} \\] Usando essa defini\u00e7\u00e3o, o algoritmo \u00e9 facilmente implementado usando recurs\u00e3o: 1 2 3 4 5 6 long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Dica Voc\u00ea pode usar a fun\u00e7\u00e3o integrada __gcd(a, b) do C++. Pode-se mostrar que o algoritmo de Euclides possui complexidade \\(O(\\log n)\\) , onde \\(n = min(a,b)\\) . O m\u00ednimo m\u00faltiplo comum (LCM) pode ser calculado da seguinte forma: \\[ lcm(a, b) = \\frac{a \\times b}{gcd(a,b)} \\] Para calcular o GCD ou LCM de mais de dois valores, pode-se calcular o valor de dois em dois (em qualquer ordem). Por exemplo: \\[ gcd(a, b, c, d) = gcd(a, gcd(b, gcd(c, d))) \\] Fun\u00e7\u00e3o totiente de Euler A fun\u00e7\u00e3o totiente de Euler, tamb\u00e9m conhecida como fun\u00e7\u00e3o \\(\\phi (n)\\) , conta o n\u00famero de inteiros entre \\(1\\) e \\(n\\) , no qual s\u00e3o coprimos de \\(n\\) . Dois n\u00fameros s\u00e3o coprimos se o m\u00e1ximo divisor comum entre eles for 1 (1 \u00e9 considerado ser coprimo para qualquer n\u00famero). Por exemplo, \\(\\phi (12) = 4\\) , pois 1, 5, 7 e 11 s\u00e3o coprimos de 12. Abaixo est\u00e3o valores de \\(\\phi (n)\\) para os primeiros n\u00fameros inteiros positivos: \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\ \\hline \\end{array}\\] A fun\u00e7\u00e3o abaixo calcula o valor de \\(\\phi (n)\\) em \\(O(\\sqrt n)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 long long phi ( long long n ) { long long result = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Complemente sua leitura e seu conhecimento: Euclidean algorithm for computing the greatest common divisor Euler's totient function Aritm\u00e9tica Modular Na aritm\u00e9tica modular , o conjunto de n\u00fameros \u00e9 limitado de forma que apenas os n\u00fameros \\(0,1,2,\\dots,m\u22121\\) s\u00e3o usados, onde \\(m\\) \u00e9 uma constante. Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(x \\bmod m\\) : o resto da divis\u00e3o de \\(x\\) por \\(m\\) . Por exemplo, se \\(m = 23\\) , em vez \\(x = 247\\) , considera-se \\(x \\bmod 23 = 17\\) . Normalmente, \\(m\\) ser\u00e1 um primo grande, dado no problema, normalmente, \\(10^9 + 7\\) . A aritm\u00e9tica modular \u00e9 usada para evitar integer overflow . As seguintes propriedades valem no c\u00e1lculo do m\u00f3dulo: \\[(a+b) \\bmod m = (a \\bmod m + b \\bmod m) \\bmod m\\] \\[(a-b) \\bmod m = (a \\bmod m - b \\bmod m) \\bmod m\\] \\[(a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\] \\[a^b \\bmod {m} = (a \\bmod m)^b \\bmod m\\] O que significa que se a resposta est\u00e1 sendo computada por meio de adi\u00e7\u00f5es, subtra\u00e7\u00f5es e multiplica\u00e7\u00f5es, e no final voc\u00ea precisa tirar o m\u00f3dulo dela, voc\u00ea pode tirar m\u00f3dulo em todas as opera\u00e7\u00f5es intermedi\u00e1rias que isso n\u00e3o afetar\u00e1 a resposta. Exponencia\u00e7\u00e3o Bin\u00e1ria A exponencia\u00e7\u00e3o bin\u00e1ria \u00e9 um truque que permite calcular \\(x^n\\) usando apenas multiplica\u00e7\u00f5es \\(O(\\log\u2061 n)\\) (em vez das multiplica\u00e7\u00f5es \\(O(n)\\) exigidas pela abordagem ing\u00eanua). Sabe-se que \\(x^a \\cdot x^b = x^{a+b}\\) . Em particular, \\(x^{2b} = x^b \\cdot x^b\\) . Logo, se o expoente \\(n\\) de \\(x^n\\) for par, pode-se dizer que \\(x^n = x^{\\frac{n}{2}} \\cdot x^{\\frac{n}{2}}\\) . No entanto, se \\(n\\) for \u00edmpar, tem-se algo similar: \\(x^n = x^{\\frac{n-1}{2}} \\cdot x^{\\frac{n-1}{2}} \\cdot x\\) . Dessa forma, pode-se montar a seguinte recorr\u00eancia: \\[ x^n = \\begin{cases} 1 &\\text{se } n = 0 \\\\ \\left(x^{\\frac{n}{2}}\\right)^2 &\\text{se } n \\text{ par}\\\\ \\left(x^{\\frac{n - 1}{2}}\\right)^2 \\cdot x &\\text{se } n \\text{ impar}\\\\ \\end{cases} \\] Note que se \\(n\\) for par, o valor \\(x^{n/2}\\) deve ser calculado apenas uma vez. Isso garante que a complexidade do algoritmo seja \\(O(\\log n)\\) . A fun\u00e7\u00e3o abaixo calcula do valor de \\(x^n\\) : 1 2 3 4 5 6 7 8 9 long long binpow ( long long x , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( x , n / 2 ); if ( n % 2 ) return res * res * x ; else return res * res ; } Alternativamente, usando sem usar recus\u00e3o e usando manipu\u00e7\u00e3o de bits : 1 2 3 4 5 6 7 8 9 10 long long binpow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x ; x = x * x ; n >>= 1 ; } return res ; } Em alguns casos, \u00e9 necess\u00e1rio calcular o valor de \\(x^n \\bmod m\\) . Sabendo que \\((a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\) , pode-se usar diretamente c\u00f3digo anterior e apenas substituir cada multiplica\u00e7\u00e3o por uma multiplica\u00e7\u00e3o modular: 1 2 3 4 5 6 7 8 9 10 11 long long binpow ( long long x , long long n , long long m = 1 ) { // (1) x %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % m ; x = x * x % m ; n >>= 1 ; } return res ; } Deixando o valor padr\u00e3o de m como 1, pode-se usar essa fun\u00e7\u00e3o sem passar o valor de m como par\u00e2metro. Dica Se \\(m\\) \u00e9 um n\u00famero primo, pode-se acelerar um pouco este algoritmo calculando \\(x^{n \\bmod(m\u22121)}\\) em vez de \\(x^n\\) . Complemente sua leitura e seu conhecimento: Binary Exponentiation O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 e 5 \u21a9","title":"Teoria dos N\u00fameros"},{"location":"teorianumeros/#teoria-dos-numeros1","text":"Teoria dos N\u00fameros \u00e9 um ramo da matem\u00e1tica que estuda os n\u00fameros inteiros. Dominar o maior n\u00famero poss\u00edvel de t\u00f3picos da teoria dos n\u00fameros \u00e9 importante, pois alguns problemas matem\u00e1ticos se tornam f\u00e1ceis (ou mais f\u00e1ceis) se voc\u00ea conhecer a teoria por tr\u00e1s do problema.","title":"Teoria dos N\u00fameros1"},{"location":"teorianumeros/#divisibilidade","text":"Um inteiro \\(n\\) \u00e9 divis\u00edvel por um inteiro \\(d\\) (denotado por \\(d | n\\) .) se houver outro inteiro \\(q\\) tal que \\(n = d \\times q\\) . Tamb\u00e9m \u00e9 dito que \\(d\\) \u00e9 um divisor de \\(n\\) . Dividindo os dois lados da igualdade \\(n = dq\\) por \\(d\\) tem-se uma defini\u00e7\u00e3o quase equivalente, ou seja, que \\(\\frac{n}{d}\\) \u00e9 um inteiro. Exemplo O n\u00famero 12 possui 6 divisores: \\(1~(1 \\times 12 = 12), 2~(2 \\times 6 = 12), 3~(3 \\times 4 = 12), 4~(4 \\times 3 = 12), 6~(6 \\times 6 = 12)\\) e \\(12~(12 \\times 1 = 12)\\) . O conceito de divisibilidade traz muitas quest\u00f5es. A primeira \u00e9 como verificar se um n\u00famro \u00e9 divis\u00edvel por outro. Para n\u00famero pequenos, que podem ser armazenados em vari\u00e1veis, por exemplo, do tipo long long , pode-se usar o operador m\u00f3dulo ou resto da divis\u00e3o ( % ): \\(n\\) \u00e9 divis\u00edvel por \\(d\\) se e somente se \u01f9 % d == 0 . Entretanto, para n\u00fameros inteiros grandes a solu\u00e7\u00e3o n\u00e3o \u00e9 t\u00e3o simples. Na Se\u00e7\u00e3o Aritm\u00e9tica Modular ser\u00e1 discutido como implementar o operador m\u00f3dulo para n\u00famero inteiros grandes. Outra quest\u00e3o \u00e9 como calcular os divisores de um n\u00famero. Todo inteiro \\(n\\) tem pelo menos dois divisores ( \\(1\\) e \\(n\\) ). Para encontrar os outros divisores, pode-se usar o fato que qualquer divisor \\(d\\) de \\(n\\) deve satisfazer \\(|d| \\leq |n|\\) . Assim, pode-se testar se os inteiros entre \\(1\\) e \\(n\\) s\u00e3o divisores de \\(n\\) , ou seja, um algoritmo \\(O(n)\\) . Entretanto, sempre que tem-se um divisor \\(d\\) , tem-se outro divisor \\(q\\) (veja o exemplo anterior). Por exemplo, ao afirmar que \\(3\\) \u00e9 um divisor de \\(12\\) , pois \\(3 \\times 4 = 12\\) , tem-se outro divisor, \\(4\\) . Ou seja, os divisores v\u00eam em pares. Veja outros exemplo: Exemplo O n\u00famero 16 possui 5 divisores: \\(1~(1 \\times 16 = 16), 2~(2 \\times 8 = 16), 4~(4 \\times 4 = 16), 8~(8 \\times 2 = 16)\\) e \\(16~(16 \\times 6 = 16)\\) . Dessa forma, pode-se limitar a encontrar cada elemento desses pares. Al\u00e9m disso, um dos valores de cada par deve ser limitado por \\(\\sqrt n\\) . Por qu\u00ea? Esse limite, ajuda a reduzir a complexidade do algoritmo que encontra todos os dividos de um n\u00famero para \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo retorna um vector com todos os divisores de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > divisores ( long long n ) { vector < long long > ans ; for ( long long a = 1 ; a * a <= n ; a ++ ) { // (1) if ( n % a == 0 ) { long long b = n / a ; ans . push_back ( a ); if ( a != b ) ans . push_back ( b ); } } return ans ; // (2) } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Em alguns casos, \u00e9 interessante ou necess\u00e1rio retornar os divisores ordenados Complemente sua leitura e seu conhecimento: Number of divisors / sum of divisors Divisibility Counting Divisors of a Number in \\(O(n^{\\frac{1}{3}})\\) How many divisors does a number have?","title":"Divisibilidade"},{"location":"teorianumeros/#numeros-primos","text":"Um n\u00famero inteiro \\(n > 1\\) \u00e9 chamado de n\u00famero primo se e somente se possui dois divisores: \\(1\\) e \\(n\\) . Um n\u00famero que n\u00e3o \u00e9 primo \u00e9 chamado de n\u00famero composto (veja a figura abaixo). O primeiro e \u00fanico n\u00famero primo par \u00e9 \\(2\\) . Os pr\u00f3ximos n\u00fameros primos s\u00e3o: \\(3, 5, 7, 11, 13, \\dots\\) . Como voc\u00ea deve imaginar, existe um n\u00famero infinito de primos (Veja a prova aqui ). N\u00fameros primos s\u00e3o os n\u00fameros naturais maiores que um que n\u00e3o s\u00e3o produtos de dois n\u00fameros naturais menores.(Fonte: Wikip\u00e9dia ) N\u00famero primo \u00e9 um t\u00f3pico importante do teoria dos n\u00fameros e a fonte de muitos problemas em programa\u00e7\u00f5es competitivas. Por isso \u00e9 de extrema importancia conhecer e dominar alguns algoritmos que envolvam n\u00fameros primos.","title":"N\u00fameros Primos"},{"location":"teorianumeros/#testes-de-primalidade","text":"Se um n\u00famero \\(n\\) n\u00e3o \u00e9 primo, ent\u00e3o ele pode ser representado pelo produto de dois inteiros \\(a \\times b\\) , onde \\(a \\leq \\sqrt n\\) ou \\(b \\leq \\sqrt n\\) . Com isso, pode-se testar se um n\u00famero \u00e9 primo ou n\u00e3o e encontrar uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos em \\(O(\\sqrt n)\\) . A fun\u00e7\u00e3o abaixo verifica se um dado n\u00famero \\(n\\) \u00e9 primo ou n\u00e3o. 1 2 3 4 5 6 7 8 9 bool ehPrimo ( long long n ) { if ( n < 2 ) return false ; for ( long long x = 2 ; x * x <= n ; x ++ ) { // (1) if ( n % x == 0 ) return false ; } return true ; } x <= sqrt(n) \u00e9 o mesmo que x*x <= n . Ou, alternativamente: 1 2 3 4 5 6 7 8 9 10 bool isPrimeFast ( long long n ) { // (1) if ( n < 5 || n % 2 == 0 || n % 3 == 0 ) return ( n == 2 || n == 3 ); long long maxP = sqrt ( n ) + 2 ; for ( long long p = 5 ; p < maxP ; p += 6 ) { if ( p < n && n % p == 0 ) return false ; if ( p + 2 < n && n % ( p + 2 ) == 0 ) return false ; } return true ; } Fonte: primes.cpp Complemente sua leitura e seu conhecimento: Primality tests","title":"Testes de Primalidade"},{"location":"teorianumeros/#decomposicao-em-fatores-primos","text":"Todo n\u00famero positivo \\(n\\) possui uma decomposi\u00e7\u00e3o (fatora\u00e7\u00e3o) em fatores primos \u00fanica: uma forma de decompor \\(n\\) em um produto de n\u00fameros primos, ou seja: \\[ n = p_1^{a_1} \\times p_2^{a_2} \\times \\dots \\times p_k^{a_k}, \\] onde \\(p_i\\) s\u00e3o n\u00fameros primos distintos e \\(a_i\\) inteiros positivos. A fun\u00e7\u00e3o abaixo retorna um vector com a decomposi\u00e7\u00e3o em fatores primos de \\(n\\) . 1 2 3 4 5 6 7 8 9 10 11 vector < long long > factor ( long long n ) { vector < long long > ans ; for ( long long i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ans . push_back ( i ); n /= i ; } } if ( n > 1 ) ans . push_back ( n ); return ans ; } Note que cada fator primo aparece no vetor o n\u00famero de vezes que ele divide \\(n\\) . Por exemplo, \\(24 = 2^3 \\times 3\\) , ent\u00e3o o resultado da fun\u00e7\u00e3o \u00e9 \\([2,2,2,3]\\) . Complemente sua leitura e seu conhecimento: Integer factorization Primalidade e fatora\u00e7\u00e3o","title":"Decomposi\u00e7\u00e3o em fatores primos"},{"location":"teorianumeros/#crivo-de-eratostenes","text":"O Crivo de Erat\u00f3stenes \u00e9 um algoritmo para encontrar todos os n\u00fameros primos at\u00e9 um certo limite usando \\(O(n \\log \\log n)\\) opera\u00e7\u00f5es. A ideia do algoritmo \u00e9 a seguinte: inicialmente, escreve-se todos os n\u00fameros entre \\(2\\) e \\(n\\) . Ent\u00e3o, marca-se todos os m\u00faltiplos de \\(2\\) (j\u00e1 que \\(2\\) \u00e9 o menor n\u00famero primo). Em seguida, pega-se o pr\u00f3ximo valor que n\u00e3o foi marcado como composto, neste caso, \u00e9 o \\(3\\) . Isso significa que 3 \u00e9 primo. Ent\u00e3o, marca-se todos os m\u00faltiplos de 3 como compostos. O pr\u00f3ximo n\u00famero n\u00e3o marcado \u00e9 o \\(5\\) (pr\u00f3ximo n\u00famero primo). Marca-se todos os m\u00faltiplos de \\(5\\) . Este processo \u00e9 repetido at\u00e9 \\(n\\) . A anima\u00e7\u00e3o abaixo exemplifica a execu\u00e7\u00e3o do algoritmo para \\(n = 120\\) . Crivo de Erat\u00f3stenes: passos do algoritmo para primos abaixo de 121.(Fonte: Wikip\u00e9dia ) O c\u00f3digo abaixo exemplifica uma poss\u00edvel implementa\u00e7\u00e3o do algoritmo. Esse algoritmo possui complexidade \\(O(n \\log \\log n)\\) (veja a prova aqui ). 1 2 3 4 5 6 7 8 9 10 11 vector < bool > crivo ( long long n ) { vector < bool > primo ( n + 1 , true ); // (1) primo [ 0 ] = primo [ 1 ] = false ; for ( long long i = 2 ; i <= n ; i ++ ) { if ( primo [ i ] && i * i <= n ) { for ( long long j = i * i ; j <= n ; j += i ) // (2) primo [ j ] = false ; } } return primo ; } Cria um array ( vector ) booleano de tamanho \\(n + 1\\) , onde todas as posi\u00e7\u00f5es s\u00e3o inicializadas com true . Iteramos por todos os n\u00fameros divis\u00edveis pelo primo i Complemente sua leitura e seu conhecimento: Sieve of Eratosthenes Linear Sieve Math note - linear sieve","title":"Crivo de Erat\u00f3stenes"},{"location":"teorianumeros/#primo-de-mersenne","text":"N\u00famero de Mersenne \u00e9 todo n\u00famero natural da forma \\(M_{n}=2^{n}-1\\) , onde \\(n\\) \u00e9 um n\u00famero natural. Os primeiros n\u00fameros Mersenne s\u00e3o: \\(0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\dots\\) . Um subconjunto particularmente interessante \u00e9 o constitu\u00eddo pelos n\u00fameros de Mersenne que s\u00e3o tamb\u00e9m primos: os primos de Mersenne . Note que nem todo n\u00famero de Mersenne \u00e9 primo, assim como nem todo n\u00famero primo \u00e9 de Mersenne. Os primeiros primos de Mersenne s\u00e3o: \\(M_2 = 3, M_3 = 7, M_5 = 31, M_7 = 127, M_13 = 8191, M_17 = 131071, M_19 = 524287, \\dots\\) Um resultado elementar sobre os n\u00fameros de Mersenne afirma que se \\(2^{n}-1\\) \u00e9 um n\u00famero primo, ent\u00e3o \\(n\\) tamb\u00e9m \u00e9 um n\u00famero primo.","title":"Primo de Mersenne"},{"location":"teorianumeros/#algoritmo-de-euclides-mdcmmc","text":"O m\u00e1ximo divisor comum (GCD, do ingl\u00eas greatest common divisor ) dos n\u00fameros \\(a\\) e \\(b\\) , gcd(a,b) , \u00e9 o maior n\u00famero que divide \\(a\\) e \\(b\\) , e o m\u00ednimo m\u00faltiplo comum (LCM, do ingl\u00eas least common multiple ) de \\(a\\) e \\(b\\) , lcm(a,b) , \u00e9 o menor n\u00famero que \u00e9 divis\u00edvel por \\(a\\) e \\(b\\) . O algoritmo de Euclides fornece uma maneira eficiente de encontrar o m\u00e1ximo divisor comum de dois n\u00fameros. O algoritmo \u00e9 baseado na seguinte defini\u00e7\u00e3o: \\[ \\gcd(a, b) = \\begin{cases}a,&\\text{se }b = 0 \\\\ \\gcd(b, a \\bmod b),&\\text{caso contr\u00e1rio.}\\end{cases} \\] Usando essa defini\u00e7\u00e3o, o algoritmo \u00e9 facilmente implementado usando recurs\u00e3o: 1 2 3 4 5 6 long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ); } Dica Voc\u00ea pode usar a fun\u00e7\u00e3o integrada __gcd(a, b) do C++. Pode-se mostrar que o algoritmo de Euclides possui complexidade \\(O(\\log n)\\) , onde \\(n = min(a,b)\\) . O m\u00ednimo m\u00faltiplo comum (LCM) pode ser calculado da seguinte forma: \\[ lcm(a, b) = \\frac{a \\times b}{gcd(a,b)} \\] Para calcular o GCD ou LCM de mais de dois valores, pode-se calcular o valor de dois em dois (em qualquer ordem). Por exemplo: \\[ gcd(a, b, c, d) = gcd(a, gcd(b, gcd(c, d))) \\]","title":"Algoritmo de Euclides (MDC/MMC)"},{"location":"teorianumeros/#funcao-totiente-de-euler","text":"A fun\u00e7\u00e3o totiente de Euler, tamb\u00e9m conhecida como fun\u00e7\u00e3o \\(\\phi (n)\\) , conta o n\u00famero de inteiros entre \\(1\\) e \\(n\\) , no qual s\u00e3o coprimos de \\(n\\) . Dois n\u00fameros s\u00e3o coprimos se o m\u00e1ximo divisor comum entre eles for 1 (1 \u00e9 considerado ser coprimo para qualquer n\u00famero). Por exemplo, \\(\\phi (12) = 4\\) , pois 1, 5, 7 e 11 s\u00e3o coprimos de 12. Abaixo est\u00e3o valores de \\(\\phi (n)\\) para os primeiros n\u00fameros inteiros positivos: \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline n & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 & 21 \\\\ \\hline \\phi(n) & 1 & 1 & 2 & 2 & 4 & 2 & 6 & 4 & 6 & 4 & 10 & 4 & 12 & 6 & 8 & 8 & 16 & 6 & 18 & 8 & 12 \\\\ \\hline \\end{array}\\] A fun\u00e7\u00e3o abaixo calcula o valor de \\(\\phi (n)\\) em \\(O(\\sqrt n)\\) . 1 2 3 4 5 6 7 8 9 10 11 12 13 long long phi ( long long n ) { long long result = n ; for ( long long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n /= i ; result -= result / i ; } } if ( n > 1 ) result -= result / n ; return result ; } Complemente sua leitura e seu conhecimento: Euclidean algorithm for computing the greatest common divisor Euler's totient function","title":"Fun\u00e7\u00e3o totiente de Euler"},{"location":"teorianumeros/#aritmetica-modular","text":"Na aritm\u00e9tica modular , o conjunto de n\u00fameros \u00e9 limitado de forma que apenas os n\u00fameros \\(0,1,2,\\dots,m\u22121\\) s\u00e3o usados, onde \\(m\\) \u00e9 uma constante. Cada n\u00famero \\(x\\) \u00e9 representado pelo n\u00famero \\(x \\bmod m\\) : o resto da divis\u00e3o de \\(x\\) por \\(m\\) . Por exemplo, se \\(m = 23\\) , em vez \\(x = 247\\) , considera-se \\(x \\bmod 23 = 17\\) . Normalmente, \\(m\\) ser\u00e1 um primo grande, dado no problema, normalmente, \\(10^9 + 7\\) . A aritm\u00e9tica modular \u00e9 usada para evitar integer overflow . As seguintes propriedades valem no c\u00e1lculo do m\u00f3dulo: \\[(a+b) \\bmod m = (a \\bmod m + b \\bmod m) \\bmod m\\] \\[(a-b) \\bmod m = (a \\bmod m - b \\bmod m) \\bmod m\\] \\[(a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\] \\[a^b \\bmod {m} = (a \\bmod m)^b \\bmod m\\] O que significa que se a resposta est\u00e1 sendo computada por meio de adi\u00e7\u00f5es, subtra\u00e7\u00f5es e multiplica\u00e7\u00f5es, e no final voc\u00ea precisa tirar o m\u00f3dulo dela, voc\u00ea pode tirar m\u00f3dulo em todas as opera\u00e7\u00f5es intermedi\u00e1rias que isso n\u00e3o afetar\u00e1 a resposta.","title":"Aritm\u00e9tica Modular"},{"location":"teorianumeros/#exponenciacao-binaria","text":"A exponencia\u00e7\u00e3o bin\u00e1ria \u00e9 um truque que permite calcular \\(x^n\\) usando apenas multiplica\u00e7\u00f5es \\(O(\\log\u2061 n)\\) (em vez das multiplica\u00e7\u00f5es \\(O(n)\\) exigidas pela abordagem ing\u00eanua). Sabe-se que \\(x^a \\cdot x^b = x^{a+b}\\) . Em particular, \\(x^{2b} = x^b \\cdot x^b\\) . Logo, se o expoente \\(n\\) de \\(x^n\\) for par, pode-se dizer que \\(x^n = x^{\\frac{n}{2}} \\cdot x^{\\frac{n}{2}}\\) . No entanto, se \\(n\\) for \u00edmpar, tem-se algo similar: \\(x^n = x^{\\frac{n-1}{2}} \\cdot x^{\\frac{n-1}{2}} \\cdot x\\) . Dessa forma, pode-se montar a seguinte recorr\u00eancia: \\[ x^n = \\begin{cases} 1 &\\text{se } n = 0 \\\\ \\left(x^{\\frac{n}{2}}\\right)^2 &\\text{se } n \\text{ par}\\\\ \\left(x^{\\frac{n - 1}{2}}\\right)^2 \\cdot x &\\text{se } n \\text{ impar}\\\\ \\end{cases} \\] Note que se \\(n\\) for par, o valor \\(x^{n/2}\\) deve ser calculado apenas uma vez. Isso garante que a complexidade do algoritmo seja \\(O(\\log n)\\) . A fun\u00e7\u00e3o abaixo calcula do valor de \\(x^n\\) : 1 2 3 4 5 6 7 8 9 long long binpow ( long long x , long long n ) { if ( n == 0 ) return 1 ; long long res = binpow ( x , n / 2 ); if ( n % 2 ) return res * res * x ; else return res * res ; } Alternativamente, usando sem usar recus\u00e3o e usando manipu\u00e7\u00e3o de bits : 1 2 3 4 5 6 7 8 9 10 long long binpow ( long long x , long long n ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x ; x = x * x ; n >>= 1 ; } return res ; } Em alguns casos, \u00e9 necess\u00e1rio calcular o valor de \\(x^n \\bmod m\\) . Sabendo que \\((a \\cdot b) \\pmod{m} = ((a \\bmod m) \\cdot (b \\bmod m)) \\bmod m\\) , pode-se usar diretamente c\u00f3digo anterior e apenas substituir cada multiplica\u00e7\u00e3o por uma multiplica\u00e7\u00e3o modular: 1 2 3 4 5 6 7 8 9 10 11 long long binpow ( long long x , long long n , long long m = 1 ) { // (1) x %= m ; long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * x % m ; x = x * x % m ; n >>= 1 ; } return res ; } Deixando o valor padr\u00e3o de m como 1, pode-se usar essa fun\u00e7\u00e3o sem passar o valor de m como par\u00e2metro. Dica Se \\(m\\) \u00e9 um n\u00famero primo, pode-se acelerar um pouco este algoritmo calculando \\(x^{n \\bmod(m\u22121)}\\) em vez de \\(x^n\\) . Complemente sua leitura e seu conhecimento: Binary Exponentiation O texto dessa p\u00e1gina s\u00e3o tradu\u00e7\u00f5es e adapta\u00e7\u00f5es encontrados aqui: 1 , 2 , 3 , 4 e 5 \u21a9","title":"Exponencia\u00e7\u00e3o Bin\u00e1ria"}]}