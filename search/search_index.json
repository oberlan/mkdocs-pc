{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programa\u00e7\u00e3o Competitiva Ementa Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional. Objetivos Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas. Programas e Sites Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona Bibliografia Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++ Notebooks Stanford University Royal Institute of Technology","title":"Disciplina"},{"location":"#programacao-competitiva","text":"","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"#ementa","text":"Revis\u00e3o de conceitos de programa\u00e7\u00e3o e algoritmos. Fundamentos de an\u00e1lise de algoritmos. Algoritmos de busca e ordena\u00e7\u00e3o. Estrutura de dados b\u00e1sicas e avan\u00e7adas. Teoria dos n\u00fameros. Paradigmas de solu\u00e7\u00f5es de problemas: busca exaustiva, dividir para conquistar, algoritmo guloso e programa\u00e7\u00e3o din\u00e2mica. Grafos. Processamento de strings. Geometria computacional.","title":"Ementa"},{"location":"#objetivos","text":"Introduzir t\u00e9cnicas de programa\u00e7\u00e3o e no\u00e7\u00f5es de complexidade de algoritmos; Familiariza\u00e7\u00e3o com ambientes de treinamento de competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar estruturas de dados b\u00e1sicas e avan\u00e7adas comumente utilizadas em competi\u00e7\u00f5es de programa\u00e7\u00e3o; Estudar algoritmos eficientes de busca e ordena\u00e7\u00e3o de dados; Estudar diferentes teorias de n\u00fameros; Apresentar e estudar diferentes tipos de paradigmas de solu\u00e7\u00f5es de problemas; Apresentar os conceitos e os principais algoritmos de grafos; Apresentar e estudar os algoritmos de processamento de strings e geometria computacional; Identificar qual o melhor algoritmo ou estrat\u00e9gia deve ser usada para resolver diferentes problemas.","title":"Objetivos"},{"location":"#programas-e-sites","text":"Programar offline: GCC (Linux) / MinGW (Windows) VS Code / Sublime Text Programar online: CS50 IDE VSCode for CS50 Judge: Maratona","title":"Programas e Sites"},{"location":"#bibliografia","text":"Competitive Programmer\u2019s Handbook Principles of Algorithmic Problem Solving Algorithms for Competitive Programming An Introduction to the USA Computing Olympiad Dynamic Programming for Computing Contest Algorithms Learn C++","title":"Bibliografia"},{"location":"#notebooks","text":"Stanford University Royal Institute of Technology","title":"Notebooks"},{"location":"buscaexaustiva/","text":"Busca Exaustiva (Recurs\u00e3o + Backtracking) Em constru\u00e7\u00e3o...","title":"Busca Exaustiva"},{"location":"buscaexaustiva/#busca-exaustiva-recursao-backtracking","text":"Em constru\u00e7\u00e3o...","title":"Busca Exaustiva (Recurs\u00e3o + Backtracking)"},{"location":"complexidade/","text":"Complexidade de Algoritmos Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, podemos descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"complexidade/#complexidade-de-algoritmos","text":"Em programa\u00e7\u00e3o competitiva \u00e9 de extrema import\u00e2ncia saber a complexidade do algoritmo desenvolvido. Normalmente, \u00e9 f\u00e1cil desenvolver um algoritmo que resolva um problema lentamente, mas o verdadeiro desafio \u00e9 projetar um algoritmo r\u00e1pido/eficiente. A complexidade de tempo de um algoritmo estima quantas opera\u00e7\u00f5es o algoritmo usar\u00e1 para alguma entrada. A ideia \u00e9 representar a efici\u00eancia como uma fun\u00e7\u00e3o cujo par\u00e2metro \u00e9 o tamanho da entrada. Calculando a complexidade de tempo, podemos descobrir se o algoritmo \u00e9 r\u00e1pido o suficiente sem implement\u00e1-lo. Leia o Cap\u00edtulo 2 do livro \"Competitive Programmer\u2019s Handbook\".","title":"Complexidade de Algoritmos"},{"location":"ed/","text":"Estrutura de Dados Em constru\u00e7\u00e3o...","title":"Estrutura de Dados"},{"location":"ed/#estrutura-de-dados","text":"Em constru\u00e7\u00e3o...","title":"Estrutura de Dados"},{"location":"gc/","text":"Geometria Computacional Em constru\u00e7\u00e3o...","title":"Geometria Computacional"},{"location":"gc/#geometria-computacional","text":"Em constru\u00e7\u00e3o...","title":"Geometria Computacional"},{"location":"grafos/","text":"Grafos Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"grafos/#grafos","text":"Em constru\u00e7\u00e3o...","title":"Grafos"},{"location":"guloso/","text":"Algoritmos Gulosos Em constru\u00e7\u00e3o...","title":"Algoritmos Gulosos"},{"location":"guloso/#algoritmos-gulosos","text":"Em constru\u00e7\u00e3o...","title":"Algoritmos Gulosos"},{"location":"inicio/","text":"Programa\u00e7\u00e3o Competitiva Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 . Caracteristicas da linguagem 1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada. Entrada e Sa\u00edda Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output Trabalhando com n\u00fameros Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types Simplificando o c\u00f3digo Nomes de tipos Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pi ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ; Macros Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) . Dicas e truques de C++ A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Inicio"},{"location":"inicio/#programacao-competitiva","text":"Vamos come\u00e7ar apresentando alguns dos recursos da linguagem de programa\u00e7\u00e3o C++ que s\u00e3o \u00fateis na programa\u00e7\u00e3o competitiva. Todos os comandos ser\u00e3o dados considerando o Linux como Sistema Operaciona. Caso esteja usando Windows, use o CS50 IDE ou VSCode for CS50 .","title":"Programa\u00e7\u00e3o Competitiva"},{"location":"inicio/#caracteristicas-da-linguagem","text":"1 2 3 4 5 6 7 8 #include <bits/stdc++.h> // (1) using namespace std ; // (2) int main () { // c\u00f3digo return 0 ; } Recurso do compilador g++ que permite incluir toda a biblioteca padr\u00e3o. Assim, n\u00e3o \u00e9 necess\u00e1rio incluir separadamente bibliotecas como iostream , vector , e algorithm . Clique aqui para saber mais . Declara que as classes e fun\u00e7\u00f5es da biblioteca padr\u00e3o podem ser usadas diretamente no c\u00f3digo. Sem essa linha ter\u00edamos que escrever, por exemplo, std::cout ao inv\u00e9s de apenas cout . O c\u00f3digo pode ser compilado usando o seguinte comando: g++ main.cpp -o programa O comando produz um arquivo bin\u00e1rio, chamado programa , a partir do c\u00f3digo-fonte main.cpp . Leia mais aqui . Para evitar bugs comuns, sempre iremos compilar o c\u00f3digo com algumas flags de compila\u00e7\u00e3o: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable main.cpp -o programa Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o do c\u00f3digo, crie um arquivo chamado cr e adicione o seguinte c\u00f3digo: g++ -O2 -std = c++17 -Wshadow -fsanitize = address,undefined -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wno-unused-but-set-variable $1 -o programa && time ./programa < in No terminal, execute o comando chmod +x cr para dar direitos de execu\u00e7\u00e3o ao arquivo cr . Para us\u00e1-lo basta passar como argumento um arquivo .cpp , por exemplo, ./cr main.cpp . O c\u00f3digo ser\u00e1 compilado e, em caso de sucesso, ser\u00e1 gerado um programa chamado programa que ser\u00e1 executado considerando o arquivo in como dado de entrada. Ao usar o arquivo in , n\u00e3o precisamos digitar os dados de entrada.","title":"Caracteristicas da linguagem"},{"location":"inicio/#entrada-e-saida","text":"Na maioria dos contests , \u00e9 necess\u00e1rio ler da entrada padr\u00e3o (teclado) e escrever algo. Em C++, \u00e9 usado o cin para leitura e cout para sa\u00edda. Tamb\u00e9m podem ser usado as fun\u00e7\u00f5es de C, como scanf e printf . A entrada do programa geralmente consiste em n\u00fameros e strings separados por espa\u00e7os e/ou novas linhas. Eles podem ser lidos a partir do cin da seguinte forma: 1 2 3 int a , b ; string c ; cin >> a >> b >> c ; Considerando que h\u00e1 ao menos um espa\u00e7o em branco ou uma nova linha entre cada elemento da entrada, esse c\u00f3digo sempre funciona. O cout pode ser usado da seguinte forma: 1 cout << a << \" \" << b << \" \" << c << \" \\n \" ; // (1) Um espa\u00e7o em branco ir\u00e1 separar cada informa\u00e7\u00e3o. Ao fim, uma linha em branco ( \\ n ) ser\u00e1 gerada. \u00c0s vezes, a entrada e a sa\u00edda podem ser um gargalo em um programa. Por isso, \u00e9 comum ser adicionado as seguintes linhas no in\u00edcio do c\u00f3digo: 1 2 ios_base :: sync_with_stdio ( 0 ); // (1) cin . tie ( 0 ); // (2) std::ios_base::sync_with_stdio std::ios::tie Aten\u00e7\u00e3o Ao usar o comando ios_base :: sync_with_stdio ( 0 ); , ser\u00e1 desativado a sincroniza\u00e7\u00e3o entre as fun\u00e7\u00e3o de C++ e C, por isso n\u00e3o use as fun\u00e7\u00e3o de entrada e sa\u00edda de C ( scanf e printf ) junto com esse comando. Alternativamente ao \\n podemos usar o comando endl . Entretanto, este comando ir\u00e1 liberar o buffer de sa\u00edda e far\u00e1 com que o c\u00f3digo rode mais lento. Por isso, prefira usar o \\n . Dica Use sempre o \\n ao inv\u00e9s do endl . Use uma macro #define endl '\\n' para n\u00e3o correr o risco de esquecer. Para se aprofundar mais: Input & Output Fast Input & Output","title":"Entrada e Sa\u00edda"},{"location":"inicio/#trabalhando-com-numeros","text":"Inteiros: Para evitar integer overflow , use sempre long long (64bits) ao inv\u00e9s de int . Reais: Use double (64bits) ou long double (80bits). Esque\u00e7a o float \ud83d\ude05. Al\u00e9m disso, nunca compare dois double com o operador == (\u00e9 poss\u00edvel que os valores sejam iguais, mas n\u00e3o s\u00e3o devido a erros de precis\u00e3o). Para verificar se dois double use o c\u00f3digo a seguir: 1 2 3 4 5 6 double a , b ; ... if ( abs ( a - b ) < 1e-9 ) { //a e b s\u00e3o iguais } ... Para saber mais: Data Types","title":"Trabalhando com n\u00fameros"},{"location":"inicio/#simplificando-o-codigo","text":"","title":"Simplificando o c\u00f3digo"},{"location":"inicio/#nomes-de-tipos","text":"Usando o comando typedef \u00e9 poss\u00edvel dar um nome mais curto a um tipo de dado. Por exemplo: 1 2 3 4 5 6 7 typedef long long ll ; typedef vector < int > vi ; typedef vector < ll > vll ; typedef pair < int , int > pi ; typedef pair < ll , ll > pll ; typedef vector < pii > vpi ; typedef vector < pll > vpll ;","title":"Nomes de tipos"},{"location":"inicio/#macros","text":"Uma macro significa que certas palavras no c\u00f3digo ser\u00e3o substitu\u00eddas antes da compila\u00e7\u00e3o. Em C++, as macros s\u00e3o definidas usando a palavra-chave #define . Veja alguns exemplos: 1 2 3 4 5 6 7 8 9 10 11 #define F first #define S second #define PB push_back #define MP make_pair #define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i) #define INF 0x3f3f3f3f #define INFLL 0x3f3f3f3f3f3f3f3f #define all(x) x.begin(),x.end() #define sz(x) (ll)x.size() #define MOD 1000000007ll #define endl '\\n' Assim, por exemplo, o c\u00f3digo for ( long long i = 0 ; i < n ; ++ i ) pode ser simplificado por FOR ( i , 0 , n ) .","title":"Macros"},{"location":"inicio/#dicas-e-truques-de-c","text":"A seguir, s\u00e3o listados alguns links com dicas e truques de C++ \u00fateis para programa\u00e7\u00e3o competitiva. Leia todos com aten\u00e7\u00e3o: C++ tips and tricks Top 20 C++ Tricks for Competitive Programming Truques de programa\u00e7\u00e3o competitiva para programadores de C++","title":"Dicas e truques de C++"},{"location":"manipulacaobits/","text":"Manipula\u00e7\u00e3o de Bits Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequencia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequencia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valroes inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorerr\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois). Operadores sobre Bits Operador AND ( & e &= ) Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) . Operador OR inclusivo ( | e |= ) Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110 Operador OR exclusivo ( ^ e ^= ) Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110 Operador NOT ( ~ e ~= ) Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A formula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 . Operador de deslocamento \u00e0 esquerda ( << e <<= ) Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56 Operador de deslocamento \u00e0 direita ( >> e >>= ) Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010001 -> 16 a = a >> 1 // 00001010 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7 Fun\u00e7\u00f5es adicionais O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x) Alguns truques e aplica\u00e7\u00f5es Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois. std::bitset Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o . Links adicionais Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#manipulacao-de-bits","text":"Todos os dados em um programa de computador s\u00e3o internamente armazenados como n\u00fameros bin\u00e1rios, ou seja, uma sequencia de 0's ou 1's. Em C++ um n\u00famero do tipo int \u00e9 uma vari\u00e1vel de 32-bits, ou seja, todo n\u00famero int consiste de uma sequencia de 32 0's ou 1's. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int 43 \u00e9: 00000000000000000000000000101011 Normalmente, \u00e9 usada a representa\u00e7\u00e3o de bits com sinal de um n\u00famero, o que significa que n\u00fameros negativos e positivos podem ser representados. Por exemplo, o int de C++ \u00e9 um tipo com sinal, logo uma vari\u00e1vel desse tipo pode armazenar valroes inteiros entre \\(-2^{31}\\) e \\(2^{31} - 1\\) . O primeiro bit de uma representa\u00e7\u00e3o com sinal indica o sinal do n\u00famero (0 para n\u00fameros n\u00e3o-negativos e 1 para n\u00fameros negativos). O complemento de dois \u00e9 usado, o que significa que o oposto de um n\u00famero \u00e9 calculado primeiro invertendo todos os bits do n\u00famero e depois aumentando o n\u00famero em um. Por exemplo, a representa\u00e7\u00e3o do n\u00famero int -43 \u00e9: 11111111111111111111111111010101 Aten\u00e7\u00e3o Se um n\u00famero for maior que o limite superior da representa\u00e7\u00e3o de bits, ocorerr\u00e1 um overflow . Considerando uma vari\u00e1vel do tipo int , o pr\u00f3ximo n\u00famero depois de \\(2^{31} - 1\\) \u00e9 \\(-2^{31}\\) . int v = 2147483647 ; // (1) v ++ ; // (2) cout << v << \" \\n \" ; // -2147483648 (3) \\(01111111111111111111111111111111_2\\) . Deveria ser \\(2147483648_{10}\\) , mas esse valor n\u00e3o pode ser representado em bits usando uma vari\u00e1vel de 32-bits. \\(10000000000000000000000000000000_2\\) (lembre-se que \u00e9 utilizado complemento de dois).","title":"Manipula\u00e7\u00e3o de Bits"},{"location":"manipulacaobits/#operadores-sobre-bits","text":"","title":"Operadores sobre Bits"},{"location":"manipulacaobits/#operador-and-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se os bits correspondentes em ambos os operadores forem 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a & b -> 1 // 00000001 c = 10 // 00001010 d = 12 // 00001100 c & d -> 8 // 00001000 Dica Com o operador & , podemos verificar se um n\u00famero x \u00e9 par usando x & 1 . De forma geral, x \u00e9 divis\u00edvel por \\(2^k\\) se \\(x \\& (2^k \u2212 1) = 0\\) .","title":"Operador AND (&amp; e &amp;=)"},{"location":"manipulacaobits/#operador-or-inclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se pelo menos um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a | b -> 13 // 00001101 c = 10 // 00001010 d = 12 // 00001100 c | d -> 14 // 00001110","title":"Operador OR inclusivo (| e |=)"},{"location":"manipulacaobits/#operador-or-exclusivo-e","text":"Os bits s\u00e3o definidos como 1 no resultado, se exatamente um dos bits correspondentes em ambos os operandos for 1. Exemplos: a = 5 // 00000101 b = 9 // 00001001 a ^ b -> 12 // 00001100 c = 10 // 00001010 d = 12 // 00001100 c ^ d -> 6 // 00000110","title":"Operador OR exclusivo (^ e ^=)"},{"location":"manipulacaobits/#operador-not-e","text":"Produz um n\u00famero onde todos os bits s\u00e3o invertidos, ou seja, todos os bits 0 s\u00e3o definidos como 1 e vice-versa. O resultado do operador NOT depende do tamanho da representa\u00e7\u00e3o do bit, pois a opera\u00e7\u00e3o inverte todos os bits. Por exemplo, considerando um n\u00famero do tipo int (32-bits), o resultado ser\u00e1: a = 5 // 00000000 00000000 00000000 00000101 ~ a = -6 // 11111111 11111111 11111111 11111010 Dica A formula ~x = -x - 1 \u00e9 v\u00e1lida. Por exemplo, ~5 = 6 .","title":"Operador NOT (~ e ~=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-esquerda-e","text":"Desloca os bits do primeiro operando \u00e0 esquerda pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da direita com zero (0). Exemplos: a = 1 // 00000001 -> 1 a = a << 1 // 00000010 -> 2 a = a << 1 // 00000100 -> 4 a = a << 1 // 00001000 -> 8 a = a << 1 // 00010000 -> 16 b = 7 // 00000111 b = b << 1 // 00001110 -> 14 c = 7 // 00000111 c <<= 3 // 00111000 -> 56","title":"Operador de deslocamento \u00e0 esquerda (&lt;&lt; e &lt;&lt;=)"},{"location":"manipulacaobits/#operador-de-deslocamento-a-direita-e","text":"Desloca os bits do primeiro operando \u00e0 direita pelo n\u00famero de bits especificado pelo segundo operando (deve ser um valor positivo): preenche a partir da esquerda com zero (0). Exemplos: a = 16 // 00010001 -> 16 a = a >> 1 // 00001010 -> 8 a = a >> 1 // 00000100 -> 4 a = a >> 1 // 00000010 -> 2 a = a >> 1 // 00000001 -> 1 a = a >> 1 // 00000000 -> 0 b = 56 // 00111000 b = b >> 3 // 00000111 -> 7 c = 56 // 00111000 c >>= 3 // 00000111 -> 7","title":"Operador de deslocamento \u00e0 direita (&gt;&gt; e &gt;&gt;=)"},{"location":"manipulacaobits/#funcoes-adicionais","text":"O compilador g++ fornece as seguintes fun\u00e7\u00f5es para contar bits: __builtin_clz(x) : o n\u00famero de zeros no in\u00edcio do n\u00famero int ; __builtin_ctz(x) : o n\u00famero de zeros no final do n\u00famero int ; __builtin_popcount(x) : o n\u00famero de uns no n\u00famero int ;; __builtin_parity(x) : a paridade (par ou \u00edmpar) de uns de um n\u00famero int .; Veja um exemplo de utiliza\u00e7\u00e3o dessas fun\u00e7\u00f5es: 1 2 3 4 5 int x = 5328 ; // 00000000000000000001010011010000 cout << __builtin_clz ( x ) << \" \\n \" ; // 19 cout << __builtin_ctz ( x ) << \" \\n \" ; // 4 cout << __builtin_popcount ( x ) << \" \\n \" ; // 5 cout << __builtin_parity ( x ) << \" \\n \" ; // 1 Embora as fun\u00e7\u00f5es acima sejam apenas para n\u00fameros int , tamb\u00e9m existem vers\u00f5es das fun\u00e7\u00f5es que suportam long e long long bastando adicionar o sufixo l ou ll no nome das fun\u00e7\u00f5es. __builtin_clzl(x) ou __builtin_clzll(x) __builtin_ctzl(x) ou __builtin_ctzll(x) __builtin_popcountl(x) ou __builtin_popcountll(x) __builtin_parityl(x) ou __builtin_parityll(x)","title":"Fun\u00e7\u00f5es adicionais"},{"location":"manipulacaobits/#alguns-truques-e-aplicacoes","text":"Um n\u00famero da forma 1 << k tem um bit na posi\u00e7\u00e3o k e todos os outros bits s\u00e3o zero, ent\u00e3o esse n\u00famero pode ser usado para acessar bits \u00fanicos de n\u00fameros. Em particular, o \\(k\\) -\u00e9simo bit de um n\u00famero \u00e9 1 exatamente quando x & (1 << k) n\u00e3o \u00e9 zero. Por exemplo, para imprimir a representa\u00e7\u00e3o de bits de um n\u00famero int pode ser usado o seguinte c\u00f3digo: 1 2 3 4 for ( int i = 31 ; i >= 0 ; i -- ) { if ( x & ( 1 << i )) cout << \"1\" ; else cout << \"0\" ; } Outras aplica\u00e7\u00f5es: x = x | (1 << k) : define o \\(k\\) -\u00e9simo bit de x para 1; x = x & ~(1 << k) : define o \\(k\\) -\u00e9simo bit de x para 0; x = x ^ (1 << k) : inverte o \\(k\\) -\u00e9simo bit de x ; x = x & (x \u2212 1) : define o \u00faltimo bit 1 de x como zero; x = x & \u2212x : define todos os bits 1 como 0, exceto o \u00faltimo bit 1; x = x | (x \u2212 1) : inverte todos os bits ap\u00f3s o \u00faltimo bit 1; x & (x \u2212 1) : se x for um n\u00famero positivo, verifica se x \u00e9 uma pot\u00eancia de dois.","title":"Alguns truques e aplica\u00e7\u00f5es"},{"location":"manipulacaobits/#stdbitset","text":"Bitset \u00e9 um cont\u00eainer da Standard Template Library do C++ que representa uma sequ\u00eancia de tamanho fixo de \\(N\\) bits. Bitsets podem ser manipulados por operadores l\u00f3gicos padr\u00e3o e convertidos para inteiros ou strings. Exemplos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bitset < 8 > a ( 42 ); // 00101010 bitset < 32 > b ( 42 ); // 00000000000000000000000000101010 bitset < 32 > c ( \"110010\" ); // 00000000000000000000000000110010 int d = c . to_ulong (); // 50 bitset < 4 > b1 ( \"0110\" ); bitset < 4 > b2 ( \"0011\" ); cout << \"b1 & b2: \" << ( b1 & b2 ) << '\\n' ; // b1 & b2: 0010 cout << \"b1 | b2: \" << ( b1 | b2 ) << '\\n' ; // b1 | b2: 0111 cout << \"b1 ^ b2: \" << ( b1 ^ b2 ) << '\\n' ; // b1 ^ b2: 0101 bitset < 8 > e ; //00000000 e . set (); //11111111 e . reset (); //00000000 e . set ( 3 ); //00001000 e . set ( 3 , 0 ); //00000000 e . flip ( 0 ); //00000001 e . flip ( 1 ); //00000011 e . flip ( 7 ); //10000011 e . flip (); //01111100 bitset < 8 > f { 0b01110010 }; cout << f << \" \\n \" ; //01110010 cout << ( f >>= 1 ) << \" \\n \" ; //00111001 cout << ( f >>= 1 ) << \" \\n \" ; //00011100 cout << ( f >>= 2 ) << \" \\n \" ; //00000111 cout << ( f <<= 3 ) << \" \\n \" ; //00111000 cout << f . count () << \" \\n \" ; // 3 Explore mais o cont\u00eainer atrav\u00e9s da documenta\u00e7\u00e3o .","title":"std::bitset"},{"location":"manipulacaobits/#links-adicionais","text":"Bitwise Operations tutorial #1 | XOR, Shift, Subsets C++ Bitsets in Competitive Programming C Bitwise Operators: AND, OR, XOR, Complement and Shift Operations Bitwise Operators in C/C++ - GeeksforGeeks Bits manipulation (Important tactics) - GeeksforGeeks Bitwise Hacks for Competitive Programming - GeeksforGeeks Bit Tricks for Competitive Programming - GeeksforGeeks Bitwise Algorithms - GeeksforGeeks Builtin functions of GCC compiler - GeeksforGeeks Bit Manipulation | HackerEarth Manipula\u00e7\u00e3o de Bits | Neps Academy C++ bitset and its application","title":"Links adicionais"},{"location":"matematica/","text":"Matem\u00e1tica Em constru\u00e7\u00e3o...","title":"Matem\u00e1tica"},{"location":"matematica/#matematica","text":"Em constru\u00e7\u00e3o...","title":"Matem\u00e1tica"},{"location":"ordenacao/","text":"Ordena\u00e7\u00e3o e Busca Em constru\u00e7\u00e3o...","title":"Ordena\u00e7\u00e3o e Busca"},{"location":"ordenacao/#ordenacao-e-busca","text":"Em constru\u00e7\u00e3o...","title":"Ordena\u00e7\u00e3o e Busca"},{"location":"pd/","text":"Programa\u00e7\u00e3o Din\u00e2mica Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o din\u00e2mica"},{"location":"pd/#programacao-dinamica","text":"Em constru\u00e7\u00e3o...","title":"Programa\u00e7\u00e3o Din\u00e2mica"},{"location":"strings/","text":"Processamento de Strings Em constru\u00e7\u00e3o...","title":"Processamento de strings"},{"location":"strings/#processamento-de-strings","text":"Em constru\u00e7\u00e3o...","title":"Processamento de Strings"}]}